%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="abstract_views_viewtypes">
#title("Abstract Views and Viewtypes")

#para('\

I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out #emphasis("conceptually") whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

')

<sect1
id="memory-allocation-deallocation">
#title("Memory Allocation and Deallocation")

#para("\

The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time may not
even be allowed.  Handling memory management safely and efficiently is a long
standing problem of great challenge in programming, and its novel solution
in ATS is firmly rooted in the paradigm of programming with theorem-proving
(PwTP).

")

#para('\

The following function #dyncode("malloc_gc") is available in ATS for memory
allocation:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

The sort #stacode("agz") is a subset sort defined for addresses that are not
null:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

Given an integer N, the type #stacode("b0ytes(N)") is a shorthand for
#stacode("@[byte?][N]"), which is for an array of N uninitialized
bytes. Therefore, the at-view #stacode("b0ytes(N)@L") is the same as the
array-view #stacode("array_v(byte?, L, N)"), where L is a memory location.
The view constructor #stacode("mfree_gc_v") is abstract. For a given
location L, the view #stacode("mfree_gc_v(L)") stands for a form of
capability that allows allocated memory at location L to be freed (or
reclaimed) by the following function #dyncode("mfree_gc"):

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

Note that #stacode("mfree_gc_v(L)") is so far the first form of view we
have encountered that is not built on top of any at-views.

')

#para('\

In practice, it is rather cumbersome to deal with bytes directly.  The
function #dyncode("ptr_alloc") is available for allocating memory to store
a single value (of certain type) and the function #dyncode("ptr_free") for
deallocating such memory:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

In addition, the function #dyncode("array_ptr_alloc") is for allocating
memory to store an array of values (of certain type), and the function
#dyncode("array_ptr_free") is for deallocating such memory:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')

#para('\

I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
#dyncode("msort1") and #dyncode("msort2") perform merge-sort on a given array:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

It is well-known that merging two sorted segments of a given array requires
additional space. When #dyncode("msort1") is called on arrays A and B, the
array A is the one to be sorted and the array B is some kind of scratch
area needed to perform merging (of sorted array segments). When a call to
#dyncode("msort1") returns, the sorted version of A is still sotred in
A. What #dyncode("msort2") does is similar but the sorted version of A is
stored in B when a call to #dyncode("msort2") returns.  As a good exercise,
I suggest that the interested reader take the effort to give a mutually
recursive implementation of #dyncode("msort1") and #dyncode("msort2").  An
implementation of merge-sort based on #dyncode("msort1") can be readily
given as follows:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

')

#para('\

The entire implementation of merge-sort on arrays plus some testing code is
available #mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "on-line").

')

</sect1><!--id="memory-allocation-deallocation-->

<!-- ****** ****** -->

<sect1
id="simple-linear-objects">
#title("Simple Linear Objects")

#para("\

Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name #emphasis("simple linear object") here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.

")

</sect1><!--id="simple-linear-objects"-->

</chapter><!--id="abstract_views_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
