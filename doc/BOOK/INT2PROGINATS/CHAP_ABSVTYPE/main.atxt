%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
 id="abstract_views_viewtypes">
#title("Abstract Views and Viewtypes")

#para('\

I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out #emphasis("conceptually") whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

')

<!-- ****** ****** -->

<sect1
 id="simple-linear-objects">
#title("Simple Linear Objects")

#para("\

Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name #emphasis("simple linear object") here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.\

")

#para('\

Let us now take a look at a concrete example of simple linear object.
The following code presents an interface for a timer (that is, stopwatch):

#atscode('\
absvtype timer_vtype
vtypedef timer = timer_vtype

fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
')

The state of a timer is given the
record type #stacode("timer_struct") defined as follows:

#atscode('\
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
')

The following linear datatype #stacode("timer")
is declared for timers, and the abstract type #stacode("timer_vtype")
is assumed to equal #stacode("timer"):

#atscode('\
//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
')

')

#para('\

Various functions on timers can now be readily implemented.
Let us first see the code for creating and freeing timers:

#atscode('\

implement
timer_new () = let
//
val timer = TIMER (_)
val TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val ~TIMER _ = timer in (*nothing*) end
// end of [timer_free]
')

')

#para('\

The function for starting a timer can be implemented as follows:

#atscode('\
implement
timer_start
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := true
  val () = x.running := true
  val () = x.ntick_beg := the_current_tick_get ()
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_start]
')

where #dyncode("the_current_tick_get") is a function for
reading the current time (represented as a number of ticks):

#atscode('\
extern fun the_current_tick_get (): uint
')

')

#para('\

A timer can be stopped or paused. The function for stopping a timer can be
implemented as follows:

#atscode('\
implement
timer_finish
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_finish]
')

')

#para('\

A timer can be paused and then resumed.
The following code implements the functions for pausing and resuming a
timer:

#atscode('\
implement
timer_pause
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_pause]

implement
timer_resume
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.started && ~(x.running) then
  {
    val () = x.running := true
    val () = x.ntick_beg := the_current_tick_get ()
  } (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_resume]
')

As can be expected, the amount of time between the point
where a timer is paused and the point where the timer is resumed
is not counted.

')

#para('\

It is also possible to reset a timer by calling the function
#dyncode("timer_reset"):

#atscode('\
implement
timer_reset
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () = x.running := false
  val () = x.ntick_beg := 0u
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_reset]
')

')

#para('\

In order to read the time accumulated by a timer,
the function #dyncode("timer_get_ntick") can be called:

#atscode('\
implement
timer_get_ntick
  (timer) = let
  val+@TIMER(x) = timer
  var ntick: uint = x.ntick_acc
  val () =
  if x.running then (
    ntick := ntick + the_current_tick_get () - x.ntick_beg
  ) (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  ntick
end // end of [timer_get_ntick]
')

')

#para('\

A straightforward approach to
implementing #dyncode("the_current_tick_get")
can be based directly on the function #dyncode("clock_gettime"):

#atscode('\
local

staload "libc/SATS/time.sats"

in (* in-of-local *)

implement
the_current_tick_get () = let
  var tv: timespec // uninitialized
  val err = clock_gettime (CLOCK_REALTIME, tv)
  val ((*void*)) = assertloc (err >= 0)
  prval ((*void*)) = opt_unsome{timespec}(tv)
in
  $UNSAFE.cast2uint(tv.tv_sec)
end // end of [the_current_tick_get]

end // end of [local]
')

Note that the library flag #dyncode("-lrt") may be needed in order to
have link-time access to #dyncode("clock_gettime") as the function is in
#dyncode("librt").

')

#para('\

Please find #mycodelink("CHAP_ABSVTYPE/timer.dats", "on-line") the
entirety of the code presented in this section plus some testing code.

')

</sect1><!--id="simple-linear-objects"-->

<!-- ****** ****** -->

<sect1
 id="memory-allocation-deallocation">
#title("Memory Allocation and Deallocation")

#para("\

The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time may not
even be allowed.  Handling memory management safely and efficiently is a long
standing problem of great challenge in programming, and its novel solution
in ATS is firmly rooted in the paradigm of programming with theorem-proving
(PwTP).

")

#para('\

The following function #dyncode("malloc_gc") is available in ATS for memory
allocation:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

The sort #stacode("agz") is a subset sort defined for addresses that are not
null:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

Given an integer N, the type #stacode("b0ytes(N)") is a shorthand for
#stacode("@[byte?][N]"), which is for an array of N uninitialized
bytes. Therefore, the at-view #stacode("b0ytes(N)@L") is the same as the
array-view #stacode("array_v(byte?, L, N)"), where L is a memory location.
The view constructor #stacode("mfree_gc_v") is abstract. For a given
location L, the view #stacode("mfree_gc_v(L)") stands for a form of
capability that allows allocated memory at location L to be freed (or
reclaimed) by the following function #dyncode("mfree_gc"):

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

Note that #stacode("mfree_gc_v(L)") is so far the first form of view we
have encountered that is not built on top of any at-views.

')

#para('\

In practice, it is rather cumbersome to deal with bytes directly.  The
function #dyncode("ptr_alloc") is available for allocating memory to store
a single value (of certain type) and the function #dyncode("ptr_free") for
deallocating such memory:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

In addition, the function #dyncode("array_ptr_alloc") is for allocating
memory to store an array of values (of certain type), and the function
#dyncode("array_ptr_free") is for deallocating such memory:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')

#para('\

I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
#dyncode("msort1") and #dyncode("msort2") perform merge-sort on a given array:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

It is well-known that merging two sorted segments of a given array requires
additional space. When #dyncode("msort1") is called on arrays A and B, the
array A is the one to be sorted and the array B is some kind of scratch
area needed to perform merging (of sorted array segments). When a call to
#dyncode("msort1") returns, the sorted version of A is still sotred in
A. What #dyncode("msort2") does is similar but the sorted version of A is
stored in B when a call to #dyncode("msort2") returns.  As a good exercise,
I suggest that the interested reader take the effort to give a mutually
recursive implementation of #dyncode("msort1") and #dyncode("msort2").  An
implementation of merge-sort based on #dyncode("msort1") can be readily
given as follows:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

')

#para('\

It is also allowed for a function to allocate memory on its call-stack
by calling a special function #dyncode("alloca"), which is given the
following type in ATS:

#atscode('\
(*
staload "libc/SATS/alloa.sats"
*)
fun alloca
  {dummy:addr}{n:int} (
  pf: void@dummy | n: size_t (n)
) : [l:addr] (bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l))
')

The type assigned to
#dyncode("alloca") makes it extremely unlikely for someone to
unintentionally write well-typed code in ATS that may erroneourly attempt
to access memory obtained from calling #dyncode("alloca") after the calling
function has returned.

')

#para('\

The following function #dyncode("array_ptr_alloca_tsz") is the
same as #dyncode("alloca") dynamically but it is given a type that
is often more convenient to use:

#atscode('\
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
')

As an example, the function template #dyncode("mergeSort") implemented
above can also be implemented as follows:

#atscode('\
implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val tsz = sizeof<a>
  var dummy: void = ()
  prval pf = view@dummy
  val (
    pfat, fpfat | p
  ) = array_ptr_alloca_tsz{a}(pf | n, tsz)
  val ((*void*)) = msort1<a> (A, n, !p, cmp)
  prval ((*void*)) = view@dummy := fpfat (pfat)
in
  // nothing
end // end of [mergeSort]
')

where the array used as a scratch area during merge-sort is allocated on
the call-stack of #dyncode("mergeSort"). While this implementation of
#dyncode("mergeSort") may seem interesting, it is actually inferior to the
previous implementation as calling #dyncode("alloca") to allocate a large
chunk of memory can readily lead to a crash for which the cause is often
very difficult to determine. In general, choosing #dyncode("alloca") over
#dyncode("malloc") is difficult to justify, and any call to the former
should be scrutinized.

')

#para('\

The entire implementation of merge-sort on arrays plus some testing code
is available #mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "on-line").

')

</sect1><!--id="memory-allocation-deallocation"-->

<!-- ****** ****** -->

<sect1
 id="array-based-circular-buffers">
#title("\
Example: Array-Based Circular Buffers\
")

#para("\

Array-based circular buffers are of common use in practice. For instance,
in a typical client/server model, a circular buffer can be employed to hold
requests issued by multiple clients that are then processed by the server
according to the first-in-first-out (FIFO) policy. In a case where each
request needs to be given a priority (chosen from a fixed set), a circular
buffer can be created for each priority to hold requests of that particular
priority.\

")

#para("\

Let us declare a linear abstract type (that is, abstract viewtype) as
follows for values representing circular buffers:

#atscode('\
absvtype
cbufObj (a:vt@ype+, m:int, n: int) = ptr
')

Such values are considered simple linear objects (as inheritance is not an
issue to be dealt with in this setting). Given a viewtype VT and two
integers M and N, the viewtype #stacode("cbufObj(VT, M, N)") is for a given
buffer of maximal capacity M that currently holds N elements of the type
VT.

")

#para("\

Some properties on the parameters of #stacode("cbufObj") can be captured
by introducing the following proof function:

#atscode('\
prfun
lemma_cbufObj_param
  {a:vt0p}{m,n:int}
  (buf: !cbufObj(a, m, n)): [m>=n; n>=0] void
')

The interface for the following two function templates indicates that they
can be called to compute the capacity and current size of a buffer:

#atscode('\
fun{a:vt0p}
cbufObj_get_cap
  {m,n:int} (buf: !cbufObj(a, m, n)): size_t(m)

fun{a:vt0p}
cbufObj_get_size
  {m,n:int}(buf: !cbufObj(a, m, n)): size_t(n)
')

")

#para("\

While it is straightforward to use #dyncode("cbufObj_get_cap") and
#dyncode("cbufObj_get_size") to tell whether a buffer is currently empty or
full, a direct approach is likely to be more efficient. The following two
function templates check for the emptiness and fullness of a given circular
buffer:

#atscode('\
//
fun{a:vt0p}
cbufObj_is_empty
  {m,n:int}(buf: !cbufObj(a, m, n)): bool(n==0)
//
fun{a:vt0p}
cbufObj_is_full
  {m,n:int}(buf: !cbufObj(a, m, n)): bool(m==n)
//
')

")

#para("\

The functions for creating and destroying circular buffers are named
#dyncode("cbufObj_new") and #dyncode("cbufObj_free"), respectively:

#atscode('\
fun{a:vt0p}
cbufObj_new
  {m:pos}(m: size_t(m)): cbufObj(a, m, 0)
//
fun cbufObj_free
  {a:vt0p}{m:int}(buf: cbufObj(a, m, 0)): void
')

Note that a buffer can be freed only if it contains no elements as
an element (of some viewtype) may contain resources. If elements in
a buffer are of some (non-linear) type, then the following function
can be called to clear out all the elements stored in the buffer:

#atscode('\
fun
cbufObj_clear
  {a:t@ype}{m,n:int}
  (buf: !cbufObj(a, m, n) >> cbufObj(a, m, 0)): void
// end of [cbufObj_clear]
')

")

#para("\

The next two functions are for inserting/removing an element into/from a
given buffer, which are probably the most frequently used operations on
buffers:

#atscode('\
//
fun{a:vt0p}
cbufObj_insert
  {m,n:int | n < m}
(
  buf: !cbufObj(a, m, n) >> cbufObj(a, m, n+1), x: a
) : void // end of [cbufObj_insert]
//
fun{a:vt0p}
cbufObj_remove
  {m,n:int | n > 0}
  (buf: !cbufObj(a, m, n) >> cbufObj(a, m, n-1)): (a)
//
')

")

#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
containing the entirety of the interface for functions creating, destroying
and manipulating circular buffers.\

")

#para("\

There are many simple and practical ways to implement the abstract type
#stacode("cbufObj") and the functions declared in
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats").  In the file
#mycodelink("CHAP_ABSVTYPE/circbuf.dats", "circbuf.dats"), I give an
implementation that employs four pointers p_beg, p_end, p_frst and p_last
to represent a circular buffer: p_beg and p_end are the starting and
finishing addresses of the underline array, respectively, and p_frst and
p_last are the starting addresses of the occupied and unoccupied segments
(in the array), respectively. What is special about this implementation is
its employing a style of programming that deliberately eschews the need for
proof construction. While code written in this style is not guaranteed to
be type-safe, the style can nonetheless be of great practical value in a
setting where constructing formal proofs is deemed too costly a requirement
to be fully fulfilled. Anyone who tries to give a type-safe implementation
for the functions declared in #mycodelink("CHAP_ABSVTYPE/circbuf.sats",
"circbuf.sats") should likely find some genuine appreciation for this
point.

")

#para("\

In the file #mycodelink("CHAP_ABSVTYPE/circbuf2.dats", "circbuf2.dats"), I
give another implementation in which a circular buffer is represented as a
pointer p_beg plus three integers m, n and f: p_beg points to the starting
location of the underline array, m is the size of the array (that is, the
capacity of the buffer), n is the number of elements currently stored in
the buffer and f is the total number of elements that have so far been
removed from the buffer. Again, proof construction is delibrately eschewed
in this implementation.

")

</sect1><!--id="array-based-circular-buffers"-->

<!-- ****** ****** -->

<sect1
 id="locking-and-unlocking">
#title("Locking and Unlocking")

#para("\

In concurrent programming, the issue of safely locking and unlocking
shared resources is both essential and challenging. I will demonstrate
here concretely and convincingly that linear types can be used with
great effectiveness to address this issue.

")

#para("\

Let us first introduce a linear abstract type #stacode("shared_vtype")
as follows:

#atscode('\
absvtype shared(a:vtype) = ptr
')

Given a viewtype VT (for some resources), a value of the type
#stacode("shared(VT)") is essentially a boxed record containing a resource
of the type VT plus a lock (or several) of some kind. The following
function #dyncode("shared_make") is called to turn a resource into a shared
resource:

#atscode('\
fun shared_make{a:vtype}(x: a): shared(a)  
')

Notice that the type #stacode("shared(VT)") itself is linear. In terms of
implementation, there is usually a reference count inside a linear shared
resource that is protected by a spin-lock. The functions
#dyncode("shared_ref") and #dyncode("shared_unref") are for increasing and
descreasing the reference count inside a shared resource:

#atscode('\
fun shared_ref{a:vtype}(!shared(a)): shared(a)
fun shared_unref{a:vtype}(shared(a)): Option_vt(a)
')

If the reference count of a shared resource is 1, then calling
#dyncode("shared_unref") on the shared resource frees the memory used in
its representation and then returns the resource stored inside it.

")

#para("\

The function #dyncode("shared_lock") acquires the resource from a
given shared resource and the function #dyncode("shared_unlock") does
the opposite:

#atscode('\
//
absview locked_v
//
fun shared_lock{a:vtype}(!shared(a)): (locked_v | a)
fun shared_unlock{a:vtype}(locked_v | !shared(a), x: a): void
//
')

Note that the abstract view #stacode("locked_v") is introduced for linear
proofs that are meant to remind the programmer that a shared resoure needs
to be released after it is acquired.

")

#para("\

As can be expected, a shared resource can be implemented as a boxed tuple
consisting of a spin-lock, a reference count and a pointer (referring to
the stored resource):

#atscode('\
//
datavtype
shared_ (a:vtype) =
  SHARED of (spin1_vt(*lock*), int(*count*), ptr)
//
assume shared = shared_
//
')

Note that the type #stacode("spin1_vt") is for linear spin-locks. The
function #dyncode("shared_ref") is implemented as follows:

#atscode('\
implement
shared_ref
  {a}(sh) = let
//
val+@SHARED
  (spin, count, _) = sh
//
val
spin = // for temp. use
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
val c0 = count
val () = count := c0 + 1
val ((*void*)) = spin_unlock(pf | spin)
prval ((*void*)) = fold@sh
//
in
  $UN.castvwtp1{shared(a)}(sh)
end // end of [shared_ref]
')

Clearly, the implementation makes use of several unsafe casts.  An
implementation without such casts would be highly involved even if it could
be done.  The spin-lock must be acquired before the binding between
#dyncode("c0") and the integer stored in #dyncode("count") is formed for
otherwise a race condition can appear. The function #dyncode("shared_unref")
is implemented as follows:

#atscode('\
implement
shared_unref
  {a}(sh) = let
//
val+@SHARED
  (spin, count, _) = sh
//
val
spin = // for temp. use
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
val c0 = count
val () = count := c0 - 1
val ((*void*)) = spin_unlock(pf | spin)
prval ((*void*)) = fold@sh
//
in
//
if
c0 <= 1
then let
  val+~SHARED(spin, _, x) = sh
  val ((*freed*)) = spin_vt_destroy(spin)
in
  Some_vt($UN.castvwtp0{a}(x))
end // end of [then]
else let
  prval () = $UN.cast2void(sh) in None_vt()
end // end of [else]
//
end // end of [shared_unref]
')

In the case where the reference count is 1,
then the shared resource is freed, the spin-lock in it
is destroyed, and the resource in it is returned.

")

#para("\

The functions
#dyncode("shared_lock")
and
#dyncode("shared_unlock")
are implemented as follows:

#atscode('\
implement
shared_lock
  {a}(sh) = let
//
val+@SHARED(spin, _, x) = sh
//
val
spin =
  unsafe_spin_vt2t(spin)
//
val
(pf | ()) = spin_lock(spin)
//
val x0 = $UN.castvwtp0{a}(x)
//
prval () = fold@sh
//
in
  ($UN.castview0(pf) | x0)
end // end of [shared_lock]
')

#atscode('\
implement
shared_unlock
  {a}(pf | sh, x0) = let
//
val+@SHARED(spin, _, x) = sh
//
val
spin =
  unsafe_spin_vt2t(spin)
//
val () = x := $UN.castvwtp0{ptr}(x0)
//
val () =
  spin_unlock($UN.castview0(pf) | spin)
//
prval () = fold@sh
//
in
  // nothing
end // end of [shared_unlock]
')

In the case of #dyncode("shared_lock"), please notice that the content
stored in the variable #dyncode("x") is read out after the spin-lock is
acquired. This is crucial for otherwise a race condition can readily
appear. In the case of #dyncode("shared_unlock"), the content of the
variable #dyncode("x") is updated before the acquired spin-lock is
released.\

")

#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/shared_vt.dats", "shared_vt.dats")
containing the entirety of the code presented in this section. In addition,
the file also contains an implementation of three threads that move in
locked steps: thread 0 moves; thread 1 moves; thread 2 moves; thread 0
moves; thread 1 moves; thread 2 moves; etc.\

")

</sect1><!--id="locking-and-unlocking"-->

<!-- ****** ****** -->

<sect1
 id="linear-channels-for-async-ipc">
#title("Linear Channels for Asynchronous IPC")

#para("\

In this section, I will present an implementation of
linear channels to support asynchronous communication between threads. This
is also a very fitting occasion for me to advocate what I often refer to as
#emphasis("programmer-centric") program verification.\

")

#para("\

A communication channel between threads is essentially
a queue wrapped in some kind of protection mechanism needed for guarding
against race conditions.  Assume that a queue is of a fixed capacity, that
is, the capacity of the queue is fixed after its creation. If the queue is
full, then inserting an element into it results in a failure.  If the queue
is empty, then removing an element from it results in a failure. In order
to prevent inserting into a full queue or removing from an empty queue, I
could first introduce a linear abstract type for queues as follows:

#atscode("\
absvtype
queue_vtype(a:vt@ype+, int(*m*), int(*n*))
vtypedef queue(a:vt@ype,m:int,n:int) = queue_vtype(a,m,n)
")

where the type #stacode("queue(VT,M,N)") is for a queue of capacity M that
currently contains N elements of type VT. Then the functions for inserting
into and removing from a queue are expected to be given the following
interface:

#atscode("\
//
fun{a:vt0p}
queue_insert
  {m,n:nat | m > n}
  (!queue(a, m, n) >> queue(a, m, n+1), a): void
//
fun{a:vt0p}
queue_remove
  {m,n:nat | n > 0}(!queue(a, m, n) >> queue(a, m, n-1)): (a)
//
")

The presented abstract type #stacode("queue") can indeed work very well for
the task of implementing linear channels. However, I will not continue with
this version of #stacode("queue") further for I intend to present a style of
program verification that is less rigorous but far more flexible.

")

#para("\

Following is another version of abstract type #stacode("queue"):

#atscode("\
//
absvtype
queue_vtype(a:vt@ype+, int(*id*)) = ptr
//
vtypedef
queue(a:vt0p, id:int) = queue_vtype(a, id)
vtypedef queue(a:vt0p) = [id:int] queue(a, id)
//
")

Given a viewtype VT and an integer ID, #stacode("queue(VT,ID)") is for a
queue containing elements of the type VT that can be uniquely identified
with the integer ID. So one may think of ID as some form of stamp. The
following declared function #dyncode("queue_isnil") is for testing whether
a given queue is empty:


#atscode("\
//
absprop ISNIL(id:int, b:bool)
//
fun
{a:vt0p}
queue_isnil{id:int}(!queue(a, id)): [b:bool] (ISNIL(id, b) | bool(b))
//
")

Given an integer ID, a proof of the prop #stacode("ISNIL(ID,true)")
(#stacode("ISNIL(ID,false)")) means that the queue uniquely identified by
ID is (not) empty. Similarly, the following declared function
#dyncode("queue_isful") is for testing whether a given queue is full:

#atscode("\
//
absprop ISFUL(id:int, b:bool)
//
fun
{a:vt0p}
queue_isful{id:int}(!queue(a, id)): [b:bool] (ISFUL(id, b) | bool(b))
//
")

Given an integer ID, a proof of the prop #stacode("ISFUL(ID,true)")
(#stacode("ISFUL(ID,false)")) means that the queue uniquely identified by
ID is (not) full.

")

#para("\

The functions #dyncode("queue_insert") and #dyncode("queue_remove")
for inserting into and removing from a given queue can now be given the
following interface:

#atscode("\
//
extern
fun
{a:vt0p}
queue_insert
  {id:int}
(
  ISFUL(id, false)
| xs: !queue(a, id) >> queue(a, id2), x: a
) : #[id2:int] void
//
extern
fun
{a:vt0p}
queue_remove
  {id:int}
(
  ISNIL(id, false) | xs: !queue(a, id) >> queue(a, id2)
) : #[id2:int] a // end-of-fun
//
")

Note that either inserting an element into a queue or removing an element
from a queue assigns a new stamp to the queue.  This is essential for
interpreting #stacode("ISNIL") and #stacode("ISFUL") in the manner presented
above.

")

#para("\

In order to call #dyncode("queue_insert") on a given queue, one needs to
have a proof attesting to the queue being not full. Such a proof is
obtained if calling #dyncode("queue_isful") on the queue returns false.
Similarly, in order to call #dyncode("queue_remove") on a given queue,
one can first call #dyncode("queue_isnil") on the queue to obtain a proof
attesting to the queue being not empty.\

")

#para("\

What is really of concern here is not to actually verify that
#dyncode("queue_isnil") and #dyncode("queue_isful") have the interface
assigned to them. Instead, the focus is on ensuring that
#dyncode("queue_insert") is never applied to a full queue and
#dyncode("queue_remove") is never applied to an empty queue under the
assumption that #dyncode("queue_isnil") and #dyncode("queue_isful") have
the assigned interface. I refer to this form of program verification as
being #emphasis("programmer-centric") because its correctness is not
formally established in an objective manner. I myself find that
programmer-centric programm verification is very flexible and effective in
practice.  If we believe that constructing informal mathematical proofs can
help one check whether the proven statements are valid, then it is only
natural to believe that programmer-centric program verification can also
help one check whether verified programs are correct.\

")

#para("\

Let us now start to implement linear channels for asynchronous
communication between threads. First, let us declare a linear abstract
type #stacode("channel") as follows:


#atscode("\
absvtype channel_vtype(a:vt@ype+) = ptr
vtypedef channel(a:vt0p) = channel_vtype(a)
")

The function for inserting an element into a channel is given the following
interface:

#atscode("\
fun{a:vt0p} channel_insert (!channel(a), a): void
")

The caller of #dyncode("channel_insert") is blocked if the channel is full.
Similarly, the function for removing an element from a channel is given the following
interface:

#atscode("\
fun{a:vt0p} channel_remove (chan: !channel(a)): (a)
")

The caller of #dyncode("channel_remove") is blocked if the channel is empty.

")

#para("\

Let a channel be represented as follows:

#atscode("\
//
datavtype
channel_ =
{
l0,l1,l2,l3:agz
} CHANNEL of
@{
  cap=intGt(0)
, spin=spin_vt(l0)
, rfcnt=intGt(0)
, mutex=mutex_vt(l1)
, CVisnil=condvar_vt(l2)
, CVisful=condvar_vt(l3)
, queue=ptr // deqarray
} (* end of [channel] *)
//
assume channel_vtype(a:vt0p) = channel_
//
")

There are 7 fields in the record representing a channel; the
#dyncode("cap") field stores an integer indicating the (fixed) capacity of
the channel; the #dyncode("spin") field stores a spin-lock for protecting
the reference count in the field of the name #dyncode("rfcnt"); the
#dyncode("mutex") field stores a mutex for protecting the queue in the
field of the name #dyncode("queue"); the field #dyncode("CVisnil") stores a
conditional variable for the situation where a caller (holding the mutex)
wants to wait for the condition that the queue becomes not empty; the
field #dyncode("CVisful") stores a conditional variable for the situation
where a caller (holding the mutex) wants to wait for the condition that the
queue becomes not full.

")

#para("\

The function
#dyncode("channel_insert") is given the following implementation:

#atscode("\
implement
{a}(*tmp*)
channel_insert
  (chan, x0) = let
//
val+CHANNEL
  {l0,l1,l2,l3}(ch) = chan
val mutex = unsafe_mutex_vt2t(ch.mutex)
val (pfmut | ()) = mutex_lock (mutex)
val xs =
  $UN.castvwtp0{queue(a)}((pfmut | ch.queue))
val ((*void*)) = channel_insert2<a> (chan, xs, x0)
prval pfmut = $UN.castview0{locked_v(l1)}(xs)
val ((*void*)) = mutex_unlock (pfmut | mutex)
//
in
  // nothing
end // end of [channel_insert]
")

where
the auxiliary function #dyncode("channel_insert2") is given
the following interface:

#atscode("\
fun{a:vt0p}
channel_insert2
  (!channel(a), !queue(a) >> _, a): void
")

Please note that #dyncode("channel_insert2") is called when
the caller is holding the mutex inside the channel. Following
is an implementation for #dyncode("channel_insert2"):

#atscode("\
implement
{a}(*tmp*)
channel_insert2
  (chan, xs, x0) = let
//
val+CHANNEL
  {l0,l1,l2,l3}(ch) = chan
//
val (pf | isful) = queue_isful (xs)
//
in
//
if
isful
then let
  prval
  (pfmut, fpf) =
  __assert () where
  {
    extern
    praxi __assert (): vtakeout0(locked_v(l1))
  }
  val mutex = unsafe_mutex_vt2t(ch.mutex)
  val CVisful = unsafe_condvar_vt2t(ch.CVisful)
  val ((*void*)) = condvar_wait (pfmut | CVisful, mutex)
  prval ((*void*)) = fpf (pfmut)
in
  channel_insert2 (chan, xs, x0)
end // end of [then]
else let
  val isnil = queue_isnil (xs)
  val ((*void*)) = queue_insert (pf | xs, x0)
  val ((*void*)) =
  if isnil.1
    then condvar_broadcast(unsafe_condvar_vt2t(ch.CVisnil))
  // end of [if]
in
  // nothing
end // end of [else]
//
end // end of [channel_insert2]
")

The logic behind #dyncode("channel_insert2") can be explained as follows.
If the queue in the given channel is full, the caller calls
#dyncode("condvar_wait") to release the mutex it holds and then wait on the
conditional variable stored in the field #dyncode("CVisful") of the
channel; after the caller regains the mutex after being awoken by a signal
sent to the conditioanl variable, it calls #dyncode("channel_insert2")
recursively. If the queue in the given channel is not full, then the caller
insert a given element into the queue stored in the field #dyncode("queue")
and then returns. Note that #dyncode("channel_insert2") is a tail-recursive
function that essentially corresponds to a standard while-loop often
appearing in C code for handling the wait on a conditional variable.\

")

#para("\

By following the above implementation for #dyncode("channel_insert") (and
#dyncode("channel_insert2")), it should be pretty straightforward for one
to figure out an implementation for #dyncode("channel_remove"). I leave it
as an exercise.

")

#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/channel_vt.dats", "channel_vt.dats")
containing the entirety of the code presented in this section plus some
code for testing.\

")

</sect1><!--id="linear-channels-for-async-ipc"-->

</chapter><!--id="abstract_views_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
