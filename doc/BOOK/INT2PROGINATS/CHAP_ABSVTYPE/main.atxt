%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="abstract_views_viewtypes">
#title("Abstract Views and Viewtypes")

#para('\

I have so far given a presentation of views that solely focuses on at-views
and the views built on top of at-views. This is largely due to at-views
being the form of most widely used views in practice and also being the
first form of views supported in ATS. However, other forms of views can be
readily introduced into ATS abstractly. Even in a case where a view can be
defined based on at-views (or other forms of views), one may still want to
introduce it as an abstract view (accompanied with certain proof functions
for performing view-changes). Often what the programmer really needs is to
figure out #emphasis("conceptually") whether abstractly defined views and
proof functions for manipulating them actually make sense. This is a bit
like arguing whether a function is computable: There is rarely a need, if
at all, to actually encode the function as a Turing-machine to prove its
being computable. IMHO, learning proper use of abstract views and abstract
viewtypes is a necessary step for one to take in order to employ linear
types effectively in practice to deal with resource-related programming
issues.

')

<!-- ****** ****** -->

<sect1
id="simple-linear-objects">
#title("Simple Linear Objects")

#para("\

Objects in the physical world are conspicuously linear: They cannot be
created from nothing or simply go vanished by turning into nothing. Thus,
it is only natural to assign linear types to values that represent physical
objects. I choose the name #emphasis("simple linear object") here to refer
to a linear value representing an object of some sort that does not contain
built-in mechanism for supporting inheritance.\

")

#para('\

Let us now take a look at a concrete example of simple linear object.
The following code presents an interface for a timer (that is, stopwatch):

#atscode('\
absvtype timer_vtype
vtypedef timer = timer_vtype

fun timer_new (): timer
fun timer_free (x: timer): void
fun timer_start (x: !timer): void
fun timer_finish (x: !timer): void
fun timer_pause (x: !timer): void
fun timer_resume (x: !timer): void
fun timer_get_ntick (x: !timer): uint
fun timer_reset (x: !timer): void
')

The state of a timer is given the
record type #stacode("timer_struct") defined as follows:

#atscode('\
typedef
timer_struct = @{
  started= bool // the timer has started
, running= bool // the timer is running
  // the tick number recorded when the timer
, ntick_beg= uint // was turned on last time
, ntick_acc= uint // the number of accumulated ticks
} (* end of [timer_struct] *)
')

The following linear datatype #stacode("timer")
is declared for timers, and the abstract type #stacode("timer_vtype")
is assumed to equal #stacode("timer"):

#atscode('\
//
datavtype timer =
  TIMER of (timer_struct)
//
assume timer_vtype = timer
//
')

')

#para('\

Various functions on timers can now be readily implemented.
Let us first see the code for creating and freeing timers:

#atscode('\

implement
timer_new () = let
//
val timer = TIMER (_)
val TIMER (x) = timer
//
val () = x.started := false
val () = x.running := false
val () = x.ntick_beg := 0u
val () = x.ntick_acc := 0u
//
prval () = fold@ (timer)
//
in
  timer
end // end of [timer_new]

implement
timer_free (timer) =
  let val ~TIMER _ = timer in (*nothing*) end
// end of [timer_free]

')

')

#para('\

The function for starting a timer can be implemented as follows:

#atscode('\
implement
timer_start
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := true
  val () = x.running := true
  val () = x.ntick_beg := the_current_tick_get ()
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_start]
')

where #dyncode("the_current_tick_get") is a function for
reading the current time (represented as a number of ticks):

#atscode('\
extern fun the_current_tick_get (): uint
')

')

#para('\

A timer can be stopped or paused. The function for stopping a timer can be
implemented as follows:

#atscode('\
implement
timer_finish
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_finish]
')

')

#para('\
A timer can be paused and then resumed.
The following code implements the functions for pausing and resuming a
timer:

#atscode('\

implement
timer_pause
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.running then
  {
    val () = x.running := false
    val () = x.ntick_acc :=
      x.ntick_acc + the_current_tick_get () - x.ntick_beg
  } (* end of [val] *)
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_pause]

implement
timer_resume
  (timer) = let
  val+@TIMER(x) = timer
  val () =
  if x.started && ~(x.running) then
  {
    val () = x.running := true
    val () = x.ntick_beg := the_current_tick_get ()
  } (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_resume]
')

As can be expected, the amount of time between the point
where a timer is paused and the point where the timer is resumed
is not counted.

')

#para('\

It is also possible to reset a timer by calling the function
#dyncode("timer_reset"):

#atscode('\
implement
timer_reset
  (timer) = let
  val+@TIMER(x) = timer
  val () = x.started := false
  val () = x.running := false
  val () = x.ntick_beg := 0u
  val () = x.ntick_acc := 0u
  prval () = fold@ (timer)
in
  // nothing
end // end of [timer_reset]
')

')

#para('\

In order to read the time accumulated by a timer,
the function #dyncode("timer_get_ntick") can be called:

#atscode('\
implement
timer_get_ntick
  (timer) = let
  val+@TIMER(x) = timer
  var ntick: uint = x.ntick_acc
  val () =
  if x.running then (
    ntick := ntick + the_current_tick_get () - x.ntick_beg
  ) (* end of [if] *) // end of [val]
  prval () = fold@ (timer)
in
  ntick
end // end of [timer_get_ntick]
')

')

#para('\

A straightforward approach to
implementing #dyncode("the_current_tick_get")
can be based directly on the function #dyncode("clock_gettime"):

#atscode('\
local

staload "libc/SATS/time.sats"

in (* in-of-local *)

implement
the_current_tick_get () = let
  var tv: timespec // uninitialized
  val err = clock_gettime (CLOCK_REALTIME, tv)
  val ((*void*)) = assertloc (err >= 0)
  prval ((*void*)) = opt_unsome{timespec}(tv)
in
  $UNSAFE.cast2uint(tv.tv_sec)
end // end of [the_current_tick_get]

end // end of [local]
')

Note that the library flag #dyncode("-lrt") is needed in order to
have link-time access to #dyncode("clock_gettime") as the function is in
#dyncode("librt").

')

#para('\

Please find #mycodelink("CHAP_ABSVTYPE/timer.dats", "on-line") the
entirety of the code presented in this section plus some testing code.

')

</sect1><!--id="simple-linear-objects"-->

<!-- ****** ****** -->

<sect1 id="array-based-circular-buffer">
#title("\
Example: An Array-Based Circular Buffer\
")

#para("\

Array-based circular buffers are of common use in practice. For instance,
in a typical client/server model, a circular buffer can be employed to hold
requests issued by multiple clients that are then processed by the server
according to the first-in-first-out (FIFO) policy. In a case where each
request needs to be given a priority (chosen from a fixed set), a circular
buffer can be created for each priority to hold requests of that particular
priority.\

")

#para("\

Let us declare a linear abstract type (that is, abstract viewtype) as
follows for values representing circular buffers:

#atscode('\
absvtype
cbufObj (a:vt@ype+, m:int, n: int) = ptr
')

Such values are considered simple linear objects (as inheritance is not an
issue to be dealt with in this setting). Given a viewtype VT and two
integers M and N, the viewtype #stacode("cbufObj(VT, M, N)") is for a given
buffer of maximal capacity M that currently holds N elements of the type
VT.

")

#para("\

Some properties on the parameters of #stacode("cbufObj") can be captured
by introducing the following proof function:

#atscode('\
prfun
lemma_cbufObj_param
  {a:vt0p}{m,n:int}
  (buf: !cbufObj (a, m, n)): [m>=n; n>=0] void
')

The interface for the following two function templates indicates that they
can be called to compute the capacity and current size of a buffer:

#atscode('\
fun{a:vt0p}
cbufObj_get_cap
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (m)

fun{a:vt0p}
cbufObj_get_size
  {m,n:int} (buf: !cbufObj (a, m, n)): size_t (n)
')

")

#para("\

While it is straightforward to use #dyncode("cbufObj_get_cap") and
#dyncode("cbufObj_get_size") to tell whether a buffer is currently empty or
full, a direct approach is likely to be more efficient. The following two
function templates check for the emptiness and fullness of a given circular
buffer:

#atscode('\
//
fun{a:vt0p}
cbufObj_is_empty
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (n==0)
//
fun{a:vt0p}
cbufObj_is_full
  {m,n:int} (buf: !cbufObj (a, m, n)): bool (m==n)
//
')

")

#para("\

The functions for creating and destroying circular buffers are named
#dyncode("cbufObj_new") and #dyncode("cbufObj_free"), respectively:

#atscode('\
fun{a:vt0p}
cbufObj_new
  {m:pos} (m: size_t m): cbufObj (a, m, 0)
//
fun cbufObj_free
  {a:vt0p}{m:int} (buf: cbufObj (a, m, 0)): void
')

Note that a buffer can be freed only if it contains no elements as
an element (of some viewtype) may contain resources. If elements in
a buffer are of some (non-linear) type, then the following function
can be called to clear out all the elements stored in the buffer:

#atscode('\
fun cbufObj_clear
  {a:t@ype}{m,n:int}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, 0)): void
// end of [cbufObj_clear]
')

")

#para("\

The next two functions are for inserting/removing an element into/from a
given buffer, which are probably the most frequently used operations on
buffers:

#atscode('\
//
fun{a:vt0p}
cbufObj_insert
  {m,n:int | n < m}
(
  buf: !cbufObj (a, m, n) >> cbufObj (a, m, n+1), x: a
) : void // end of [cbufObj_insert]
//
fun{a:vt0p}
cbufObj_remove
  {m,n:int | n > 0}
  (buf: !cbufObj (a, m, n) >> cbufObj (a, m, n-1)) : (a)
//
')

")

#para("\

Please find on-line the file
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats")
containing the entirety of the interface for functions creating, destroying
and manipulating circular buffers.\

")

#para("\

There are many simple and practical ways to implement the abstract type
#stacode("cbufObj") and the functions declared in
#mycodelink("CHAP_ABSVTYPE/circbuf.sats", "circbuf.sats").  In the file
#mycodelink("CHAP_ABSVTYPE/circbuf.dats", "circbuf.dats"), I give an
implementation that employs four pointers p_beg, p_end, p_frst and p_last
to represent a circular buffer: p_beg and p_end are the starting and
finishing addresses of the underline array, respectively, and p_frst and
p_last are the starting addresses of the occupied and unoccupied segments
(in the array), respectively. What is special about this implementation is
its employing a style of programming that deliberately eschews the need for
proof construction. While code written in this style is not guaranteed to
be type-safe, the style can nonetheless be of great practical value in a
setting where constructing formal proofs is deemed too costly a requirement
to be fully fulfilled. Anyone who tries to give a type-safe implementation
for the functions declared in #mycodelink("CHAP_ABSVTYPE/circbuf.sats",
"circbuf.sats") should likely find some genuine appreciation for this
point.

")

#para("\

In the file #mycodelink("CHAP_ABSVTYPE/circbuf2.dats", "circbuf2.dats"), I
give another implementation in which a circular buffer is represented as a
pointer p_beg plus three integers m, n and f: p_beg points to the starting
location of the underline array, m is the size of the array (that is, the
capacity of the buffer), n is the number of elements currently stored in
the buffer and f is the total number of elements that have so far been
removed from the buffer. Again, proof construction is delibrately eschewed
in this implementation.

")

</sect1><!--id="array-based-circular-buffer"-->

<!-- ****** ****** -->

<sect1
id="memory-allocation-deallocation">
#title("Memory Allocation and Deallocation")

#para("\

The issue of memory allocation and deallocation is of paramount importance
in systems programming, where garabage collection (GC) at run-time may not
even be allowed.  Handling memory management safely and efficiently is a long
standing problem of great challenge in programming, and its novel solution
in ATS is firmly rooted in the paradigm of programming with theorem-proving
(PwTP).

")

#para('\

The following function #dyncode("malloc_gc") is available in ATS for memory
allocation:

#atscode("\
fun malloc_gc
  {n:nat}(n: size_t n)
  : [l:agz] (b0ytes n @ l, mfree_gc_v (l) | ptr l)
// end of [malloc_gc]
")

The sort #stacode("agz") is a subset sort defined for addresses that are not
null:

#atscode("\
sortdef agz = {a:addr | a > null} // [gz] for great-than-zero
")

Given an integer N, the type #stacode("b0ytes(N)") is a shorthand for
#stacode("@[byte?][N]"), which is for an array of N uninitialized
bytes. Therefore, the at-view #stacode("b0ytes(N)@L") is the same as the
array-view #stacode("array_v(byte?, L, N)"), where L is a memory location.
The view constructor #stacode("mfree_gc_v") is abstract. For a given
location L, the view #stacode("mfree_gc_v(L)") stands for a form of
capability that allows allocated memory at location L to be freed (or
reclaimed) by the following function #dyncode("mfree_gc"):

#atscode("\
fun mfree_gc
  {l:addr}{n:nat}
  (pfat: b0ytes(n) @ l, pfgc: mfree_gc_v (l) | p: ptr l): void
// end of [free_gc]
")

Note that #stacode("mfree_gc_v(L)") is so far the first form of view we
have encountered that is not built on top of any at-views.

')

#para('\

In practice, it is rather cumbersome to deal with bytes directly.  The
function #dyncode("ptr_alloc") is available for allocating memory to store
a single value (of certain type) and the function #dyncode("ptr_free") for
deallocating such memory:

#atscode('\
fun{a:vt0p}
ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]
')

In addition, the function #dyncode("array_ptr_alloc") is for allocating
memory to store an array of values (of certain type), and the function
#dyncode("array_ptr_free") is for deallocating such memory:

#atscode('\
fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) : [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) : void // end of [array_ptr_free]
')

')

#para('\

I now give a realistic and interesting example involving both array
allocation and deallocation. The following two functions templates
#dyncode("msort1") and #dyncode("msort2") perform merge-sort on a given array:

#atscode('\
typedef cmp (a:t@ype) = (&a, &a) -> int

extern
fun{
a:t@ype
} msort1 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]), cmp: cmp(a)): void
// end of [msort1]

extern
fun{
a:t@ype
} msort2 {n:nat}
  (A: &(@[a][n]), n: size_t n, B: &(@[a?][n]) >> @[a][n], cmp: cmp(a)): void
// end of [msort2]
')

It is well-known that merging two sorted segments of a given array requires
additional space. When #dyncode("msort1") is called on arrays A and B, the
array A is the one to be sorted and the array B is some kind of scratch
area needed to perform merging (of sorted array segments). When a call to
#dyncode("msort1") returns, the sorted version of A is still sotred in
A. What #dyncode("msort2") does is similar but the sorted version of A is
stored in B when a call to #dyncode("msort2") returns.  As a good exercise,
I suggest that the interested reader take the effort to give a mutually
recursive implementation of #dyncode("msort1") and #dyncode("msort2").  An
implementation of merge-sort based on #dyncode("msort1") can be readily
given as follows:

#atscode('\
extern
fun{
a:t@ype
} mergeSort{n:nat}
  (A: &(@[a][n]), n: size_t n, cmp: cmp(a)): void
// end of [mergeSort]

implement
{a}(*tmp*)
mergeSort (A, n, cmp) = let
  val (pfat, pfgc | p) = array_ptr_alloc<a> (n)
  val ((*void*)) = msort1 (A, n, !p, cmp)
  val ((*void*)) = array_ptr_free (pfat, pfgc | p)
in
  // nothing
end // end of [mergeSort]
')

Clearly, an array is first allocated (to be used as a scratch area) and
then deallocated after it is no longer needed.

')

#para('\

The entire implementation of merge-sort on arrays plus some testing code is
available #mycodelink("CHAP_ABSVTYPE/mergeSort.dats", "on-line").

')

</sect1><!--id="memory-allocation-deallocation-->

<!-- ****** ****** -->

</chapter><!--id="abstract_views_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
