%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="parametric_polymorphism">
#title("Parametric Polymorphism")

#para("\

Code sharing is of paramount importance in programming.  In a typed
programming language, we often encounter a situation where the same
functionality is needed for values of different types. For instance, we may
need to compute the length of a list while the elements in the list can be
characters, integers, strings, etc. Evidently, we want to avoid
implementing a list-length function for each element type as it would
probably be the worst form of code duplication. We want to implement one
single function that can be applied to any list to compute the length of
the list. This list-length function parameterizes over the element type of
a given list, and it behaves uniformly regardless what the element type is.
This is a form of code sharing that is often referred to as
#emphasis("parametric polymorphism"), which should be distinguished from
other forms of polymorphism such as inheritance polymorphism in
object-oriented programming.\

")#comment("para")

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_POLYMORPH", "on-line").\

")

<sect1
id="function_templates">
#title("Function Templates")

#para("\

A function template is a code template that implements a function.
In the following code, two functions are defined to swap values:

#atscode("\
typedef charint = (char, int)
typedef intchar = (int, char)
fun swap_char_int (xy: charint): intchar = (xy.1, xy.0)
fun swap_int_char (xy: intchar): charint = (xy.1, xy.0)
")

If types are ignored, the bodies of #dyncode("swap_char_int") and
#dyncode("swap_int_char") are identical. In order to avoid this kind of
code duplication, we can first implement a function template
#dyncode("swap") as follows and then implement #dyncode("swap_char_int")
and #dyncode("swap_int_char") based on #dyncode("swap"):

#atscode("\
fun{
a,b:t@ype
} swap (xy: (a, b)): (b, a) = (xy.1, xy.0)
fun swap_char_int (xy: charint): intchar = swap<char,int> (xy)
fun swap_int_char (xy: intchar): charint = swap<int,char> (xy)
")

It should be noted that a function template is not a first-class value in
ATS: There is no expression for representing a function template.  The
syntax #stacode("{a,b:t@ype}") following the keyword #dyncode("fun")
represents template parameters or arguments. The unusual symbol
#stacode("t@ype") is a sort for static terms representing types of
unspecified size, where the size of a type is the number of bytes needed
for representing a value of the type (under the assumption that all of the
values of the type have the same size).  There is another sort
#stacode("type") in ATS, which is for static terms representing types of
size equal to one word exactly, that is, 4 bytes on a 32-bit machine or 8
bytes on a 64-bit machine.  The syntax #dyncode("swap&lt;char,int&gt;"),
where no space is allowed between #dyncode("swap") and #dyncode("&lt;") ,
stands for an instance of the function template #dyncode("swap") in which
the parameters #stacode("a") and #stacode("b") are replaced with
#stacode("char") and #stacode("int"), respectively.  The syntax
#dyncode("swap&lt;int,char&gt;") is interpreted similarly.\

")#comment("para")

#para("\

A different style of implementation of #dyncode("swap") is given
as follows:

#atscode("\
fun{a:t@ype}{b:t@ype} swap2 (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

where the template parameters are given sequentially (instead of
simultaneously). The following code shows how #dyncode("swap2") can be
instantiated to form instances:

#atscode("\
fun swap_char_int (xy: charint): intchar = swap2<char><int> (xy)
fun swap_int_char (xy: intchar): charint = swap2<int><char> (xy)
")

Note that #dyncode("&gt;&lt;") is a special symbol (of the name GTLT) and
no space is allowed between #dyncode("&gt;") and #dyncode("&lt;").\

")#comment("para")

#para("\

As another example, a higher-order function template for composing
(closure) functions is given as follows:

#atscode("\
typedef
cfun (t1:t@ype, t2:t@ype) = t1 -<cloref1> t2

fun{
a,b,c:t@ype
} compose (
  f: cfun (a, b), g: cfun (b, c)
) :<cloref1> cfun (a, c) = lam x => g(f(x))

val plus1 = lam (x:int): int =<cloref> x+1
val times2 = lam (x:int): int =<cloref> x*2

val f_2x_1 = compose<int,int,int> (times2, plus1)
val f_2x_2 = compose<int,int,int> (plus1, times2)
")

It should be clear that the value #dyncode("f_2x_1") represents the
function that multiplies its integer argument by 2 and then adds 1 to it.
Similarly, the value #dyncode("f_2x_2") represents the function that adds 1
to its integer argument and then multiplies it by 2.\

")#comment("para")

#para("\

In ATS, function templates are typechecked but not compiled to code in C.
Instead, they are compiled to an intermediate form.  Only instances of
function templates are compiled to code in C. Suppose we have a function
template foo taking one type parameter and two instances foo&lt;T1&gt; and
foo&lt;T2&gt; are used in a program for some types T1 and T2. In general,
one function in C is generated for each instance of foo when the program is
compiled. However, if T1 and T2 have the same name, then the two instances
may share one function in C.\

")#comment("para")

#para("\

Please note that I may simply use the name function to refer to a function
template from now on if no confusion is expected.\

")

</sect1><!--id="function_templates"-->

<!-- ****** ****** -->

<sect1
id="polymorphic_functions">
#title("Polymorphic Functions")

#para("\

A polymorphic function is rather similar to a function template.
However, the former is a first-class value in ATS while the latter is not.
As an example, the following defined function #dyncode("swap_boxed") is
polymorphic:

#atscode("\
fun swap_boxed{a,b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

The type variables #stacode("a") and #stacode("b") are often referred as
static arguments while #dyncode("xy") is a dynamic argument. Here is some code
that makes use of the polymorphic function #dyncode("swap_boxed"):

#atscode('\
val AB = ("A", "B")
val BA1 = swap_boxed{string,string} (AB)
val BA2 = swap_boxed (AB) // omitting type arguments may be fine
')

If #stacode("swap_boxed") is called on a pair of the type (T1, T2) for some
types T1 and T2, both T1 and T2 are required to be boxed. Otherwise, a
type-error is reported. For instance, calling #dyncode("swap_boxed") on
#dyncode("(0, 1)") yields a type-error as the type #dyncode("int") is not
boxed.\

")#comment("para")

#para("\

When calling a polymorphic function, we often omit passing static
arguments explicitly and expect them to be synthesized by the
compiler. However, there are also occasions, which are not uncommon, where
static arguments need to be supplied explicitly as either they cannot be
successfully synthesized or what is synthesized is not exactly what is
expected by the programmer.\

")

#para("\

It is also possible to pass static arguments sequentially as is
shown in the following style of implementation of a polymorphic function:

#atscode('\
fun swap2_boxed{a:type}{b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)

val AB = ("A", "B")
val BA1 = swap2_boxed (AB) // both static arguments to be synthesized
val BA2 = swap2_boxed{...} (AB) // both static arguments to be synthesized
val BA3 = swap2_boxed{..}{string} (AB) // 1st static argument to be synthesized
val BA4 = swap2_boxed{string}{..} (AB) // 2nd static argument to be synthesized
val BA5 = swap2_boxed{..}{..} (AB) // both static arguments to be synthesized
val BA6 = swap2_boxed{string}{string} (AB) // both static arguments are provided
')

The special syntax #stacode("{..}") indicates to the typechecker that the
static argument (or arguments) involved in the current application should
be synthesized while the special syntax #stacode("{...}") means that the
rest of static arguments should all be synthesized.\

")#comment("para")

#para("\

I have seen two kinds of errors involving polymorphic functions that are
extremely common in practice.

<itemizedlist>

<listitem>

#para("\
The first kind is depicted in the following example:

#atscode("\
fun swap_boxed{a,b:t@ype} (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

Notice that the sort for type variables #stacode("a") and #stacode("b") is
#stacode("t@ype") (instead of #stacode("type")). While this example can
pass typechecking, its compilation results in a compile-time error that may
seem mysterious to many programmers. The simple reason for this error is
that the compiler cannot figure out the size of #stacode("a") and
#stacode("b") when trying to generate code in C as the sort #stacode("t@ype")
is for types of unspecified size.

")#comment("para")

</listitem>

<listitem>
#para("\
The second kind is depicted in the following example:

#atscode("\
fun{a,b:type} swap_boxed (xy: (a, b)): (b, a) = (xy.1, xy.0)
")

Strictly speaking, there is really no error in this case. If defined as
such, #stacode("swap_boxed") is a function template instead of a
polymorphic function. However, such a function template is severely
restricted as it cannot be instantiated with types that are not boxed.
While this could be intended, it is very unlikely.\

")#comment("para")

</listitem>

</itemizedlist>

Given the potential confusion, why do we need both function templates and
polymorphic functions?  At this stage, it is certainly plausible that we
program only with function templates and make no use of polymorphic
functions. However, polymorphic functions can hardly be missed in the
presence dependent types. There will actually be numerous occasions where
we encounter polymorphic function templates, that is, templates for
polymorphic functions.\

")#comment("para")

</sect1><!--id="polymorphic_functions"-->

<!-- ****** ****** -->

<sect1
id="polymorphic_datatypes">
#title("Polymorphic Datatypes")

#para("\

Code sharing also applies to datatype declarations. For instance, a
commonly used polymorphic datatype #stacode("list0") is declared as follows:

#atscode("\
datatype
list0 (a:t@ype) =
  | list0_nil (a) of () | list0_cons (a) of (a, list0 a)
// end of [list0]
")

More precisely, #stacode("list0") is a type constructor. Given a type T, we
can form a type #stacode("list0(T)") for lists consisting of elements of
the type T. For instance, #stacode("list0(char)") is for character lists,
#stacode("list0(int)") for integer lists, #stacode("list0(list0(int))") for lists
whose elements are themselves integer lists, etc.  To a great extent, the
need for function templates or polymorphic functions largely stems from the
availability of polymorphic datatypes. As an example, a function template
#dyncode("list0_length") is implemented as follows for computing the length
of any given list:

#atscode("\
fun{a:t@ype}
list0_length (xs: list0 a): int =
(
  case+ xs of
  | list0_cons (_, xs) => 1 + list0_length<a> (xs) | list0_nil () => 0
) (* end of [list0_length] *)
")

When applying #dyncode("list0_length") to a list xs, we can in general
write #dyncode("list0_length(xs)"), expecting the typechecker to synthesize
a proper type parameter for #dyncode("list0_length").  We may also write
#dyncode("list0_length&lt;")#stacode("T")#dyncode("&gt;(xs)") if the
elements of xs are of the type T. The latter style, though a bit more
verbose, is likely to yield more informative messages in case type-errors
occur.

")#comment("para")

#para("\

Another commonly used polymorphic datatype #stacode("option0") is declared as
follows:

#atscode("\
datatype
option0 (a:t@ype) =
  | option0_none (a) of () | option0_some (a) of a
// end of [option0]
")

A typical use of #stacode("option0") is to perform some kind of
error-handling. Suppose that we are to implement a function doing integer
division and we want to make sure that the function returns even if it is
called in a case where the divisor equals 0. This can be done as follows:

#atscode("\
fun divopt
(
  x: int, y: int
) : option0 (int) =
  if y != 0 then option0_some{int}(x/y) else option0_none((*void*))
// end of [divopt]
")

By inspecting what #dyncode("divopt") returns, we can tell whether integer
division has been done normally or an error of divsion-by-zero has
occurred. A realistic use of #stacode("option0") is shown in the following
implementation of #dyncode("list0_last"):

#atscode("\
fun{
a:t@ype
} list0_last
(
  xs: list0 a
) : option0 (a) = let
//
fun loop
  (x: a, xs: list0 a): a =
(
  case+ xs of
  | list0_nil () => x | list0_cons (x, xs) => loop (x, xs)
) (* end of [loop] *)
//
in
  case+ xs of
  | list0_nil () => option0_none((*void*))
  | list0_cons (x, xs) => option0_some{a}(loop (x, xs))
end // end of [list0_last]
")

When applied to a list, #dyncode("list0_last") returns an optional
value. If the value matches the pattern #dyncode("option0_none()"), then
the list is empty. Otherwise, the value is formed by applying
#dyncode("option0_some") to the last element of the given list.\

")#comment("para")

</sect1><!--id="polymorphic_datatypes"-->

<!-- ****** ****** -->

<sect1
id="example_function_templates_on_lists">
#title("Example: Function Templates on Lists")

#para("\

In functional programming, lists are ubiquitous. We implement as follows
some commonly used function templates on lists. It should be noted that
these templates are all available in some library of ATS, where they may be
implemented in a significantly more efficient manner due to the use of
certain programming features (such as linear datatypes) that have not been
covered so far.\

")

#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_POLYMORPH/listfun.dats", "on-line").\

")

<sect2 id="list0_append">
#title("
Appending: #dyncode("list0_append")
")

#para("\

Given two lists xs and ys of the type #stacode("list0(T)") for some type T,
#dyncode("list0_append(xs, ys)") returns a list that is the concatenation
of xs and ys:

#atscode("\
fun{
a:t@ype
} list0_append
(
  xs: list0 a
, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_cons{a}(x, list0_append<a> (xs, ys))
| list0_nil ((*void*)) => ys
) (* end of [list0_append] *)
")

Clearly, this implementation of #dyncode("list0_append") is not
tail-recursive.\

")#comment("para")

</sect2><!--id="list0_append"-->

<sect2
id="list0_reverse_append">
#title("
Reverse-Appending: #dyncode("list0_reverse_append")
")

#para("\

Given two lists xs and ys of the type #dyncode("list0(T)") for some type T,
#dyncode("list0_reverse_append(xs, ys)") returns a list that is the
concatenation of the reverse of xs and ys:

#atscode("\
fun{
a:t@ype
} list0_reverse_append
(
  xs: list0 a, ys: list0 a
) : list0 a =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_reverse_append<a> (xs, list0_cons{a}(x, ys))
| list0_nil () => ys
) (* end of [list0_reverse_append] *)
")

Clearly, this implementation of #dyncode("list0_reverse_append") is
tail-recursive.\

")#comment("para")

</sect2><!--id="list0_reverse_append"-->

<sect2
id="list0_reverse">
#title("
Reversing: #dyncode("list0_reverse")
")

#para("\

Given a list xs, #dyncode("list0_reverse(xs)") returns the
reverse of xs:

#atscode("\
fun{a:t@ype}
list0_reverse
  (xs: list0 a): list0 a = list0_reverse_append<a> (xs, list0_nil)
// end of [list0_reverse]
")
")#comment("para")

</sect2><!--id="list0_reverse"-->

<sect2 id="list0_map">
#title("
Mapping: #dyncode("list0_map")
")

#para("\

Given a list xs of the type #stacode("list0(T1)") for some type T1 and a
closure function f of the type T1 -&lt;cloref1&gt; T2 for some type T2,
#dyncode("list0_map(xs)") returns a list ys of the type #stacode("list0(T2)"):

#atscode("\
fun
{a:t@ype}
{b:t@ype}
list0_map
(
  xs: list0 a, f: a -<cloref1> b
) : list0 b =
(
case+ xs of
| list0_cons (x, xs) =>
    list0_cons{b}(f x, list0_map<a><b> (xs, f))
| list0_nil ((*void*)) => list0_nil ()
) (* end of [list0_map] *)
")

The length of ys equals that of xs and each element y in ys equals f(x),
where x is the corresponding element in xs.  Clearly, this implementation
of #dyncode("list0_map") is not tail-recursive.\

")#comment("para")

</sect2><!--id="list0_map"-->

<!-- ****** ****** -->

<sect2 id="list0_foldleft">
#title("Left-Folding: #dyncode("list0_foldleft")")

#para('\

Given xs, ini and f, #dyncode("list0_foldleft(ini, xs, f)") computes the
value of the expression f(... f(f(ini, xs[0]), xs[1]) ..., xs[n-1]), where
n is the length of xs and xs[i] refers to element i in xs for each i &lt; n.
The following implementation of #dyncode("list0_foldleft") is tail-recursive:

#atscode('\
fun
{a:t@ype}
{b:t@ype}
list0_foldleft
(
  ini: a, xs: list0 (b), f: (a, b) -> a
) : a =
(
  case+ xs of
  | list0_cons
      (x, xs) => list0_foldleft<a><b> (f (ini, x), xs, f)
  | list0_nil ((*void*)) => ini
)
')

')

</sect2><!--id="list0_foldleft"-->

<!-- ****** ****** -->

<sect2 id="list0_foldright">
#title("Right-Folding: #dyncode("list0_foldright")")

#para('\

Given xs, res and f, #dyncode("list0_foldright(xs, res, f)") computes the
value of the expression f(xs[0], f(xs[1], f(... f(xs[n-1], res) ...))), where
n is the length of xs and xs[i] refers to element i in xs for each i &lt; n.
The following implementation of #dyncode("list0_foldright") is not tail-recursive:

#atscode('\
fun
{a:t@ype}
{b:t@ype}
list0_foldright
(
  xs: list0 (a), res: b, f: (a, b) -> b
) : b =
(
  case+ xs of
  | list0_cons
      (x, xs) => f (x, list0_foldright<a><b> (xs, res, f))
  | list0_nil ((*void*)) => res
)
')

')

</sect2><!--id="list0_foldright"-->

<!-- ****** ****** -->

<sect2 id="list0_zip">
#title("Zipping: #dyncode("list0_zip")")

#para("\

Given two lists xs and ys of the types #stacode("list0(T1)") and
#stacode("list0(T2)") for some types T1 and T2, respectively,
#dyncode("list0_zip(xs, ys)") returns a list zs of the type #stacode("list0
@(T1, T2)"):

#atscode("\
fun{
a,b:t@ype
} list0_zip
(
  xs: list0 a
, ys: list0 b
) : list0 @(a, b) = let
  typedef ab = @(a, b)
in
//
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =>
  (
    list0_cons{ab}((x, y), list0_zip<a,b> (xs, ys))
  )
| (_, _) => list0_nil ()
//
end // end of [list0_zip]
")

The length of zs is the minimum of the lengths of xs and ys and each
element z in zs equals @(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
#dyncode("list0_zip") is not tail-recursive.\

")#comment("para")

</sect2><!--id="list0_zip"-->

<sect2 id="list0_zipwith">
#title("
Zipping with: #dyncode("list0_zipwith")
")

#para("\

Given two lists xs and ys of the types #stacode("list0(T1)") and
#stacode("list0(T2)") for some types T1 and T2, respectively, and a closure
function f of the type (T1, T2) -&lt;cloref1&gt; T3 for some type T3,
#dyncode("list0_zipwith(xs, ys, f)") returns a list zs of the type
#stacode("list0(T3)"):

#atscode("\
fun
{a,b:t@ype}
{c:t@ype}
list0_zipwith
(
  xs: list0 a
, ys: list0 b
, f: (a, b) -<cloref1> c
) : list0 c =
(
case+ (xs, ys) of
| (list0_cons (x, xs),
   list0_cons (y, ys)) =>
  (
    list0_cons{c}(f (x, y), list0_zipwith<a,b><c> (xs, ys, f))
  )
| (_, _) => list0_nil ()
) (* end of [list0_zipwith] *)
")

The length of zs is the minimum of the lengths of xs and ys and each
element z in zs is f(x, y), where x and y are the corresponding elements in
xs and ys, respectively.  Clearly, this implementation of
#dyncode("list0_zipwith") is not tail-recursive.  Note that
#dyncode("list0_zipwith") behaves exactly like #dyncode("list0_zip") if its
third argument #dyncode("f") is replaced with #dyncode("lam (x, y) => @(x, y)").
This function template is also named #dyncode("list0_map2") for the obvious
reason.\

")#comment("para")

</sect2><!--id="list0_zipping_with"-->

</sect1><!--id="example_function_templates_on_lists"-->

<!-- ****** ****** -->

<sect1 id="example_mergesort" xreflabel="implementation of mergesort on lists">

#title("Example: Mergesort on Lists")

#para("\

Mergesort is simple sorting algorithm that is guaranteed to be log-linear.
It is stable in the sense that the order of two equal elements always stay
the same after sorting. I give as follows a typical functional style of
implementation of mergesort on lists.

")

#para('\

First, let us introduce abbreviations
for the list constructors #dyncode("list0_nil") and #dyncode("list0_cons"):

#atscode("\
\#define :: list0_cons // writing [::] for list0_cons
\#define cons0 list0_cons // writing [cons0] for list0_cons
\#define nil0 list0_nil // writing [nil0] for list0_nil
")

Note that the operator #dyncode("::") is already given the infix status.
For instance, the list consisting of the first 5 natural numbers can be
constructed as follows:

#atscode("\
cons0 (0, cons0 (1, 2 :: 3 :: 4 :: nil0 ()))
")

In practice, there is of course no point in mixing #dyncode("cons0")
with #dyncode("::").

')#comment("para")

#para("\

We next implement a function template #dyncode("merge") to merge two given
ordered lists into a single ordered one:

#atscode("\
typedef
lte (a:t@ype) = (a, a) -> bool

fun{
a:t@ype
} merge (
  xs: list0 a, ys: list0 a, lte: lte a
) : list0 a =
(
  case+ xs of
  | cons0 (x, xs1) => (
    case+ ys of
    | cons0 (y, ys1) =>
        if x \lte y then
          cons0{a}(x, merge<a> (xs1, ys, lte))
        else
          cons0{a}(y, merge<a> (xs, ys1, lte))
        // end of [if]
    | nil0 () => xs
    ) // end of [cons0]
  | nil0 () => ys
) (* end of [merge] *)
")

For instance, suppose that the two given lists are (1, 3, 4, 8) and (2, 5,
6, 7, 9), and the comparison function (the third argument of
#dyncode("merge")) is the standard less-than-or-equal-to function on
integers. Then the list returned by #dyncode("merge") is (1, 2, 3, 4, 5, 6,
7, 8, 9). The syntax #dyncode("\lte") means that the particular occurrence
of #dyncode("lte") following the backslash symbol (#dyncode("\\\\")) is
given the infix status, and thus the expression #dyncode("x \\\\lte y")
means the same as #dyncode("lte(x, y)").\

")#comment("para")

#para("\

The following function template #dyncode("mergesort") implements the
standard mergesort algorithm:

#atscode("\
fun{
a:t@ype
} mergesort
(
  xs: list0 a, lte: lte a
) : list0 a = let
//
val n = list0_length<a> (xs)
//
fun msort
(
  xs: list0 a, n: int, lte: lte a
) : list0 a =
  if n >= 2 then split (xs, n, lte, n/2, nil0) else xs
//
and split
(
  xs: list0 a, n: int, lte: lte a, i: int, xsf: list0 a
) : list0 a =
  if i > 0 then let
    val-cons0 (x, xs) = xs
  in
    split (xs, n, lte, i-1, cons0{a}(x, xsf))
  end else let
    val xsf = list0_reverse<a> (xsf) // make sorting stable!
    val xsf = msort (xsf, n/2, lte) and xs = msort (xs, n-n/2, lte)
  in
    merge<a> (xsf, xs, lte)
  end // end of [if]
//
in
  msort (xs, n, lte)
end // end of [mergesort]
")#comment("atscode")

Suppose we want to sort the list (8, 3, 4, 1, 2, 7, 6, 5, 9); we first
divide it into two lists: (8, 3, 4, 1) and (2, 7, 6, 5, 9); by performing
mergesort on each of them, we obtain two ordered lists: (1, 3, 4, 8) and
(2, 5, 6, 7, 9); by merging these two ordered list, we obtain the ordered
list (1, 2, 3, 4, 5, 6, 7, 8, 9), which is a permutation of the original
list (8, 3, 4, 1, 2, 7, 6, 5, 9).\

")#comment("para")

#para("\

Note that the function template #dyncode("merge") is not tail-recursive as
the call to #dyncode("merge") in its body is not a tail-call. This can be a
serious problem in practice: It is almost certain that a stack overflow is
to occur if the above implementation of mergesort is employed to sort a
list that is very long (e.g., containing 1,000,000 elements or more). I
will later give a tail-recursive implementation of the #dyncode("merge")
function in ATS that makes use of linear types.  ")

#para("\

Please find the entire code in this section plus some additional code for
testing #mycodelink("CHAP_POLYMORPH/mergesort.dats", "on-line").\

")

</sect1><!--id="example_mergesort"-->

</chapter><!--id="parametric_polymorphism"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
