%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="introduction-to-views-and-viewtypes">
#title("Introduction to Views and Viewtypes")

<!-- ****** ****** -->

#para('\

Probably the single greatest motivation behind the development of ATS is
the desire to make ATS a programming language that can be employed
effectively to construct safe and reliable programs running in the kernels
of operating systems. Instead of following seemingly natural approaches
that often focus on carving out a "safe" subset of C and/or put wrappers
around "unsafe" programming features in C, ATS relies on the paradigm of
programming with theorem-proving to prevent resources such as memory from
being misused or mismanaged, advocating an approach to safety that is both
general and flexible. For example, a well-typed program constructed in ATS
cannot cause buffer overrun at run-time even though pointer arithmetic is
fully supported in ATS. More specifically, if a pointer is to be
dereferenced, ATS requires that a proof be given attesting to the safety of
the dereferencing operation. Proofs of this kind are constructed to
demonstrate the validity of linear propositions, which are referred to as
views in ATS, for classifying resources as well as capabilities.

')#comment("para")

#para('\

Please find #mycodelink("CHAP_VVTINTRO/", "on-line") the code presented
for illustration in this chapter.

')

<!-- ****** ****** -->

<sect1
id="views_for_pointers">
#title("Views for Memory Access through Pointers")

#para('\

A view is a linear version of prop, where the word #emphasis("linear")
comes from linear logic, a resource-aware logic invented by Jean-Yves
Girard. There is a built-in sort #stacode("view") for static terms
representing views.  Given a type T and a memory location L, a view of the
form #stacode("T@L") can be formed to indicate a value of the type T being stored in
the memory at the location L, where #stacode("@") is a special infix
operator.  Views of this form are extremely common in practice, and they
are often referred to as at-views.  As an example, the following function
templates #dyncode("ptr_get0") and #dyncode("ptr_set0"), which reads and
writes through a given pointer, are assigned types containing at-views:

#atscode('\
fun{a:t@ype}
ptr_get0 {l:addr} (pf: a @ l | p: ptr l): (a @ l | a)

fun{a:t@ype}
ptr_set0 {l:addr} (pf: a? @ l | p: ptr l, x: a): (a @ l | void)
')

')

#para('\

Note that #stacode("ptr") is a type constructor that forms a type
#stacode("ptr(L)") when applied to a static term L of the sort
#stacode("addr"), and the only value of the type #stacode("ptr(L)") is the
pointer that points to the location denoted by L.

')

#para('\

Given a type T, the function #dyncode("ptr_get0&lt;T&gt;") is assigned the
following type:

#atscode('\
{l:addr} (T @ l | ptr (l)) -> (T @ l | T)
')

which indicates that the function #dyncode("ptr_get0&lt;T&gt;") returns a
proof of the view #stacode("T@L") and a value of the type T when applied to
a proof of the view #stacode("T@L") and a pointer of the type
#stacode("ptr(L)") for some L. Intuitively speaking, a proof of the view
#stacode("T@L"), which is a form of resource as #stacode("T@L") is linear, is
#emphasis("consumed") when it is passed to #dyncode("ptr_get0&lt;T&gt;"),
and another proof of the same view #stacode('T@L') is generated when
#dyncode("ptr_get0&lt;T&gt;") returns. Notice that a proof of the view
#stacode('T@L') must be returned for otherwise subsequent accesses to the
memory location L would have been precluded.

')

#para('\

Similarly, the function #dyncode("ptr_set0&lt;T&gt;") is assigned the
following type:

')

#atscode('\
{l:addr} (T? @ l | ptr (l)) -> (T @ l | void)
')

#para('\

Note that T? is a type for values of size #stacode("sizeof(T)") that are
assumed to be uninitialized.  The function #dyncode("ptr_set0&lt;T&gt;")
returns a proof of the view #stacode("T@L") when applied to a proof of the
view #stacode("T?@L"), a pointer of the type #stacode("ptr(L)") and a value
of the type T. The use of the view #stacode("T?@L") indicates that the
memory location at L is assumed to be uninitialized when
#dyncode("ptr_set0&lt;T&gt;") is called.

')

#para('\

As an example, a function template #dyncode("swap0") is implemented as follows
for swapping memory contents at two given locations:

#atscode('\
fn{a:t@ype}
swap0 {l1,l2:addr}
(
  pf1: a @ l1, pf2: a @ l2
| p1: ptr (l1), p2: ptr (l2)
) : (a @ l1, a @ l2 | void) = let
  val (pf1 | x1) = ptr_get0<a> (pf1 | p1)
  val (pf2 | x2) = ptr_get0<a> (pf2 | p2)
  val (pf1 | ()) = ptr_set0<a> (pf1 | p1, x2)
  val (pf2 | ()) = ptr_set0<a> (pf2 | p2, x1)
in
  (pf1, pf2 | ())
end // end of [swap0]
')

')

#para('\

Compared to a corresponding implementation in C, the verbosity of this one
in ATS is evident. In particular, the need for #emphasis("threading")
linear proofs through calls to functions that make use of resources can
often result in a lot of #emphasis("administrative") code to be written. I
now present some special syntax to significantly alleviate the need for
such administrative code.

')

#para('\

The function templates #dyncode("ptr_get1") and #dyncode("ptr_set1") are
given the following interfaces:

#atscode('\
fun{a:t@ype}
ptr_get1 {l:addr} (pf: !a @ l >> a @ l | p: ptr l): a

fun{a:t@ype}
ptr_set1 {l:addr} (pf: !a? @ l >> a @ l | p: ptr l, x: a): void
')

Clearly, for each type T, the function
#dyncode("ptr_get1&lt;T&gt;") is assigned the following type:

#atscode('\
{l:addr} (!T @ l >> T @ l | ptr(l)) -> T
')

Given a linear proof pf of the view #stacode("T@L") for some L and a
pointer p of the type #stacode("ptr(L)"), the function call
#dyncode("ptr_get1&lt;T&gt;")(pf, p) is expected to return a value of the
type T. However, the proof pf is not consumed. Instead, it is still a proof
of the view #stacode("T@L") after the function call returns. Similarly, the
function #dyncode("ptr_set1&lt;T&gt;") is assigned the following type:

#atscode('\
{l:addr} (!T? @ l >> T @ l | ptr(l), T) -> void
')

Given a linear proof pf of the view #stacode("T?@L") for some L, a pointer
p of the type #stacode("ptr(L)") and a value v of the type T, the function
call #dyncode("ptr_set1&lt;T&gt;")(pf, p, v) is expected to return the void
value while changing the view of pf from #stacode("T?@L") to
#stacode("T@L").  In general, assume that f is given a type of the
following form for some views V1 and V2:

#atscode('\
(...,!V1 >> V2, ...) -> ...
')

Then a function call f(..., pf, ...) on some proof variable pf of the view
V1 is to change the view of pf into V2 upon its return.  In the case where
V1 and V2 are the same, !V1 >> V2 can simply be written as !V1.  As an
example, a function template #dyncode("swap1") for swapping the contents at
two given memory locations is implemented as follows:

#atscode('\
fn{a:t@ype}
swap1 {l1,l2:addr} (
  pf1: !a@l1, pf2: !a@l2 | p1: ptr l1, p2: ptr l2
) : void = let
  val x = ptr_get1<a> (pf1 | p1)
  val () = ptr_set1<a> (pf1 | p1, ptr_get1<a> (pf2 | p2))
  val () = ptr_set1<a> (pf2 | p2, x)
in
  // nothing
end // end of [swap1]
')

Clearly, this implementation is considerably cleaner when compared to the
above implementation of #dyncode("swap0").

')

#para('\

A further simplied implementation of #dyncode("swap1") is given as follows:

#atscode('\
fn{a:t@ype}
swap1{l1,l2:addr}
(
  pf1: !a@l1, pf2: !a@l2
| p1: ptr (l1), p2: ptr (l2)
) : void = let
  val tmp = !p1 in !p1 := !p2; !p2 := tmp
end // end of [swap1]
')

Given a pointer p of the type #stacode("ptr(L)") for some L, #dyncode("!p")
yields the value stored at the memory location L.  The typechecker first
searches for a proof of the view #stacode("T@L") for some T among all the
currently available proofs when typechecking #dyncode("!p"); if such a
proof pf is found, then #dyncode("!p") is essentially elaborated into
#dyncode("ptr_get1(pf | p)") and then typechecked. As #dyncode("!p") is a
left-value (which is to be explained later in detail), it can also be used
to form an assignment like #dyncode("!p := v") for some value v. The
typechecker elaborates #dyncode("!p := v") into #dyncode("ptr_set1(pf | p,
v)") for the sake of typechecking if a proof of the at-view #stacode("T@L")
can be found for some type T among all the currently available proofs. Note
that this implementation of #dyncode("swap1") makes no use of
administrative code for handling linear proofs explicitly.

')

</sect1>#comment("sect1/id=views_for_pointers")

<!-- ****** ****** -->

<sect1
id="viewtypes_as_combination">
#title("Viewtypes as a Combination of Views and Types")

#para("\

A linear type in ATS is given the name #emphasis("viewtype"), which is
chosen to indicate that a linear type consists of two parts: one part for
views and the other for types. For instance, given a view V and a type T,
then the tuple (V | T) is a viewtype, where the bar symbol (|) is a
separator (just like a comma) to separate views from types. What seems a
bit surprising is the opposite: For each viewtype VT, we may assume the
existence of a view V and a type T such that VT is equivalent to (V |
T). Formally, this T can be referred as VT?! in ATS.  This somewhat
unexpected interpretation of linear types is a striking novelty of ATS,
which stresses that the linearity of a viewtype comes #emphasis("entirely")
from the view part residing within it.

")

#para('\

The built-in sorts #stacode("viewtype") and #stacode("viewt@ype") are for static
terms representing viewtypes whose type parts are of the sorts
#stacode("type") and #stacode("t@ype"), respectively. In other words, the former
is assigned to viewtypes for linear values of the size equal to that of a
pointer and the latter to viewtypes for linear values of unspecified size.
For example, #stacode("tptr") is defined as follows that takes a type and an
address to form a viewtype (of the sort #stacode("viewtype")):

#atscode('\
vtypedef tptr (a:t@ype, l:addr) = (a @ l | ptr l)
')

Given a type T and an address L, the viewtype #stacode("tptr(T, L)") is for
a pointer to L paired with a linear proof stating that a value of the type
T is stored at L. If we think of a counter as a pointer paired with a proof
stating that the pointer points to an integer (representing the count),
then the following defined function #dyncode("getinc") returns the current
count of a given counter after increasing it by 1:\

#atscode('\

fn getinc
  {l:addr}{n:nat}
(
  cnt: !tptr (int(n), l) >> tptr (int(n+1), l)
) : int(n) = n where {
  val n = ptr_get1<int(n)> (cnt.0 | cnt.1)
  val () = ptr_set1<int(n+1)> (cnt.0 | cnt.1, n+1)
} (* end of [getinc] *)
')

')

#para('\

A particularly interesting example of a viewtype is the following one:

#atscode('\
vtypedef cloptr
  (a:t@ype, b:t@ype, l:addr) =
  [env:t@ype] (((&env, a) -> b, env) @ l | ptr l)
// end of [cloptr_app]
')

Given two types A and B, a pointer to some address L where a closure
function is stored that takes a value of the type A to return a value of
the type B can be given the viewtype #stacode("cloptr(A, B, L)"). Note that
a closure function is just an envless function paired with an environment
containing bindings for variables in the body of the closure function that
are introduced from outside. In the function type #stacode("(&amp;env, a)
-> b"), the symbol #stacode("&amp;") indicates that the corresponding
function argument is passed by reference, that is, the argument is required
to be a left-value and what is actually passed at run-time is the address
of the left-value.  I will cover the issue of call-by-reference elsewhere
in more details.  The following piece of code demonstrates a pointer to a
closure function being called on a given argument:\

#atscode('\
fun{
a:t@ype}{b:t@ype
} cloptr_app {l:addr}
(
  pclo: !cloptr (a, b, l), x: a
) : b = let
  val p = pclo.1
  prval pf = pclo.0 // take out pf: ((&env, a) -> b, env) @ l
  val res = !p.0 (!p.1, x)
  prval () = pclo.0 := pf // put the proof pf back
in
  res
end // end of [cloptr]
')

Note that the linear proof in #dyncode("pclo") is first taken out so that
the code for dereferencing p (denoted by the syntax #dyncode("!p")) can
pass typechecking, and it is then returned so that the type of
#dyncode("pclo") is restored to its original one. The very ability to
explain within ATS programming features such as closure function is a
convincing indication of the expressiveness of the type system of ATS.

')

</sect1>#comment("sect1/id=viewtypes_as_combination")

<!-- ****** ****** -->

<sect1
id="lval_and_cbr">
#title("Left-Values and Call-by-Reference")

#para('\

In its simplest form, a left-value is just a pointer paired with a linear
proof attesting to a value (of some type) being stored at the location to
which the pointer points. The name #emphasis("left-value") stems from such a
value being allowed to appear on the left-hand side of an assignment
statement (in languages like C). Often, a left-value is intuitively
explained as a value with an address attached to it. Note that whatever
representation chosen for a left-value must make it possible to identify
both the pointer and the linear proof (of some at-view) that are associated
with the left-value.

')

#para('\

In ATS, the simplest expression representing a left-value is
#dyncode("!p"), where #dyncode("!") is a special symbol and p a value of
the type #stacode("ptr(L)") for some address L. When this expression is
typechecked, a proof of #stacode("T@L") for some type T is required to be
found among the currently available proofs. I will introduce additional
forms of left values gradually.

')

#para('\

The default strategy for passing a function argument in ATS is
call-by-value. However, it is also allowed in ATS to specify that
call-by-reference is chosen for passing a particular function argument. By
call-by-reference, it is meant that the argument to be passed must be a
left-value and what is actually passed is the address of the left-value
(instead of the value stored at the address). For example, the following
defined function #dyncode("swap2") makes essential use of
call-by-reference:

#atscode('\
fn{
a:t@ype
} swap2 (
  x1: &a, x2: &a
) : void = let
  val tmp = x1 in x1 := x2; x2 := tmp
end // end of [swap2]
')

Note that the special symbol #dyncode("&amp;") in front of the type of a
function argument indicates that the argument needs to be passed according
to the call-by-reference strategy. The following code implements
#dyncode("swap1") based on #dyncode("swap2"):

#atscode('\
fn{
a:t@ype
} swap1{l1,l2:addr}
(
  pf1: !a @ l1, pf2: !a @ l2 | p1: ptr l1, p2: ptr l2
) : void = swap2 (!p1, !p2)
')

When the call #dyncode("swap2(!p1, !p2)") is evaluated at run-time, the
parameters actually being passed are the two pointers #dyncode("p1") and
#dyncode("p2") (rather than the values stored at the locations to which
these two pointers point).\

')

#para('\

Given a type T and an integer N, the syntax #stacode("@[T][N]") stands for
a flat array consisting N elements of the type T. Please note that a value
of the type #stacode("@[T][N]") is of the size N*sizeof(T). If a function
has a parameter representing an array, then this parameter is most liklely
call-by-reference. For instance, the following code implements a function
that takes two arrays of doubles to compute their dot product (also knowns
as inner product):

#atscode('\
fun dotprod 
(
  A: &(@[double][3])
, B: &(@[double][3])
) : double =
(
  A[0] * B[0] + A[1] * B[1] + A[2] * B[2]
)
')

Note that both array arguments of #dyncode("dotprod") are call-by-reference.

')

</sect1>#comment("sect1/id=lval_and_cbr")

<!-- ****** ****** -->

<sect1
id="stack-allocated_variables">
#title("Stack-Allocated Variables")

#para('\

Given a type T and an address L, how can a proof of the view
#stacode("T@L") be obtained in the first place? There are actually a
variety of methods for obtaining such proofs in practice, and I present one
as follows that is based on stack-allocation of local variables.

')

#para('\

In the body of the following function #dyncode("foo"), some stack-allocated
local variables are declared:

')

#atscode('\
fn foo (): void = let
  var x0: int // view@(x0): int? @ x0
  val () = x0 := 0 // view@(x0): int(0) @ x0
  var x1: int = 1 // view@(x1): int(1) @ x1
//
// [with] is a keyword in ATS
//
  var y: int with pfy // pfy is an alias of view@(y): int? @ y
  val () = y := 2 // pfy = view@(y): int(2) @ y
  var z: int with pfz = 3 // pfz is an alias of view@(z): int(3) @ z
in
  // nothing
end // end of [foo]
')

#para('\

The keyword #dyncode("var") is for declaring a local variable. When a
variable is declared, either its type or its initial value needs to be
given. If a variable is declared without a type, then the type of its
initial value is assumed to be its type. Assume that a variable x is
declared of type T. Then the pointer to the location of the variable is
denoted by #dyncode("addr@(x)"), where #dyncode("addr@") is a keyword, and
its associated linear proof (of some at-view) can be referred to as
#dyncode("view@(x)"), where #dyncode("view@") is a keyword. A variable is
another form of left-value in ATS. In the body of #dyncode("foo"),
#dyncode("x0") is declared to be a variable of the type #stacode("int") and
then it is initialized with the integer 0; #dyncode("x1") is declared to be
a variable of the type #stacode("int") that is given the initial value 1;
#dyncode("y") is declared to be a variable of the type #stacode("int")
while #dyncode("pfy") is introduced as an alias for #dyncode("view@(y)"),
and then #dyncode("y") is initialized with the integer 2; #dyncode("z") is
declared to be a variable of the type #stacode("int") that is given the
initial value 3 while #dyncode("pfz") is introduced as an alias for
#dyncode("view@(z)").

')

#para('\

The following code gives an implementation of the factorial function:

')

#atscode('\
fn fact{n:nat}
  (n: int (n)): int = let
  fun loop{n:nat}{l:addr} .<n>.
    (pf: !int @ l | n: int n, res: ptr l): void =
    if n > 0 then let
      val () = !res := n * !res in loop (pf | n-1, res)
    end // end of [if]
  // end of [loop]
  var res: int with pf = 1
  val () = loop (pf | n, addr@res) // addr@res: the pointer to res
in
  res
end // end of [fact]
')

#para('\

Note that the variable #dyncode("res") holds the intermediate result during
the execution of the loop. As #dyncode("res") is stack-allocated, there is
no garbage generated after a call to #dyncode("fact") is evaluated. When
this style of programming is done in C, there is often a concern about the
pointer to #dyncode("res") being derefenced after a call to
#dyncode("fact") returns, which is commonly referred to as derefencing a
dangling pointer.  This concern is completely eliminated in ATS as it is
required by the type system of ATS that a linear proof of the at-view
associated with the variable #dyncode("res") be present at the end of legal
scope for #dyncode("res"). More specifically, if x is a declared variable
of the type T, then a linear proof of the view #stacode("T?@L"), where L is
the address of x, must be available when typechecking reaches the end of
the scope for x.  This requirement ensures that a variable can no longer be
accessed after the portion of the stack in which it is allocated is
reclaimed as no linear proof of the at-view associated with the variable is
ever available from that point on.

')

#para('\

Arrays in ATS can also be stack-allocated. For instance, the following code
allocates two arrays of doubles in the frame of the function
#dyncode("main0") and then passes them to #dyncode("dotprod") to compute
their dot product:

#atscode('\
implement
main0 () =
{
//
var A = @[double][3](1.0) // initialized with 1.0, 1.0, 1.0
var B = @[double](1.0, 2.0, 3.0) // initialized with 1.0, 2.0, 3.0
//
val () = println! ("A * B = ", dotprod (A, B)) // A * B = 6.0
//
} (* end of [main0] *)
')

The at-view associated with the variable A is #stacode("(@[double][3])@A"),
where A also refers to the address of the variable A. Similarly, the
at-view associated with the variable B is #stacode("(@[double][3])@B").

For the sake of completeness, I mention the syntax for uninitialized arrays
as follows: Given a type T and an integer N, the syntax
#dyncode("@[T][N]()") is for an array consisting of N uninitialized values
of type T.

')

#para('\

Note that allocating large arrays in the call frame of a function may not
be a good practice as doing so can greatly increase the likelihood of
stack-overflow at run-time.

')

#para('\

It is also allowed in ATS to allocate a closure in the call frame of a
function. For instance, the following code implements a function named
#dyncode("foo") that stores a flat closure-function in a stack-allocated
variable named #dyncode("bar"):

#atscode('\
fun foo
(
  x: int, y: int
) : int = let
//
var bar = lam@ (): int => x * y
//
in
  bar ()
end // end of [foo]
')

Note that the special keyword #keycode("lam@") should be used to form a
flat closure-function. For the sake of completeness, I present another example
as follows to show that a recursive closure-function can also be stored in
a stack-allocated variable:

#atscode('\
fun foo2
(
  x: int, y: int
) : int = let
//
var bar2 = fix@ f (x: int): int => if x > 0 then y + f(x-1) else 0
//
in
  bar2 (x)
end // end of [foo]
')

Note that the special keyword #keycode("fix@") should be used to form
a flat recursive closure-function.

')

#para('\

In a setting where dynamic memory allocation is not
allowed, stack-allocated closures can play a pivotal role in supporting
programming with higher-order functions.

')

</sect1>#comment("sect1/id=stack_allocated_variables")

<!-- ****** ****** -->

<sect1
id="heap-allocated-linear-closure-functions">
#title("Heap-Allocated Linear Closure-Functions")

#para('\

In ATS, a closure-function can be assiged a linear type, allowing
it to be properly tracked within the type system and also explicitly
freed by the programmer.
')

#para('\

The following code implements a higher-order function
#dyncode("list_map_cloptr") which takes a linear closure-function
as its second argument:

#atscode('\
fun{
a:t@ype}{b:vt@ype
} list_map_cloptr{n:int}
(
  xs: list (a, n), f: !(a) -<cloptr1> b
) : list_vt (b, n) =
(
  case+ xs of
  | list_nil () => list_vt_nil ()
  | list_cons (x, xs) => list_vt_cons (f (x), list_map_cloptr<a><b> (xs, f))
)
')

Note that the keyword #keycode("-&lt;cloptr1&gt;") indicates that the
function type it forms is for a linear closure-function. If a type for a
pure linear closure-function is needed, the keyword
#keycode("-&lt;cloptr0&gt;") can be used.  The symbol #keycode("!") in
front of the function type means that the second (linear) argument of
#dyncode("list_map_cloptr") is call-by-value and it is still available
after #dyncode("list_map_cloptr") returns.\

')

#para('\

Let us now see some concrete code in which a linear closure-function is
created, called, and finally freed:

#atscode('\
implement
main0 () =
{
//
val xs =
$list_vt{int}(0, 1, 2, 3, 4)
//
val len = list_vt_length (xs)
//
val f = lam (x: int): int =<cloptr1> x * len
//
val ys =
list_map_cloptr<int><int> ($UNSAFE.list_vt2t(xs), f)
//
val () = cloptr_free($UNSAFE.castvwtp0{cloptr(void)}(f))
//
val () = println! ("xs = ", xs) // xs = 0, 1, 2, 3, 4
val () = println! ("ys = ", ys) // ys = 0, 5, 10, 15, 20
//
val ((*freed*)) = list_vt_free (xs)
val ((*freed*)) = list_vt_free (ys)
//
} (* end of [main0] *)
')

The function #dyncode("cloptr_free") is given the following
interface:

#atscode('\
fun cloptr_free{a:t0p}(pclo: cloptr (a)):<!wrt> void
')

Also, the cast involved in
#dyncode("$UNSAFE.castvwtp0{cloptr(void)}(f)") is a safe cast.

')

#para('\

The support for linear closure-functions in ATS1 is crucial in a setting
where higher-order functions are needed but run-time garbage collection
(GC) is not allowed or supported. In ATS2, linear closure-functions become
much less important as programming with higher-order functions in a setting
without GC can be more conveniently achieved through the use templates.
However, if one wants to store closure-functions in a data structure
without causing memory leaks, it is necessary to use linear closure-functions
unless GC can be relied upon to reclaim memory.\

')

</sect1>#comment("sect1/id=heap-allocated-linear-closure-functions")

<!-- ****** ****** -->

</chapter>
<!--id="introduction_to_views_and_viewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
