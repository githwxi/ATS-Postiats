%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="theorem-proving_in_ats_lf">
#title("Theorem-Proving in ATS/LF")

#para("\

Within the ATS programming language system, there is a component named
ATS/LF for supporting (interactive) therorem-proving. In ATS/LF,
theorem-proving is done by constructing proofs as total functional
programs. It will soon become clear that this style of theorem-proving can
be combined cohesively with functional programming to yield a programming
paradigm that is considered the signature of ATS: #emphasis("programming
with theorem-proving"). Moreover, ATS/LF can be employed to encode various
deduction systems and their meta-properties.\

")

#para("\

Please find #mycodelink("CHAP_THMPRVING/", "on-line")
the code employed for illustration in this chapter plus some additional
code for testing.\

")

<!-- ****** ****** -->

<sect1
 id="encoding_relations_as_dataprops">
#title("Encoding Relations as Dataprops")

#para("\

In the statics of ATS, there is a built-in sort #emphasis("prop") for
static terms that represent types for proofs. A static term of the sort
#emphasis("prop") can also be referred to as a type or more accurately, a
prop-type or just a prop. A dataprop can be declared in a manner that is
mostly similar to the declaration of a datatype. For instance, a prop
construct #stacode("FIB") is introduced in the following dataprop declaration:

#atscode("\
dataprop
FIB(int, int) =
  | FIB0(0, 0) of () // [of ()] can be dropped
  | FIB1(1, 1) of () // [of ()] can be dropped
  | {n:nat}{r0,r1:nat}
    FIB2(n+2, r0+r1) of (FIB(n, r0), FIB(n+1, r1))
// end of [FIB]
")

The sort assigned to #stacode("FIB") is #emphasis("(int, int) -&gt; prop"),
indicating that #stacode("FIB") takes two static integers to form a
prop-type. There are three data (or proof) constructors associated with
#stacode("FIB"): #dyncode("FIB0"), #dyncode("FIB1") and #dyncode("FIB2"), which are
assigned the following function types (or more accurately, prop-types):

<itemizedlist>

<listitem>
#para("\
#dyncode("FIB0"): #stacode("() -> FIB(0, 0)")
")
</listitem>

<listitem>
#para("\
#dyncode("FIB1"): #stacode("() -> FIB(1, 1)")
")
</listitem>

<listitem>
#para("\
#dyncode("FIB2"):
 #stacode("{n:nat}{r0,r1:int} (FIB(n, r0), FIB(n+1, r1)) -> FIB(n+2, r0+r1)")
")
</listitem>

</itemizedlist>

Given a natural number n and an integer r, it should be clear that
#stacode("FIB(n, r)") encodes the relation fib(n) = r, where fib is defined
by the following three equations:

<itemizedlist>

<listitem>
#para("\
fib(0) = 0, and
")
</listitem>

<listitem>
#para("
fib(1) = 1, and
")
</listitem>

<listitem>
#para("\
fib(n+2) = fib(n+1) + fib(n) for n >= 2.
")
</listitem>

</itemizedlist>

A proof value of the prop #stacode("FIB(n, r)") can be constructed if and
only if fib(n) equals r. For instance, the proof value
#dyncode("FIB2(FIB0(), FIB1())") is assigned the prop #dyncode("FIB(2,
1)"), attesting to fib(2) equaling 1.\

")#comment("para")

#para("\

As another example of dataprop, the following declaration introduces a prop
constructor #stacode("MUL") together with three associated proof constructors:

#atscode("\
dataprop MUL(int, int, int) =
  | {n:int} MULbas(0, n, 0) of ()
  | {m:nat}{n:int}{p:int}
    MULind(m+1, n, p+n) of MUL(m, n, p)
  | {m:pos}{n:int}{p:int}
    MULneg(~(m), n, ~(p)) of MUL(m, n, p)
// end of [MUL]
")

Given three integers m, n and p, the prop #stacode("MUL(m, n, p)")
encodes the relation m*n = p. As for #dyncode("MULbas"), #dyncode("MULind")
and #dyncode("MULneg"), they correspond to the following three equations,
respectively:

<itemizedlist>

<listitem>
#para("\
0*n = 0 for every integer n, and
")
</listitem>

<listitem>
#para("\
(m+1)*n = m*n + n for each pair of integers m and n, and
")
</listitem>

<listitem>
#para("\
(~m)*n = ~(m*n) for each pair of integers m and n.
")
</listitem>

</itemizedlist>

In other words, the dataprop declaration for #stacode("MUL") encodes the
relation that represents the standard multiplication function on integers.\

")

#para("\

It can be readily noticed that the process of encoding a functional
relation (i.e., a relation representing a function) as a dataprop is
analogous to implementing a function in a logic programming language such
as Prolog.\

")#comment("para")

</sect1><!--id="encoding_relations_as_dataprops"-->

<!-- ****** ****** -->

<sect1 id="constructing_proofs_as_total_functions">

#title("Constructing Proofs as Total Functions")

#para("\
Theorems are represented as types (or more accurately, props) in
ATS/LF. For instance, the following prop states that integer multiplication
is commutative:

#atscode("\
{m,n:int}{p:int} MUL(m, n, p) -<prf> MUL(n, m, p)
")

Constructing a proof for a theorem in ATS/LF means implementing a total
value (which is most likely to be a total function) of the type that is the
encoding of the theorem in ATS/LF, where being total means being pure and
terminating. Please note that this style of theorem-proving may seem rather
peculiar to those who have never tried it before.
")#comment("para")

#para("\
As a simple introductory example, let us first construct a proof
function in ATS/LF that is given the following interface:

#atscode("\
prfun mul_istot {m,n:int} (): [p:int] MUL(m, n, p)
")

The keyword #keycode("prfun") indicates that the interface is for a proof
function (in contrast to a non-proof function).  Note that
#dyncode("mul_istot") is declared to be of the following type (or more
accurately, prop):

#atscode("{m,n:int} () -<prf> [p:int] MUL(m, n, p)")

which essentially states that integer multiplication is a total function:
Given any two integers m and n, there exists an integer p such that m, n
and p are related according to the structurally inductively defined
relation #stacode("MUL"). The following code gives an implementation of
#dyncode("mul_istot"):

#atscode("\
primplement
mul_istot{m,n}() = let
//
prfun istot
  {m:nat;n:int} .<m>. (): [p:int] MUL(m, n, p) =
  sif m > 0 then MULind(istot{m-1,n}()) else MULbas()
// end of [istot]
//
in
  sif m >= 0 then istot{m,n}() else MULneg(istot{~m,n}())
end // end of [mul_istot]  
")

Note that the keyword #keycode("primplement") (instead of
#keycode("implement")) initiates the implementation of a proof.  The inner
proof function #dyncode("istot") encodes a proof showing that there exists
an integer p for any given natural number m and integer n such that m, n
and p are related (according to #stacode("MUL")).  The keyword
#keycode("sif") is used for forming a conditional (proof) expression in
which the test is a static expression.  The proof encoded by
#dyncode("istot") proceeds by induction on m; if m > 0 holds, then there
exists an integer p1 such that m-1, n and p1 are related by induction
hypothesis (on m-1) and thus m, n and p are related for p = p1+n according
to the rule encoded by #dyncode("MULind"); if m = 0, then m, n and p are
related for p = 0. The proof encoded by the implementation of
#dyncode("mul_istot") goes like this: if m is a natural number, then the
lemma proven by #dyncode("istot") shows that m, n and some p are related;
if m is negative, then the same lemma shows that ~m, n and p1 are related
for some integer p1 and thus m, n and p are related for p = ~p1 according
to the rule encoded by #dyncode("MULneg").\

")#comment("para")

#para("\

As another example of theorem-proving in ATS/LF, a proof function of
the name #dyncode("mul_isfun") is given as follows:

#atscode("\
prfn mul_isfun
  {m,n:int}{p1,p2:int}
(
  pf1: MUL(m, n, p1), pf2: MUL(m, n, p2)
) : [p1==p2] void = let
  prfun isfun
    {m:nat;n:int}{p1,p2:int} .<m>.
  (
    pf1: MUL(m, n, p1), pf2: MUL(m, n, p2)
  ) : [p1==p2] void =
    case+ pf1 of
    | MULind(pf1prev) => let
        prval MULind(pf2prev) = pf2 in isfun (pf1prev, pf2prev)
      end // end of [MULind]
    | MULbas() => let
        prval MULbas() = pf2 in ()
      end // end of [MULbas]
  // end of [isfun]
in
  case+ pf1 of
  | MULneg(pf1nat) => let
      prval MULneg(pf2nat) = pf2 in isfun (pf1nat, pf2nat)
    end // end of [MULneg]
  | _ (*non-MULneg*) =>> isfun (pf1, pf2)
end // end of [mul_isfun]
")

The keyword #keycode("prfn") is used for defining a non-recursive proof
function, and the keyword #keycode("prval") for introducing bindings that
relate names to proof expressions, that is, expressions of prop-types. As
far as pattern matching exhaustiveness is concerned, #keycode("prval") is
equivalent to #keycode("val+") (as proofs cannot contain any effects such
as failures of pattern matching).\

")

#para("\

What #dyncode("mul_isfun") proves is that the relation #stacode("MUL") is
functional on its first two arguments: If m, n and p1 are related according
to #stacode("MUL") and m, n and p2 are also related according to
#stacode("MUL"), then p1 and p2 are equal.  The statement is first proven
by the inner proof function #dyncode("isfun") under the assumption that m
is a natural number, and then the assumption is dropped.  Let us now take a
look at the first matching clause in the body of #dyncode("isfun"). If the
clause is chosen, then #dyncode("pf1") matches the pattern
#dyncode("MULind(pf1prev)") and thus #dyncode("pf1prev") is of the type
#dyncode("MUL(m1, n1, q1)") for some natural number m1 and integer n1 and
integer p1 such that m=m1+1, n=n1, and p1=q1+n1. This means that
#dyncode("pf2") must be of the form #dyncode("MULind(pf2prev)") for some
#dyncode("pf2prev") of the type #dyncode("MUL(m2, n2, q2)") such that
m2+1=m, n2=n and p2=q2+n2. By calling #dyncode("isfun") on #dyncode("pf1prev")
and #dyncode("pf2prev"), which amounts to invoking the induction hypothesis
on m-1, we establish q1=q2, which implies p1=p2. The second matching clause
in the body of #dyncode("isfun") can be readily understood, which
corresponds to the base case in the inductive proof encoded by
#dyncode("isfun").\

")

</sect1><!--id="constructing_proofs_as_total_functions"-->

<!-- ****** ****** -->

<sect1
 id="example_distributivity_of_multiplication">
#title("Example: Distributivity of Multiplication")

#para("\
The distributivity of multiplication over addition means that the following
equation holds

#atscode("m * (n1 + n2) = m * n1 + m * n2")

for m, n1 and n2 ranging over integers. A direct encoding of the equation
is given by the following (proof) function interface:

#atscode("\
//
prfun
mul_distribute
  {m,n1,n2:int}{p1,p2:int}
  (MUL(m, n1, p1), MUL(m, n2, p2)): MUL(m, n1+n2, p1+p2)
//
")

Plainly speaking, the encoding states that the product of m and (n1+n2) is
p1+p2 if the product of m and n1 is p1 and the product of m and n2 is p2.
An implementation of #dyncode("mul_distribute") is given as follows:

#atscode("\
primplement
mul_distribute
{m,n1,n2}{p1,p2}
  (pf1, pf2) = let
//
prfun
auxnat
{m:nat}{p1,p2:int} .<m>.
(
  pf1: MUL(m, n1, p1), pf2: MUL(m, n2, p2)
) : MUL(m, n1+n2, p1+p2) =
(
  case+ (pf1, pf2) of
  | (MULbas(), MULbas()) => MULbas()
  | (MULind pf1, MULind pf2) => MULind(auxnat (pf1, pf2))
) (* end of [auxnat] *)
//
in
//
sif
m >= 0
then (
  auxnat (pf1, pf2)
) // end of [then]
else let
  prval MULneg(pf1) = pf1
  prval MULneg(pf2) = pf2
in
  MULneg(auxnat (pf1, pf2))
end // end of [else]
//
end // end of [mul_distribute]
")

The inner function #dyncode("auxnat") encodes a straighforward
proof based on mathematical induction that establishes the following
equation:

#atscode("\
m * (n1 + n2) = m * n1 + m * n2
")

for m ranging over natural numbers and n1 and n2 ranging over integers. The
function #dyncode("mul_distribute") can then be implemented immediately
based on #dyncode("auxnat").\

")

</sect1><!--id="example_distributivity_of_multiplication"-->

<!-- ****** ****** -->

<sect1
 id="example_commutativity_of_multiplication">
#title("Example: Commutativity of Multiplication")

#para("\
The commutativity of multiplication means that the following equation
holds

#atscode("m * n = n * m")

for m and n ranging over integers. A direct encoding of this equation
is given by the following (proof) function interface:

#atscode("\
//
prfun
mul_commute{m,n:int}{p:int}(MUL(m, n, p)): MUL(n, m, p)
//
")

An implementation of #dyncode("mul_commute") is given as follows:

#atscode("\
primplmnt
mul_commute
  {m,n}{p}(pf0) = let
//
prfun
auxnat
{m:nat}
{p:int} .<m>.
(
pf: MUL(m, n, p)
) : MUL(n, m, p) =
(
  case+ pf of
  | MULbas() => mul_nx0_0{n}()
  | MULind(pf1) =>
      mul_distribute(auxnat(pf1), mul_nx1_n{n}())
    // end of [MULind]
) (* end of [auxnat] *)
//
in
//
sif
m >= 0
then auxnat(pf0)
else let
  prval MULneg(pf1) = pf0 in mul_neg_2(auxnat(pf1))
end // end of [else]
//
end // end of [mul_commute]
")

where the following proof functions are called:

#atscode("\
//
prfun
mul_nx0_0{n:int}(): MUL(n, 0, 0) // n * 0 = 0
//
prfun
mul_nx1_n{n:int}(): MUL(n, 1, n) // n * 1 = n
//
prfun
mul_neg_2
  {m,n:int}{p:int}(MUL(m,n,p)): MUL(m,~n,~p) // m*(~n) = ~(m*n)
//
")

The inner function #dyncode("auxnat") encodes a straighforward
proof based on mathematical induction that establishes the following
equation:

#atscode("m * n = n * m")

for m ranging over natural numbers and n ranging over integers.
The function #dyncode("mul_commute") can then be implemented immediately
based on #dyncode("auxnat").\
")

</sect1><!--id="example_commutativity_of_multiplication"-->

<!-- ****** ****** -->

<sect1 id="datasorts">
#title("Algebraic Datasorts")

#para("\
A datasort is rather similar to a dataype. However, the former is
declared in the statics of ATS while the latter in the dynamics of ATS. To
see a typical need for datasorts, let us try to encode a theorem in ATS
stating that s is strictly less than 2<superscript>h</superscript> if s and
h are the size and height, respectively, of a given binary tree. To
represent binary trees in the statics, we first declare a datasort as
follows:

#atscode("\
datasort tree = E of () | B of (tree, tree)
")

The name of the declared datasort is #stacode("tree") and there are two
constructor associated with it: #stacode("E") and #stacode("B"), where E
forms the empty tree and B forms a tree by joining two given trees.  For
instance, #stacode("B(E(), E())") is a static term of the sort
#stacode("tree") that represents a singleton tree, that is, a tree
consisting of exactly one node.  Please note that the trees formed by E and
B are really just tree skeletons carrying no data.\

")

#para("\
We now declare two dataprops as follows for capturing the notion of
size and height of trees:

#atscode("\
dataprop
SZ (tree, int) =
  | SZE (E (), 0) of ()
  | {tl,tr:tree}{sl,sr:nat}
    SZB (B (tl, tr), 1+sl+sr) of (SZ (tl, sl), SZ (tr, sr))
// end of [SZ]

dataprop
HT (tree, int) =
  | HTE (E (), 0) of ()
  | {tl,tr:tree}{hl,hr:nat}
    HTB (B (tl, tr), 1+max(hl,hr)) of (HT (tl, hl), HT (tr, hr))
// end of [HT]
")

Given a tree t and an integer s, SZ(t, s) encodes the relation that the
size of t equals s. Similiarly, given a tree t and an integer h, HZ(t, h)
encodes the relation that the height of t equals h.
")

#para("\
As the power function (of base 2) is not available in the statics of ATS,
we declare a dataprop as follows to capture it:

#atscode("\
dataprop
POW2 (int, int) =
  | POW2bas (0, 1)
  | {n:nat}{p:int} POW2ind (n+1, p+p) of POW2 (n, p)
// end of [POW2]
")

Given two integers h and p, POW2 (h, p) encodes the relation that
2<superscript>h</superscript> equals p.
")

#para("\
It should be clear by now that the following proof function
interface encodes the theorem stating that s is strictly less than
2<superscript>h</superscript> if s and h are the size and height of a
given binary tree:

#atscode("\
prfun
lemma_tree_size_height
  {t:tree}{s,h:nat}{p:int}
(
  pf1: SZ (t, s), pf2: HT (t, h), pf3: POW2 (h, p)
) : [s < p] void // end of [prfun]
")

Let us now construct an implementation of this proof function as follows.
")#comment("para")

#para("\
We first establish some elementary properties on the power function
(of base 2):

#atscode("\
prfun
pow2_istot
  {h:nat} .<h>. (): [p:int] POW2 (h, p) =
  sif h==0
    then POW2bas () else POW2ind (pow2_istot {h-1} ())
  // end of [sif]
// end of [pow2_istot]

prfun
pow2_pos
  {h:nat}{p:int} .<h>.
  (pf: POW2 (h, p)): [p > 0] void =
  case+ pf of
  | POW2bas () => () | POW2ind (pf1) => pow2_pos (pf1)
// end of [pow2_pos]

prfun
pow2_inc
  {h1,h2:nat | h1 <= h2}{p1,p2:int} .<h2>.
  (pf1: POW2 (h1, p1), pf2: POW2 (h2, p2)): [p1 <= p2] void =
  case+ pf1 of
  | POW2bas () => pow2_pos (pf2)
  | POW2ind (pf11) => let
      prval POW2ind (pf21) = pf2 in pow2_inc (pf11, pf21)
    end // end of [POW2ind]
// end of [pow2_inc]
")

Clearly, #dyncode("pow2_istot") shows that the relation encoded by the
dataprop #stacode("POW2") is a total relation; #dyncode("pow2_pos") proves
that the power of each natural number is positive; #dyncode("pow2_inc")
establishes that the power function is increasing.\

")

#para("\

The function #dyncode("lemma_tree_size_height") can be implemented
as follows:

#atscode("\
primplement
lemma_tree_size_height
  (pf1, pf2, pf3) = let
//
prfun
lemma{t:tree}
  {s,h:nat}{p:int} .<t>.
(
  pf1: SZ (t, s)
, pf2: HT (t, h)
, pf3: POW2 (h, p)
) : [p > s] void =
(
  scase t of
  | E () => let
      prval SZE () = pf1
      prval HTE () = pf2
      prval POW2bas () = pf3
   in
     // nothing
   end // end of [E]
  | B (tl, tr) => let
      prval SZB (pf1l, pf1r) = pf1
      prval HTB {tl,tr}{hl,hr} (pf2l, pf2r) = pf2
      prval POW2ind (pf31) = pf3
      prval pf3l = pow2_istot {hl} ()
      prval pf3r = pow2_istot {hr} ()
      prval () = lemma (pf1l, pf2l, pf3l)
      prval () = lemma (pf1r, pf2r, pf3r)
      prval () = pow2_inc (pf3l, pf31)
      prval () = pow2_inc (pf3r, pf31)
    in
      // nothing
    end // end of [B]
) (* end of [lemma] *)
//
in
  lemma (pf1, pf2, pf3)
end // end of [lemma_tree_size_height]
")

The inner function #dyncode("lemma"), which is given a termination metric
consisting of a static term of the sort #stacode("tree"), corresponds to a
proof based on structural induction (where the involved structure is the
binary tree #dyncode("t")).  Given two terms t1 and t2 of the sort
#stacode("tree"), t1 is (strictly) less than t2 if t1 is a (proper)
substructure of t2. Evidently, this is a well-founded ordering.  The
keyword #keycode("scase") is used to form a dynamic expression that does
case-analysis on a static term (built by constructors associated with some
declared datasort). So the relation between #keycode("sif") and
#keycode("scase") is essentially parallel to that between #keycode("if")
and #keycode("case").  Please find the entirety of the above code
#mycodelink("CHAP_THMPRVING/tree.dats", "on-line").\

")#comment("para")

</sect1><!--id="datasorts"-->

<!-- ****** ****** -->

<sect1
 id="example_establishing_properties_on_braun_trees">
#title("Example: Establishing Properties on Braun Trees")

#para("\

As stated previously in this book, a binary tree is a Braun tree if it is
empty or if its left and right subtrees are Braun trees and the size of the
left one minus the size of the right one is either 0 or 1.  Formally, we
can declare the following dataprop #dyncode("isBraun") to capture the notion
of Braun trees:

#atscode("\
dataprop
isBraun (tree) =
  | isBraunE (E) of ()
  | {tl,tr:tree}
    {sl,sr:nat | sr <= sl; sl <= sr + 1}
    isBraunB (
      B(tl, tr)) of (isBraun tl, isBraun tr, SZ (tl, sl), SZ (tr, sr)
    ) // end of [isBraunB]
// end of [isBraun]
")
")

#para("\
We first prove that there exists a Braun tree of any given size.
This property can be encoded as follows in ATS:

#atscode("\
prfun lemma_existence {n:nat} (): [t:tree] (isBraun (t), SZ (t, n))
")

Literally, the type assigned to #dyncode("lemma_existence") means that there
exists a tree t for any given natural number n such that t is a Braun tree
and the size of t is n. The following code gives an implementation of
#dyncode("lemma_existence"):

#atscode("\
primplement
lemma_existence
  {n}((*void*)) = let
//
prfun
lemma{n:nat} .<n>.
(
  // argless
) : [t:tree] (isBraun (t), SZ (t, n)) =
  sif n==0
    then (isBraunE (), SZE ())
    else let
      stadef nl = n / 2
      stadef nr = n - 1 - nl
      val (pfl1, pfl2) = lemma{nl}((*void*))
      and (pfr1, pfr2) = lemma{nr}((*void*))
    in
      (isBraunB (pfl1, pfr1, pfl2, pfr2), SZB (pfl2, pfr2))
    end // end of [else]
  // end of [sif]
//
in
  lemma{n}((*void*))
end // end of [lemma_existence]
")

Note that #keycode("stadef") is a keyword in ATS for introducting a static
binding between a name and a static term (of any sort). If one prefers,
this keyword can be chosen to replace the keyword #keycode("typedef") (for
introducing a name and a static term of the sort #keycode("t@ype")).

")#comment("para")

#para("\
Next we show that two Braun trees of the same size are identical. This
property can be encoded as follows:

#atscode("\
prfun
lemma_unicity
  {n:nat}{t1,t2:tree}
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) // end of [lemma_unicity]
")

where #stacode("EQ") is a prop-constructor introduced by the following
dataprop declaration:

#atscode("\
dataprop EQ (tree, tree) =
  | EQE (E, E) of ()
  | {t1l,t1r:tree}{t2l,t2r:tree}
    EQB (B (t1l, t1r), B (t2l, t2r)) of (EQ (t1l, t2l), EQ (t1r, t2r))
// end of [EQ]
")

Clearly, #stacode("EQ") is the inductively defined equality on trees.
An implementation of the proof function #dyncode("lemma_unicity") is presented
as follows:

#atscode("\
primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
  prfun lemma{n:nat}{t1,t2:tree} .<n>.
  (
    pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
  ) : EQ (t1, t2) =
    sif n==0
      then let
        prval SZE () = pf3 and SZE () = pf4
        prval isBraunE () = pf1 and isBraunE () = pf2
      in
        EQE ()
      end // end of [then]
      else let
        prval SZB (pf3l, pf3r) = pf3
        prval SZB (pf4l, pf4r) = pf4
        prval isBraunB (pf1l, pf1r, pf1lsz, pf1rsz) = pf1
        prval isBraunB (pf2l, pf2r, pf2lsz, pf2rsz) = pf2
        prval () = SZ_istot (pf1lsz, pf3l) and () = SZ_istot (pf1rsz, pf3r)
        prval () = SZ_istot (pf2lsz, pf4l) and () = SZ_istot (pf2rsz, pf4r)
        prval pfeql = lemma (pf1l, pf2l, pf3l, pf4l)
        prval pfeqr = lemma (pf1r, pf2r, pf3r, pf4r)
      in
        EQB (pfeql, pfeqr)
      end // end of [else]
    // end of [sif]
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
")

Note that the proof function #dyncode("SZ_istot") in this implementation of
#dyncode("lemma_unicity") is given the following interface:

#atscode("\
prfun
SZ_istot{t:tree}{n1,n2:int}
  (pf1: SZ (t, n1), pf2: SZ (t, n2)): [n1==n2] void
")

which simply states that #stacode("SZ") is a functional relation with
respect to its first parameter, that is, there is at most one n for every
given t such that t and n are related according to #stacode("SZ").

Clearly, the mathematical proof corresponding to this implementation is of
induction on the size n of the two given trees t1 and t2. In the base case
where n is 0, t1 and t2 are equal as they both are the empty tree. In the
inductive case where n > 0, it is proven that n1l and n2l are of the same
value where n1l and n2l are the sizes of the left subtrees of t1 and t2,
respecitvely; similarly, it is also proven that n1r and n2r are of the same
value where n1r and n2r are the sizes of the right subtrees of t1 and t2,
respectively; by induction hypothesis on n1l, the left substrees of t1 and
t2 are the same; by induction hypothesis on n1r, the right substrees of t1
and t2 are the same; by the definition of tree equality (encoded by
#stacode("EQ")), t1 and t2 are the same.\

")#comment("para")

#para("\

As a comparison, the following code gives another implementation of
#dyncode("lemma_unicity") that is of a different (and rather unusual) style:

#atscode("\
primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
//
prfun
lemma{n:nat}{t1,t2:tree} .<t1>.
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) =
  case+ (pf1, pf2) of
//
  | (isBraunE (), isBraunE ()) => EQE ()
//
  | (isBraunB (pf11, pf12, pf13, pf14),
     isBraunB (pf21, pf22, pf23, pf24)) => let
//
      prval SZB (pf31, pf32) = pf3
      prval SZB (pf41, pf42) = pf4
//
      prval () = SZ_istot (pf13, pf31)
      prval () = SZ_istot (pf23, pf41)
//
      prval () = SZ_istot (pf14, pf32)
      prval () = SZ_istot (pf24, pf42)
//
      prval pfeq1 = lemma (pf11, pf21, pf31, pf41)
      prval pfeq2 = lemma (pf12, pf22, pf32, pf42)
    in
      EQB (pfeq1, pfeq2)
    end
//
  | (isBraunE _, isBraunB _) =/=>
    let prval SZE _ = pf3 and SZB _ = pf4 in (*none*) end
  | (isBraunB _, isBraunE _) =/=>
    let prval SZB _ = pf3 and SZE _ = pf4 in (*none*) end
//
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
")

This implementation corresponds to a proof by induction on the structure of
the given tree t1. Note that the use of the special symbol #keycode("=/=>"),
which is a keyword in ATS, is to indicate to the typechecker of ATS that
the involved clause of pattern matching is #emphasis("unreachable"): It is the
responsibility of the programmer to establish the falsehood on the
right-hand side of the clause. Please find the entirety of the above code
#mycodelink("CHAP_THMPRVING/brauntree.dats", "on-line").\

")#comment("para")

</sect1><!--id="example_establishing_properties_on_braun_trees"-->

<!-- ****** ****** -->

<sect1
 id="programmer_centric_theorem_proving">
#title("Programmer-Centric Theorem-Proving")

#para("\

I have so far presented several formal proofs in ATS.  However,
constructing such formal proofs is at most a secondary issue in ATS. If I
compare ATS with theorem-proving systems such as Isabelle and Coq, I would
like to state emphatically that the design for theorem-proving in ATS takes
a fundamentally different view of theorem-proving. In particular,
theorem-proving in ATS does not take a foundational approach that
establishes the validity of a theorem by reducing it to the validity of a
minimal set of axioms and rules. Instead, theorem-proving in ATS is mostly
done in a semi-formal manner and its primary purpose is to greatly diminish
the chance of a programmer making use of incorrect assumptions or
claims. In this regard, theorem-proving in ATS is rather similar to
contructing informal paper-and-pencil proofs (in mathematics and
elsewhere). I refer to this style of theorem-proving in ATS as being
programmer-centric.  In order to allow the reader to obtain a more concrete
feel as to what this style of theorem-proving is like, I present in the
rest of this section a simple but telling example of programmer-centric
theorem-proving.\

")#comment("para")

#para("\

Suppose we are to prove that the square of any rational number cannot equal
2. Note that this statement is a bit weaker than the one stating that the
square root of 2 is irrational as the latter assumes the very existence of the
square root of 2. Let us first sketch an informal proof as follows.\

")#comment("para")

#para("\

Suppose that (m/n)#sup("2")=2 for some positive numbers m and n. Clearly,
this means (m)#sup("2")=2(n)#sup("2"), implying m being an even number.
Let m=2m#sub("2"). We have (2m#sub("2"))#sup("2")=2(n)#sup("2"), implying
(n/m#sub("2"))#sup("2")=2. Clearly, m &gt; n &gt; m#sub("2") holds. If we
assume that m is the least positive number satisfying (m/n)#sup("2")=2 for
some n, then a contradiction is reached as n satisfies the same property.
Therefore, there is no rational number whose square equals 2. Clearly,
this proof still holds if the number 2 is replaced with another prime number.

")#comment("para")

#para("\

The primary argument in the above informal proof can be encoded in
ATS as follows:

#atscode('\
//
extern
prfun
mylemma_main
{m,n,p:int | m*m==p*n*n}(PRIME(p)): [m2:nat | n*n==p*m2*m2] void
//
primplmnt
mylemma_main
{m,n,p}(pfprm) = let
  prval pfeq_mm_pnn =
    eqint_make{m*m,p*n*n}()
  prval () = square_is_nat{m}()
  prval () = square_is_nat{n}()
  prval () = lemma_PRIME_param(pfprm)
  prval
  pfmod1 =
    lemma_MOD0_intr{m*m,p,n*n}()
  prval
  pfmod2 = mylemma1{m,p}(pfmod1, pfprm)
  prval
  [m2:int]
  EQINT() =
    lemma_MOD0_elim(pfmod2)
  prval EQINT() = pfeq_mm_pnn
  prval () =
  __assert{p}{p*m2*m2,n*n}() where
  {
    extern prfun __assert{p:pos}{x,y:int | p*x==p*y}(): [x==y] void
  } (* end of [where] *) // end of [prval]
in
  #[m2 | ()]
end // end of [mylemma_main]
//
')

The interface for #dyncode("mylemma_main") states that
(m)#sup("2")=p(n)#sup("2") implies (n)#sup("2")=p(m#sub("2"))#sup("2") for
some natural number m#sub("2").

")

#para("\

Given two integers m and p, #dyncode("MOD0(m,p)") means that m equals the
product of p and q for some natural number q. This meaning is encoded into
the following two proof functions:

#atscode("\
//
prfun
lemma_MOD0_intr{m,p,q:nat | m==p*q}(): MOD0(m, p)
//
prfun
lemma_MOD0_elim{m,p:int}(MOD0(m, p)): [q:nat] EQINT(m, p*q)
//
")

where #dyncode("EQINT") is a dataprop declared as follows:

#atscode('\
dataprop EQINT(int, int) = {x:int} EQINT(x, x)
')

Given two integers x and y, #dyncode("EQINT(x, y)") simply means that
x equals y.  Also, the function #dyncode("eqint_make") is assgined the
interface below:

#atscode('\
prfun eqint_make{x,y:int | x == y}((*void*)): EQINT (x, y)
')

Given an integer p, #dyncode("PRIME(p)") means that p is a prime number.
The following two proof functions are called in the above implementation
of #dyncode("mylemma_main"):

#atscode('\
//
prfun lemma_PRIME_param{p:int}(PRIME(p)): [p >= 2] void
//
prfun mylemma1{n,p:int}(MOD0(n*n, p), PRIME(p)): MOD0(n, p)
//
')

The proof function #dyncode("mylemma1") encodes a proposition stating that
p divides n if p divides the square of n and p is also a prime number.
I give no implementation of #dyncode("mylemma1") as I see the encoded
proposition to be obviously true. Certainly, this is a kind of programmer-centric
judgment. \

")

#para("\

One may find that
the following declaration in the implementation of #dyncode("mylemma_main")
looks mysterious:

#atscode("\
  prval EQINT() = pfeq_mm_pnn
")

Note that #dyncode("pfeq_mm_pnn")
is of the prop #dyncode('EQINT(m*m, p*(n*n))').
Also, m equaling p*m#sub("2") for some natural number m#sub("2") is
available when the above declaration is typechecked.
This means that the equality between
(p*m#sub("2"))#sup("2") and p*(n)#sup("2") is added into the current store
of (static) assumptions after the above declaration is typechecked.

")

#para("\

Please find #mycodelink("CHAP_THMPRVING/sqrt2_irrat.dats", "on-line") the
entirety of an encoded proof showing that there exists no rational number whose
square equals 2.\

")

</sect1><!--id="programmer_centric_theorem_proving"-->

<!-- ****** ****** -->

</chapter><!--id="theorem-proving_in_ats_lf"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
