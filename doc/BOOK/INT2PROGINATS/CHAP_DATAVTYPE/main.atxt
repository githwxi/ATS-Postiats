%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="dataviewtypes">
#title("Dataviewtypes as Linear Datatypes")

#para("\

A dataviewtype can be thought of as a linear version of datatype. To a
large extent, it is a combination of a datatype and a dataview. This
programming feature is primarily introduced into ATS for the purpose of
providing in the setting of manual memory management the kind of
convenience brought by pattern matching. In a situation where GC must be
reduced or even completely eliminated, dataviewtypes can often be chosen as
a replacement for datatypes.  I now present in this chapter some commonly
encountered dataviewtypes and their uses.

")

<!-- ****** ****** -->

<sect1
id="linear_optional_values">
#title("Linear Optional Values")

#para("\

When an optional value is created, the value is most likely to be used
immediately and then discarded. If such a value is assigned a linear type,
then the memory allocated for storing it can be efficiently reclaimed.  The
dataviewtype #stacode("option_vt") for linear optional values is declared as
follows:

#atscode('\
datavtype
option_vt (a:t@ype+, bool) =
  | Some_vt (a, true) of a | None_vt (a, false) of ()
// end of [option_vt]

vtypedef Option_vt (a:t@ype) = [b:bool] option_vt (a, b)
')

Note that #keycode("datavtype") is just the short version of
#keycode("dataviewtype").  The introduced dataviewtype
#stacode("option_vt") is covariant in its first argument and there are two
data constructors #dyncode("Some_vt") and #dyncode("None_vt") associated
with it. In the following example, #dyncode("find_rightmost") tries to find
the rightmost element in a list that satisfies a given predicate:

#atscode('\
fun{a:t@ype}
find_rightmost{n:nat} .<n>.
(
  xs: list (a, n), P: (a) -<cloref1> bool
) : Option_vt (a) =
(
  case+ xs of
  | list_cons (x, xs) => let
      val opt = find_rightmost (xs, P)
    in
      case opt of
      | ~None_vt () => if P (x) then Some_vt (x) else None_vt ()
      | _ (*Some_vt*) => opt
    end // end of [list_cons]
  | list_nil () => None_vt ()
) (* end of [find_rightmost] *)
')

Note that the tilde symbol (#keycode("~")) in front of the pattern
#dyncode("None_vt()") indicates that the memory for the node that matches
the pattern is freed before the body of the matched clause is evaluated.
In this case, no memory is actually freed as #dyncode("None_vt") is mapped
to the null pointer.  I will soon give more detailed explanation about
freeing memory allocated for constructors associated with dataviewtypes.

")

#para('\

As another example, the following function template
#dyncode("list_optcons") tries to construct a new list with its head
element extracted from a given optional value:

#atscode('\
fn{a:t@ype}
list_optcons
  {b:bool}{n:nat}
(
  opt: option_vt (a, b), xs: list (a, n)
) : list (a, n+bool2int(b)) =
  case+ opt of
  | ~Some_vt (x) => list_cons (x, xs) | ~None_vt () => xs
// end of [list_optcons]
')

The symbol #stacode("bool2int") stands for a built-in static function in
ATS that maps #dyncode("true") and #dyncode("false") to 1 and 0,
respectively. What is special here is that the first argument of
#dyncode("list_optcons"), which is linear, is consumed after a call to
#dyncode("list_optcons") returns and the memory it occupies is reclaimed.

')

</sect1>#comment("sect1/id=linear_optional_values")

<!-- ****** ****** -->

<sect1
id="linear_lists">
#title("Linear Lists")

#para('\

A linear list is essentially the same as a singly-linked list depicted by
the dataview #stacode("slist_v"). However, memory allocation and
deallocation of list-nodes not handled previously are handled this time.
The following declaration introduces a linear datatype #stacode("list_vt"),
which forms a boxed type (of the sort #stacode("viewtype")) when applied to
a type and an integer:

#atscode('\
datavtype
list_vt (a:t@ype+, int) =
  | list_vt_nil (a, 0) of ()
  | {n:nat}
    list_vt_cons (a, n+1) of (a, list_vt (a, n))
// end of [list_vt]
')

Given a type T and an integer I, #stacode("list_vt(T, I)") is
for linear lists of length I in which each element is of the type T.

')

#para('\

Assume that a data constructor named #emphasis("foo") is associated with a
dataviewtype.  Then there is a corresponding viewtype construtor of the name
#emphasis("foo_unfold") that takes n+1 addresses to form a viewtype, where
n is the arity of #emphasis("foo"). For instance, there is a viewtype
constructor #stacode("list_vt_cons_unfold") that takes 3 address L0, L1 and
L2 to form a viewtype #stacode("list_vt_cons_unfold(L0, L1, L2)"). This
viewtype is for a list-node created by a call to #dyncode("list_vt_cons")
such that the node is located at L0 and the two arguments of
#dyncode("list_vt_cons") are located at L1 and L2 while the proofs for the
at-views associated with L1 and L2 are put in the store for currently
available proofs.

')

#para('\

The following function template #dyncode("length") computes the length of a
given linear list:

#atscode('\
fn{
a:t@ype
} length{n:nat}
  (xs: !list_vt (a, n)): int n = let
  fun loop
    {i,j:nat | i+j==n} .<i>.
    (xs: !list_vt (a, i), j: int j): int (n) =
    case+ xs of
    | list_vt_cons (_, xs1) => loop (xs1, j+1) | list_vt_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [length]
')

The interface of #dyncode("length") indicates that
#dyncode("length&lt;T&gt;") returns an integer equal to I when applied to a
list of the type #dyncode("list_vt(T, I)"), where T and I are a type and an
integer, respectively. Note that the symbol #dyncode("!") in front of the
type of a function argument indicates that the argument is call-by-value
and it is preserved after a call to the function. The function
#dyncode("loop") inside the body of #dyncode("length") is tail-recursive.
Given a linear list and an integer, #dyncode("loop") returns the sum of the
length of the list and the integer. In the body of #dyncode("loop"), if
#dyncode("xs") matches the pattern #dyncode("list_vt_cons(_, xs1)"), then
the name #dyncode("xs1") is bound to the tail of #dyncode("xs"). Note that
#dyncode("xs1") is a value (instead of a variable), and it is not allowed
that #dyncode("xs1") be modified into another value (of a different type).

')

#para('\

Suppose that we do want to modify the content stored in a list-node.
For instance, we may want to double the value of each integer stores in a
linear integer list. The following code implements a function named
#dyncode("list_vt_2x") that does precisely this:

#atscode('\
fun
list_vt_2x{n:nat}
  (xs: !list_vt (int, n) >> _): void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = x := 2 * x
      val () = list_vt_2x (xs1)
      prval () = fold@ (xs)
    in
      // nothing
    end // end of [list_vt_cons]
  | list_vt_nil () => ()
) (* end of [list_vt_2x] *)
')

Given a type T, the notation (#stacode("!T &gt;&gt; _")) is a shorthand for
(#stacode("!T &gt;&gt; T")).  Note that the special symbol #keycode("@") in
front of the pattern #dyncode("list_vt_cons(x, xs1)") means
#emphasis("unfolding"). If #dyncode("xs") matches this pattern, then
#dyncode("x") and #dyncode("xs1") are bound to the pointers pointing to
some memory locations L1 and L2 where the head and tail of #dyncode("xs")
are stored, respectively, and the type of #dyncode("xs") changes into
#stacode("list_vt_cons_unfold(L0, L1, L2)") for L0 being the location of
the list-node referred to by #dyncode("xs").  In the body of the clause
guarded by the pattern #dyncode("list_vt_cons(x, xs1)"), #dyncode("x") and
#dyncode("xs1") are treated as variables (which are a form of
left-value). The special proof function #dyncode("fold@") is called on
#dyncode("xs") to fold it plus the proofs of at-views attached to L1 and L2
into a linear list.

')

#para('\

Let us now see an example where linear list-nodes are explicitly freed:

')

#atscode('\
fun{
a:t@ype
} list_vt_free
  {n:nat} .<n>.
  (xs: list_vt (a, n)): void =
(
  case+ xs of
  | ~list_vt_cons
      (x, xs1) => list_vt_free (xs1)
  | ~list_vt_nil ((*void*)) => ()
) (* end of [list_vt_free] *)
')

#para('\

Given a linear list, the function #dyncode("list_vt_free") frees all the
nodes in the list. Let us go over the body of #dyncode("list_vt_free")
carefully.  If #dyncode("xs") matches the pattern #dyncode("list_vt_cons(x,
xs1)"), then the names #dyncode("x") and #dyncode("xs1") are bound to the
head and tail of #dyncode("xs"), respectively; the special symbol
#keycode("~") in front of the pattern indicates that the list-node referred
to by #dyncode("xs") is freed immediately after #dyncode("xs") matches the
pattern.  If #dyncode("xs") matches the pattern #dyncode("list_vt_nil()"),
no bindings are generated; the special symbol #keycode("~") in front of the
pattern indicates that the list-node referred to by #dyncode("xs") is
freed; nothing in this case is actually freed at run-time as
#dyncode("list_vt_nil") is mapped to the null pointer.

')

#para('\

It is also possible to use the special function #dyncode("free@") to
explicitly free a node (also called a skeleton) left in a linear variable
after the variable matches a pattern formed with a constructor associated
with some dataviewtype. For instance, the following code gives another
implementation of #dyncode("list_vt_free"):

')

#atscode('\
fun{
a:t@ype
} list_vt_free
  {n:nat} .<n>. (xs: list_vt (a, n)): void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val xs1_ = xs1 // [xs1_] is the value stored in [xs1]
      val ((*void*)) = free@{a}{0}(xs) in list_vt_free (xs1_)
    end // end of [list_vt_cons]
  | @list_vt_nil () => free@{a} (xs)
// end of [list_vt_free]
')

#para('\

As it can be a bit tricky to use #dyncode("free@") in practice, I present
more details as follows. First, let us note that the constructors
#dyncode("list_vt_nil") and #dyncode("list_vt_cons") associated with
#stacode("list_vt") are assigned the following types:

')

#atscode('\
list_vt_nil : // one quantifier
  {a:t@ype} () -> list_vt (a, 0)
list_vt_cons : // two quantifiers
  {a:t@ype}{n:nat} (a, list_vt (a, n)) -> list_vt (a, n+1)
')

#para('\

If #dyncode("free@") is applied to a node of the type
#dyncode("list_vt_nil()"), it needs one static argument, which is a type,
to instantiate the quantifier in the type of the constructor
#dyncode("list_vt_nil"). If #dyncode("free@") is applied to a node of the
type #stacode("list_vt_cons_unfold(L0, L1, L2)"), then it needs two static
arguments, which are a type and an integer, to instantiate the two
quantifiers in the type of the constructor #dyncode("list_vt_cons"). In the
case where the type of #dyncode("xs") is #stacode("list_vt_cons_unfold(L0,
L1, L2)"), typechecking the call #dyncode("free@{a}{0}(xs)") implicitly
consumes a proof of the at-view #stacode("a?@L1") and another proof of the
at-view #stacode("list_vt(a, 0)?@L2").  As there is no difference between
#stacode("list_vt(T, 0)?") and #stacode("list_vt(T, I)?") for any T and I,
the static argument 0 is chosen in the code. As a matter of fact, any
natural number can be used in place of 0 as the second static argument of
#dyncode("free@").

')

<sect2
id="linear-list-reversing">
#title("Linear List-Reversing")

#para('\

The following code implements a function #dyncode("reverse") that turns a
given linear list into its reverse:

#atscode('\
fn{
a:t@ype
} reverse{n:nat}
(
  xs: list_vt (a, n)
) : list_vt (a, n) = let
  fun revapp
    {i,j:nat | i+j==n} .<i>.
  (
    xs: list_vt (a, i), ys: list_vt (a, j)
  ) : list_vt (a, n) =
    case+ xs of
    | @list_vt_cons
        (_, xs1) => let
        val xs1_ = xs1
        val () = xs1 := ys
        prval () = fold@ (xs)
      in
        revapp (xs1_, xs)
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) => ys
  // end of [revapp]
in
  revapp (xs, list_vt_nil)
end // end of [reverse]
')

The type assigned to #dyncode("reverse") indicates that the function
returns a linear list of the same length as the one it consumes.  Note that
the inner function #dyncode("revapp") is tail-recursive.  This
implementation of linear list-reversing directly corresponds to the one
presented previously that is based the dataview #stacode("slseg_v") (for
singly-linked list segments). Comparing the two implementations, we can see
that the one based on dataviewtype is significantly simplified at the level
of types. For instance, there is no explicit mentioning of pointers in the
types assigned to functions #dyncode("reverse") and #dyncode("revapp").

')

</sect2>#comment("sect2/id=linear-list-reversing")

<sect2
id="linear-list-appending">
#title("Linear List-Appending")

#para('\

The following code implements a function #dyncode("append") that
concatenates two given linear lists into one:

#atscode('\
fn{
a:t@ype
} append{m,n:nat}
(
  xs: list_vt (a, m)
, ys: list_vt (a, n)
) : list_vt (a, m+n) = let
  fun loop {m,n:nat} .<m>. // [loop] is tail-recursive
  (
    xs: &list_vt (a, m) >> list_vt (a, m+n), ys: list_vt (a, n)
  ) : void =
    case+ xs of
    | @list_vt_cons
        (_, xs1) => let
        val () = loop (xs1, ys) in fold@ (xs)
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) => xs := ys
  // end of [loop]
  var xs: List_vt (a) = xs // creating a left-value for [xs]
  val () = loop (xs, ys)
in
  xs
end // end of [append]
')

As the call #dyncode("fold@(xs)") in the body of the function
#dyncode("loop") is erased after typechecking, #dyncode("loop") is a
tail-recursive function.  Therefore, #dyncode("append") can be called on
lists of any length without the concern of possible stack overflow. The
type for the first argument of #dyncode("loop") begins with the symbol
#dyncode("&amp;"), which indicates that this argument is
call-by-reference. The type of #dyncode("loop") simply means that its first
argument is changed from a list of length #stacode("m") into a list of
length #stacode("m+n") while its second argument is consumed.

')

#para('\

This implementation of list append essentially corresponds to the
one presented previously that is based on the dataview #dyncode("slseg_v").
Comparing these two, we can easily see that the above one is much simpler
and cleaner, demonstrating concretely some advantage of dataviewtypes over
dataviews.

')

#para('\

This is also a good place for me to mention a closely related issue
involving (functional) list construction and tail-recursion. Following is a
typical implementation of functioal list concatenation:

#atscode('\
fun{
a:t@ype
} append1{m,n:nat}
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) =
  case+ xs of
  | list_cons (x, xs) => list_cons (x, append1 (xs, ys))
  | list_nil () => ys
// end of [append1]
')

Clearly, #dyncode("append1") is not tail-recursive, which means that it may
cause stack overflow at run-time if its first argument is very long (e.g.,
containing 1 million elements). There is, however, a direct and type-safe
way in ATS to implement functional list concatenation in a tail-recursive
manner, thus eliminating the concern of potential stack overflow. For
instance, the following implementation of #dyncode("append2") returns the
concatenation of two given functional lists while being tail-recursive:

#atscode('\
fun{
a:t@ype
} append2{m,n:nat}
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = let
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list (a, n)
, res: &(List a)? >> list (a, m+n)
) : void =
(
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = 
      res := list_cons{a}{0}(x, _)
      val+ list_cons (_, res1) = res
      val () = loop (xs, ys, res1)
      prval ((*void*)) = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := ys)
) (* end of [loop] *)
//
var res: List(a)
val () = loop (xs, ys, res)
//
in
  res
end // end of [append2]
')

During typechecking, the expression #dyncode("list_cons{a}{0}(x, _)") is
assigned the (linear) type #stacode("list_cons(L0, L1, L2)") for some
addresses L0, L1 and L2 while a proof of the at-view #stacode("a@L1") and
another proof of the at-view #stacode("list(a, 0)?@L2") are put into the
store for currently available proofs. Note that the special symbol
#keycode("_") simply indicates that the tail of the newly constructed list
is uninitialized. A partially initialized list of the type
#stacode("list_cons(L0, L1, L2)") is guaranteed to match the pattern
#dyncode("list_cons(_, res1)"), yielding a binding between #dyncode("res1")
and the pointer pointing to L2 where the (possibly uninitialized) tail of
the list is stored. When #dyncode("fold@") is called on a variable of the
type #stacode("list_cons(L0, L1, L2)"), it changes the type of the variable
to #stacode("list(T, N+1)") by consuming a proof of the at-view
#stacode("T@L1") and another proof of the at-view #stacode("list(T,
N)@L2"), where T and N are a type and an integer, respectively.

')

</sect2>#comment("sect2/id=linear-list-appending")

<sect2
id="linear-list-summary">
#title("Summary")

#para('\

With dataviewtypes, we can largely retain the convenience of pattern
matching associated with datatypes while supporting explicit memory
management.  Compared to dataviews, dataviewtypes are less
general. However, if a dataviewtype can be employed to solve a problem,
then the solution is often significantly simpler and cleaner than an
alternative dataview-based one.

')

</sect2>#comment("sect2/id=linear-list-summary")

</sect1>#comment("sect1/id=linear_lists")

<!-- ****** ****** -->

<sect1
id="example_mergeSort_lin">
#title("Example: Merge-Sort on Linear Lists")

#para("\

When merge-sort is employed to sort an array of elements, it requires
additional memory proportionate to the size of the array in order to move
the elements around, which is considered a significant weakness of
merge-sort. However, merge-sort does not have this requirement when it
operates on a linear list.  I present as follows an implementation of
merge-sort on linear lists that can readily rival its counterpart in C in
terms of both time-efficiency and memory-efficiency. The invariants
captured in this implementation and the easiness to capture them should
provide strong evidence that attests to ATS being a programming language
capable of enforcing great precision in practical programming.

")

#para('\

Let us first introduce a type definition and an interface for a function
template that compares elements in lists to be sorted:

#atscode('\
//
typedef cmp (a:t@ype) = (&a, &a) -> int
//
fun{a:t@ype} compare (x: &a, y: &a, cmp: cmp (a)): int
//
')

The interface for merge-sort is given as follows:

#atscode('\
fun{
a:t@ype
} mergeSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
// end of [mergeSort]
')

The first argument of #dyncode("mergeSort") is a linear list (to be sorted)
and the second one a function for comparing the elements in the linear
list.  Clearly, the interface of #dyncode("mergeSort") indicates that
#dyncode("mergeSort") consumes its first argument and then returns a linear
list that is of the same length as its first argument. As is to become clear,
the returned linear list is constructed with the nodes of the consumed
one. In particular, the implementation of #dyncode("mergeSort") given as
follows does not involve any memory allocation or deallocation.

')

#para('\

The function template for merging two sorted lists into one is given as follows:

#atscode('\
fun{
a:t@ype
} merge{m,n:nat} .<m+n>.
(
  xs: list_vt (a, m), ys: list_vt (a, n)
, res: &List_vt(a)? >> list_vt (a, m+n)
, cmp: cmp a
) : void =
  case+ xs of
  | @list_vt_cons (x, xs1) => (
    case+ ys of
    | @list_vt_cons (y, ys1) => let
        val sgn = compare<a> (x, y, cmp)
      in
        if sgn <= 0 then let // stable sorting
          val () = res := xs
          val xs1_ = xs1
          prval () = fold@ (ys)
          val () = merge<a> (xs1_, ys, xs1, cmp)
        in
          fold@ (res)
        end else let
          val () = res := ys
          val ys1_ = ys1
          prval () = fold@ (xs)
          val () = merge<a> (xs, ys1_, ys1, cmp)
        in
          fold@ (res)
        end // end of [if]
      end (* end of [list_vt_cons] *)
    | ~list_vt_nil () => (fold@ (xs); res := xs)
    ) // end of [list_vt_cons]
  | ~list_vt_nil () => (res := ys)
// end of [merge]
')

Unlike the one given in a previous functional implementation, this
implementation of #dyncode("merge") is tail-recursive and thus is guaranteed
to be translated into a loop in C by the ATS compiler. This means that the
concern of #dyncode("merge") being unable to handle very long lists (e.g.,
containing 1 million elements) due to potential stack overflow is
eliminated.

')

#para('\

The next function template is for splitting a given linear lists into two:

#atscode('\
fun{
a:t@ype
} split{n,k:nat | k <= n} .<n-k>.
(
  xs: &list_vt (a, n) >> list_vt (a, n-k), nk: int (n-k)
) : list_vt (a, k) =
  if nk > 0 then let
    val+@list_vt_cons(_, xs1) = xs
    val res = split<a> (xs1, nk-1); prval () = fold@(xs)
  in
    res
  end else let
    val res = xs; val () = xs := list_vt_nil () in res
  end // end of [if]
// end of [split]
')

Note that the implementation of #dyncode("split") is also tail-recursive.

')

#para('\

The following function template #dyncode("msort") takes a linear list, its
length and a comparsion function, and it returns a sorted version of the
given linear list:

#atscode('\
fun{
a:t@ype
} msort{n:nat} .<n>.
(
  xs: list_vt (a, n), n: int n, cmp: cmp(a)
) : list_vt (a, n) =
  if n >= 2 then let
    val n2 = half(n)
    val n3 = n - n2
    var xs = xs // lvalue for [xs]
    val ys = split<a> (xs(*cbr*), n3)
    val xs = msort<a> (xs, n3, cmp)
    val ys = msort<a> (ys, n2, cmp)
    var res: List_vt (a) // uninitialized
    val () = merge<a> (xs, ys, res(*cbr*), cmp)
  in
    res
  end else xs
// end of [msort]
')

The second argument of #dyncode("msort") is passed so that the length of
the list being sorted does not have to be computed directly by traversing
the list when each recursive call to #dyncode("msort") is made.

')

#para('\

Finally, #dyncode("mergeSort") can be implemented with a call to
#dyncode("msort"):

#atscode('\
implement{a}
mergeSort (xs, cmp) = msort<a> (xs, length (xs), cmp)
')

By inspecting the implementation of #dyncode("split") and
#dyncode("merge"), we can readiy see that #dyncode("mergeSort") performs
stable sorting, that is, it preserves the order of equal elements during
sorting.

')

#para('\

Please find #mycodelink("CHAP_DATAVTYPE/mergeSort.dats", "on-line") the
entirety of the code presented in this section plus some additional code
for testing.

')

</sect1>#comment("sect1/id=example_mergeSort_lin")

<!-- ****** ****** -->

<sect1
id="example_insertionSort_lin">
#title("Example: Insertion Sort on Linear Lists")

#para('\

I present a standard implementation of insertion sort on linear lists in
this section.  The interface for insertion sort is given as follows:

#atscode('\
fun{
a:t@ype
} insertionSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
// end of [insertionSort]
')

Like #dyncode("mergeSort"), #dyncode("insertionSort") is implemented in a
manner that makes no use of memory allocation or deallocation.  Given a
linear list, #dyncode("insertionSort") essentially shuffles the nodes in
the list to form a sorted list.

')

#para('\

The following code implements a function #dyncode("insord") that inserts a
given list-node into a sorted linear list to form another sorted linear list:

#atscode('\
fun{
a:t@ype
} insord
  {l0,l1,l2:addr}{n:nat}
(
  pf1: a @ l1
, pf2: list_vt (a, 0)? @ l2
| xs0: &list_vt (a, n) >> list_vt (a, n+1)
, nx0: list_vt_cons_unfold (l0, l1, l2), p1: ptr (l1), p2: ptr (l2)
, cmp: cmp (a)
) : void =
(
  case+ xs0 of
  | @list_vt_cons
      (x0, xs1) => let
      val sgn = compare<a> (x0, !p1, cmp)
    in
      if sgn <= 0 // HX: for stableness: [<=] instead of [<]
        then let
          val () = insord<a> (pf1, pf2 | xs1, nx0, p1, p2, cmp)
          prval () = fold@ (xs0)
        in
          // nothing
        end // end of [then]
        else let
          prval () = fold@ (xs0)
          val () = (!p2 := xs0; xs0 := nx0)
          prval () = fold@ (xs0)
        in
          // nothing
        end // end of [else]
      // end of [if]
    end // end of [list_vt_cons]
  | ~list_vt_nil () =>
    {
      val () = xs0 := nx0
      val () = !p2 := list_vt_nil ()
      prval () = fold@ (xs0)
    }
) (* end of [insord] *)
')

The implementation of #dyncode("insord") is tail-recursive.  The type
assigned to #dyncode("insord") indicates that the argument xs0 of
#dyncode("insord") is call-by-reference. If xs0 stores a list of length n
when #dyncode("insord") is called, then it stores a list of length n+1 when
#dyncode("insord") returns. The arguments nx0, p1 and p2 are call-by-value,
and they should be bound to a list-node and the first and second fields in
the list-node, respectively, when a call to #dyncode("insord")
initiates. The proof arguments pf1 and pf2 are needed so that the pointers
bound to p1 and p2 can be accessed and updated.

')

#para('\

The function template #dyncode("insertionSort") can now be readily
implemented based #dyncode("insord"):

#atscode('\
implement{a}
insertionSort
  (xs, cmp) = let
//
fun loop{m,n:nat}
(
  xs: list_vt (a, m)
, ys: &list_vt (a, n) >> list_vt (a, m+n)
, cmp: cmp (a)
) : void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val xs1_ = xs1
      val ((*void*)) =
        insord<a> (view@x, view@xs1 | ys, xs, addr@x, addr@xs1, cmp)
      // end of [va]
    in
      loop (xs1_, ys, cmp)
    end // end of [list_vt_cons]
  | ~list_vt_nil ((*void*)) => ()
//
var ys = list_vt_nil{a}()
val () = loop (xs, ys, cmp)
//
in
  ys
end // end of [insertionSort]
')

Clearly, this implementation of #dyncode("insertionSort") is
tail-recursive.  While insertion sort is of O(n^2)-time complexity, it is
often more efficient than merge-sort or quick-sort when sorting very short
lists.  For instance, we may implement #dyncode("msort") (which is called
by #dyncode("mergeSort")) as follows by taking advantage of the efficiency
of #dyncode("insertionSort") on short lists:

#atscode('\
fun{
a:t@ype
} msort{n:nat} .<n>.
(
  xs: list_vt (a, n)
, n: int n, cmp: cmp(a)
) : list_vt (a, n) = let
//
// cutoff is selected to be 10
//
in
  if n > 10 then let
    val n2 = half(n)
    val n3 = n - n2
    var xs = xs // lvalue for [xs]
    val ys = split<a> (xs, n3)
    val xs = msort<a> (xs, n3, cmp)
    val ys = msort<a> (ys, n2, cmp)
    var res: List_vt (a) // uninitialized
    val () = merge<a> (xs, ys, res(*cbr*), cmp)
  in
    res
  end else insertionSort<a> (xs, cmp)
end // end of [msort]
')

Note that the stableness of #dyncode("mergeSort") is maintained as
#dyncode("insertionSort") also performs stable sorting.

')

#para('\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/insertionSort.dats", "on-line").

')

</sect1>#comment("sect1/id=example_insertionSort_lin")

<!-- ****** ****** -->

<sect1
id="example_quickSort_lin">
#title("Example: Quick-Sort on Linear Lists")

#para('\

In this section, I give an implementation of quick-sort on linear
lists. While list-based quick-sort may not be a preferred sorting method in
practice, its implementation is nonetheless interesting.
The interface for quick-sort is given as follows:

#atscode('\
fun{a:t@ype}
quickSort{n:nat} (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
')

Like the implementation of #dyncode("mergeSort") and
#dyncode("insertionSort"), the implementation of #dyncode("quickSort")
given as follows makes no use of memory allocation and deallocation.

')

#para('\

The following code implements a function #dyncode("takeout_node_at") that
takes out a node from a linear list at a given position:

#atscode('\
fun{a:t@ype}
takeout_node_at
  {n:int}{k:nat | k < n}
(
  xs: &list_vt (a, n) >> list_vt (a, n-1), k: int(k)
) : list_vt_cons_pstruct (a, ptr?) =
(
//
if k > 0 then let
  val+@list_vt_cons (x, xs1) = xs
  val res = takeout_node_at<a> (xs1, k-1)
  prval () = fold@ (xs)
in
  res
end else let
  val+@list_vt_cons (x, xs1) = xs
  val nx = xs
  val () = xs := xs1
in
  $UNSAFE.castvwtp0 ((view@x, view@xs1 | nx)) // HX: this is a safe cast
end // end of [if]
//
) (* end of [takeout_node_at] *)
')

Assume that a data constructor named #emphasis("foo") is associated with a
dataviewtype.  Then there is a corresponding viewtype construtor of the
name #emphasis("foo_pstruct") that takes n types to form a viewtype, where
n is the arity of #emphasis("foo"). For instance, there is a viewtype
constructor #stacode("list_vt_cons_pstruct") that takes 2 types T1 and T2
to form a viewtype #stacode("list_vt_cons_pstruct(T1, T2)"). This viewtype
is for a list-node created by a call to #dyncode("list_vt_cons") such that
the two arguments of #dyncode("list_vt_cons") are of types T1 and T2.
Essentially, #stacode("list_vt_cons_pstruct(T1, T2)") stands for
#stacode("list_vt_cons_unfold(L0, L1, L2)") for some addresses L0, L1 and
L2 plus two views #stacode("T1@L1") and #stacode("T2@L2").

')

#para('\

A key step in quick-sort lies in partitioning a linear list based on a
given pivot. This step is fulfilled by the following code that implements a
function template named #dyncode("partition"):

#atscode('\
fun{
a:t@ype
} partition{n,r1,r2:nat}
(
  xs: list_vt (a, n), pvt: &a
, r1: int(r1), res1: list_vt (a, r1), res2: list_vt (a, r2)
, cmp: cmp (a)
) : [n1,n2:nat | n1+n2==n+r1+r2]
  (int(n1), list_vt (a, n1), list_vt (a, n2)) =
(
  case+ xs of
  | @list_vt_cons
      (x, xs_tail) => let
      val xs_tail_ = xs_tail
      val sgn = compare<a> (x, pvt, cmp)
    in
      if sgn <= 0 then let
        val r1 = r1 + 1
        val () = xs_tail := res1
        prval () = fold@ (xs)
      in
        partition<a> (xs_tail_, pvt, r1, xs, res2, cmp)
      end else let
        val () = xs_tail := res2
        prval () = fold@ (xs)
      in
        partition<a> (xs_tail_, pvt, r1, res1, xs, cmp)
      end // end of [if]
    end (* end of [list_vt_cons] *)
  | ~list_vt_nil ((*void*)) => (r1, res1, res2)
) (* end of [partition] *)
')

The implementation of #dyncode("partition") is tail-recursive.  Given a
linear list and a pivot, #dyncode("partition") returns a tuple (r1, res1,
res2) such that res1 contains every element in the list that is less than
or equal to the pivot, res2 contains the rest, and r1 is the length of
res1. The way in which the nodes of the given linear list are moved into
res1 and res2 is quite an interesting aspect of this implementation.

')

#para('\

By making use of #dyncode("takeout_node_at") and #dyncode("partition"),
we can readily implement #dyncode("quickSort") as follows:

#atscode('\
implement
{a}(*tmp*)
quickSort
  (xs, cmp) = let
//
fun sort{n:nat}
(
  xs: list_vt (a, n), n: int n
) : list_vt (a, n) =
(
  if n > 10 then let
    val n2 = half (n)
    var xs = xs
    val nx = takeout_node_at<a> (xs, n2)
    val+list_vt_cons (pvt, nx_next) = nx
    val (n1, xs1, xs2) =
    partition<a> (xs, pvt, 0, list_vt_nil, list_vt_nil, cmp)
    val xs1 = sort (xs1, n1)
    val xs2 = sort (xs2, n - 1 - n1)
    val () = nx_next := xs2
    prval () = fold@ (nx)
  in
    list_vt_append (xs1, nx)
  end else insertionSort<a> (xs, cmp)
) (* end of [sort] *)
//
in
  sort (xs, list_vt_length (xs))
end // end of [quickSort]
')

Note that the pivot for each round is taken from the middle of the list
being sorted, which can be time-consuming as taking out a node from the
middle of a list is O(n)-time. This issue can be addressed by always
choosing the first element to be the pivot. However, doing so can
often lead to degenerated O(n^2)-time performance of quick-sort in practice.

')

#para('\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/quickSort.dats", "on-line").

')

</sect1>#comment("sect1/id=example_quickSort_lin")

<!-- ****** ****** -->

<sect1
id="linear_binary_search_trees">
#title("Linear Binary Search Trees")

#para("\

A binary search tree with respect to a given ordering is a binary tree such
that the value stored in each node inside the tree is greater than or equal
to those stored in the left child of the node and less than or equal to
those stored in the right child of the node.  Binary search trees are a
common data structure for implementing finite maps.

")

#para("\

A family of binary
trees are said to be balanced if there is a fixed constant C (for the
entire family) such that the ratio between the length of a longest path and
the length of a shortest path is bounded by C for every tree in the
family. For instance, common examples of balanced binary trees include AVL
trees and red-black trees. Finite maps based on balanced binary search
trees support guaranteed log-time insertion and deletion operations, that
is, the time to complete such an operation is O(log(n)) in the worst case,
where n is the size of the map.

")

#para('\

In this section, I am to implement several basic operations on linear
binary search trees, further illustrating some use of dataviewtypes. Let us
first declare as follows a dataviewtype #stacode("bstree_vt") for linear
binary (search) trees:

#atscode('\
datavtype
bstree_vt (a:t@ype+, int) =
  | bstree_vt_nil (a, 0) of ()
  | {n1,n2:nat}
    bstree_vt_cons (a, n1+n2+1) of (bstree_vt (a, n1), a, bstree_vt (a, n2))
// end of [bstree_vt]
')

')

#para('\

Note that the integer index of #stacode("bstree_vt") captures the size
information of a binary (search) tree.  There are two constructors
#dyncode("bstree_vt_cons") and #dyncode("bstree_vt_nil") associated with
#stacode("bstree_vt"). It should be pointed out that the tree created by
#dyncode("bstree_vt_nil") is empty and thus not a leaf, which on the other
hand is a node whose left and right children are both empty.  As a simple
example, the following function template #dyncode("size") computes the size
of a given tree:

#atscode('\
fun{
a:t@ype
} size{n:nat} .<n>.
(
  t: !bstree_vt (a, n)
) : int (n) =
  case+ t of
  | bstree_vt_nil () => 0
  | bstree_vt_cons
     (tl, _, tr) => 1 + size (tl) + size (tr)
// end of [size]
')

')

#para('\

Assume that we have a binary search tree with repect to some ordering.  If
a predicate P on the elements stored in the tree possesses the property
that P(x1) implies P(x2) whenever x1 is less than x2 (according to the
ordering), then we can locate the least element in the tree that satisfies
the predicate P by employing so-called binary search as is demonstrated in
the following implementation of #dyncode("search"):

#atscode('\
fun{
a:t@ype
} search
  {n:nat} .<n>.
(
  t: !bstree_vt (a, n), P: (&a) -<cloref> bool
) : Option_vt (a) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =>
      if P (x) then let
        val res = search (tl, P)
        val res = (
          case+ res of
          | ~None_vt () => Some_vt (x) | _ => res
        ) : Option_vt (a)
      in
        fold@ (t); res
      end else let
        val res = search (tr, P) in fold@ (t); res
      end // end of [if]
  | @bstree_vt_nil () => (fold@ (t); None_vt ())
// end of [search]
')

Clearly, if the argument #dyncode("t") of #dyncode("search") ranges over a
family of balanced trees, then the time-complexity of #dyncode("search") is
O(log(n)) (assuming that #dyncode("P") is O(1)).

')

#para('\

Let us next see some code implementing an operation that inserts a given
element into a binary search tree:

#atscode('\
fun{
a:t@ype
} insert{n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val () = tl := insert (tl, x0, cmp)
      in
        fold@ (t); t
      end else let
        val () = tr := insert (tr, x0, cmp)
      in
        fold@ (t); t
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insert]
')

')

#para('\

When inserting an element, the function template #dyncode("insert") extends
the given tree with a new leaf node containing the element, and this form
of insertion is often referred to as leaf-insertion.  There is another form
of insertion often referred to as root-insertion, which always puts at the
root position the new node containing the inserted element. The following
function template #dyncode("insertRT") is implemented to perform a standard
root-insertion operation:

#atscode('\
fun{
a:t@ype
} insertRT{n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val tl_ = insertRT (tl, x0, cmp)
        val+@bstree_vt_cons (_, tll, tlr) = tl_
        val () = tl := tlr
        prval () = fold@ (t)
        val () = tlr := t
      in
        fold@ (tl_); tl_
      end else let
        val tr_ = insertRT (tr, x0, cmp)
        val+@bstree_vt_cons (trl, _, trr) = tr_
        val () = tr := trl
        prval () = fold@ (t)
        val () = trl := t
      in
        fold@ (tr_); tr_
      end
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
')

The code immediately following the first recursive call to
#dyncode("insertRT") performs a right tree rotation. Let us use T(tl, x,
tr) for a tree such that its root node contains the element x and its left
and right children are tl and tr, respectively. Then a right rotation turns
T(T(tll, xl, tlr), x, tr) into T(tll, xl, T(tlr, x, tr)).  The code
immediately following the second recursive call to #dyncode("insertRT")
performs a left tree rotation, which turns T(tl, x, T(trl, xr, trr)) into
T(T(tl, x, tlr), xr, trr).

')

#para('\

To further illustrate tree rotations, I present as follows
two function templates #dyncode("lrotate") and #dyncode("rrotate"), which
implement the left and right tree rotations, respectively:

#atscode('\
fn{
a:t@ype
} lrotate
  {l,l_tl,l_x,l_tr:addr} 
  {nl,nr:int | nl >= 0; nr > 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tr = !p_tr
  val+@bstree_vt_cons (trl, _, trr) = tr
  val () = !p_tr := trl
  prval () = fold@ (t); val () = trl := t
in
  fold@ (tr); tr
end // end of [lrotate]

fn{
a:t@ype
} rrotate
  {l,l_tl,l_x,l_tr:addr}
  {nl,nr:int | nl > 0; nr >= 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tl = !p_tl
  val+@bstree_vt_cons (tll, x, tlr) = tl
  val () = !p_tl := tlr
  prval () = fold@ (t); val () = tlr := t
in
  fold@ (tl); tl
end // end of [rrotate]
')

Given 4 addresses L0, L1, L2 and L3, the type
#stacode("bstree_vt_cons_unfold(L0, L1, L2, l3)") is for a tree node
created by a call to #dyncode("bstree_vt_cons") such that the node is
located at L0 and the three arguments of #dyncode("bstree_vt_cons") are
located at L1, L2 and L3, and the proofs for the at-views associated with
L1, L2 and L3 are put in the store for currently available proofs.

')

#para('\

The function template #dyncode("insertRT") for root-insertion can now be
implemented as follows by making direct use of #dyncode("lrotate") and
#dyncode("rrotate"):

#atscode('\
fun{
a:t@ype
} insertRT {n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      prval pf_x = view@x
      prval pf_tl = view@tl
      prval pf_tr = view@tr
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val () = tl := insertRT<a> (tl, x0, cmp)
      in
        rrotate<a> (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end else let
        val () = tr := insertRT<a> (tr, x0, cmp)
      in
        lrotate<a> (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
')

')

#para('\

I would like to point out that neither #dyncode("insert") nor
#dyncode("insertRT") is tail-recursive. While it is straightforward to give
the former a tail-recursive implementation, there is no direct way to do
the same to the latter. In order to implement root-insertion in a
tail-recursive manner, we are in need of binary search trees with parental
pointers (so as to allow each node to gain direct access to its parent),
which can be done with dataviews but not with dataviewtypes.

')

#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/bstree_vt.dats", "on-line").

")

</sect1>#comment("sect1/id=linear_binary_search_trees")

<!-- ****** ****** -->

<sect1
id="transition_from_datatypes_to_dataviewtypes">
#title("Transition from Datatypes to Dataviewtypes")

#para('\

Many programmers are likely to find it a rather involved task to write code
manipulating values of dataviewtypes. When handling a complex data
structure, I myself often try to first use a datatype to model the data
structure and implement some functionalities of the data structure based
the datatype. I then change the datatype into a corresponding dataviewtype
and modify the implementation accordingly to make it work with the
dataviewtype. I now present as follows an implementation of linear
red-black trees that is directly based on a previous
<xref linkend="example_fun_red-black_trees"/>,
illustrating concretely a kind of gradual transition from datatypes to
dataviewtypes that can greatly reduce the level of difficulty one may
otherwise encounter in an attempt to program with dataviewtypes directly.

')

#para('\

The following declaration of dataviewtype #stacode("rbtree") is identical
to the previous declaration of datatype #stacode("rbtree") except the
keyword #keycode("datavtype") being now used instead of the keyword
#keycode("datatype"):

#atscode('\
\#define BLK 0; \#define RED 1
sortdef clr = {c:int | 0 <= c; c <= 1}

datavtype rbtree
(
  a: t@ype+, int(*c*), int(*bh*), int(*v*)
) = // element type, color, black height, violations
  | rbtree_nil (a, BLK, 0, 0) of ((*void*))
  | {c,cl,cr:clr}{bh:nat}{v:int}
    {c==BLK && v==0 || c == RED && v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of (int c, rbtree0 (a, cl, bh), a, rbtree0 (a, cr, bh))
// end of [rbtree]

where rbtree0 (a:t@ype, c:int, bh:int) = rbtree (a, c, bh, 0)
')

')

#para('\

At the first sight, the following function template #dyncode("insfix_l") is
greatly more involved that a previous version of the same name (for
manipulating functional red-black trees):

#atscode('\
fn{
a:t@ype
} insfix_l // right rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr}
(
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, v) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, 0) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tl: ptr (l_tl)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK
  \#define R RED
  \#define nil rbtree_nil
  \#define cons rbtree_cons
in
  case+ !p_tl of
  | @cons (cl as R, tll as @cons (cll as R, _, _, _), _, tlr) => let
//
      val () = cll := B
      prval () = fold@ (tll)
//
      val tl = !p_tl
      val () = !p_tl := tlr
      prval () = fold@ (t)
      val () = tlr := t
//
    in
      fold@ (tl); tl
    end // end of [cons (R, cons (R, ...), ...)]
  | @cons (cl as R, tll, _, tlr as @cons (clr as R, tlrl, _, tlrr)) => let
//
      val tl = !p_tl
      val () = !p_tl := tlrr
      prval () = fold@ (t)
      val () = tlrr := t
//
      val tlr_ = tlr
      val () = tlr := tlrl
      val () = cl := B
      prval () = fold@ (tl)
      val () = tlrl := tl
//
    in
      fold@ (tlr_); tlr_
    end // end of [cons (R, ..., cons (R, ...))]
  | _ (*rest-of-cases*) =>> (fold@ (t); t)
end // end of [insfix_l]
')

However, I would like to point out that the interface for the above
#dyncode("insfix_l") is a #emphasis("direct") translation of the interface for
the previous #dyncode("infix_l"). In other words, the previously captured
relation between a tree being rotated and the one obtained from applying
#dyncode("infix_l") to it also holds in the setting of linear red-black trees.
The very same statement can be made about the following function template
#dyncode("insfix_r"), which is precisely a mirror image of #dyncode("insfix_l"):

#atscode('\
fn{
a:t@ype
} insfix_r // left rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr} (
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, 0) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, v) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tr: ptr (l_tr)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK
  \#define R RED
  \#define nil rbtree_nil
  \#define cons rbtree_cons
in
  case+ !p_tr of
  | @cons (cr as R, trl, _, trr as @cons (crr as R, _, _, _)) => let
//
      val () = crr := B
      prval () = fold@ (trr)
//
      val tr = !p_tr
      val () = !p_tr := trl
      prval () = fold@ (t)
      val () = trl := t
//
    in
      fold@ (tr); tr
    end // end of [cons (R, ..., cons (R, ...))]
  | @cons (cr as R, trl as @cons (crr as R, trll, _, trlr), _, trr) => let
//
      val tr = !p_tr
      val () = !p_tr := trll
      prval () = fold@ (t)
      val () = trll := t
//
      val trl_ = trl
      val () = trl := trlr
      val () = cr := B
      prval () = fold@ (tr)
      val () = trlr := tr
//
    in
      fold@ (trl_); trl_
    end // end of [cons (R, cons (R, ...), ...)]
  | _ (*rest-of-cases*) =>> (fold@ (t); t)
end // end of [insfix_r]
')

')

#para('\

As can be expected, the following function template
#dyncode("rbtree_insert") is essentially a direct translation of the one of
the same name for inserting an element into a functional red-black tree:

#atscode('\
extern
fun{a:t@ype}
rbtree_insert
  {c:clr}{bh:nat}
(
  t: rbtree0 (a, c, bh), x0: &a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)

implement{a}
rbtree_insert
  (t, x0, cmp) = let
//
\#define B BLK
\#define R RED
\#define nil rbtree_nil
\#define cons rbtree_cons
//
fun ins
  {c:clr}{bh:nat} .<bh,c>.
(
  t: rbtree0 (a, c, bh), x0: &a
) : [cl:clr; v:nat | v <= c] rbtree (a, cl, bh, v) =
(
  case+ t of
  | @cons (
      c, tl, x, tr
    ) => let
      prval pf_c = view@c
      prval pf_tl = view@tl
      prval pf_x = view@x
      prval pf_tr = view@tr
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn < 0 then let
        val [cl:int,v:int] tl_ = ins (tl, x0)
        val () = tl := tl_
      in
        if (c = B)
        then (
          insfix_l<a>
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tl)
          // end of [insfix_l]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cl}(t); t
        end // end of [if]
      end else if sgn > 0 then let
        val [cr:int,v:int] tr_ = ins (tr, x0)
        val () = tr := tr_
      in
        if (c = B)
        then (
          insfix_r<a>
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tr)
          // end of [insfix_r]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cr}(t); t
        end // end of [if]
      end else (fold@{a}{..}{..}{0} (t); t)
    end // end of [cons]
  | ~nil () => cons{a}{..}{..}{0}(R, nil, x0, nil)
) (* end of [ins] *)
//
val t = ins (t, x0)
//
in
//
case+ t of @cons(c as R, _, _, _) => (c := B; fold@ (t); t) | _ =>> t
//
end // end of [rbtree_insert]
')

')

#para('\

I literally implemented the above #dyncode("rbtree_insert") by making a
copy of the previous implementation of #dyncode("rbtree_insert") for
functional red-black trees and then properly modifying it to make it pass
typechecking. Although this process of copying-and-modifying is difficult
to be described formally, it is fairly straightforward to follow in
practice as it is almost entirely guided by the error messages received
during typechecking.

')

#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/rbtree.dats", "on-line").
A challenging as well as rewarding exercise is for the reader to implement
an operation that deletes an element from a given linear red-black tree.

")

</sect1>#comment("sect1/id=transition_from_datatypes_to_dataviewtypes")

<!-- ****** ****** -->

</chapter><!--id="dataviewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
