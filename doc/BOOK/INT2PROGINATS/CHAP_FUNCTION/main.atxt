%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="functions">
#title("Functions")

#para("\

Functions play a foundational role in programming.  While it may be
theoretically possible to program without functions (but with loops), such
a programming style is of little practical value. ATS does provide some
language constructs for implementing for-loops and while-loops directly. I,
however, strongly recommend that the programmer implement loops as
recursive functions or more precisely, as tail-recursive functions. This is
a programming style that matches well with more advanced programming
features in ATS, which will be presented in this book later.\

")

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_FUNCTION/", "on-line").
")

<sect1
id="functions-as-a-simple-form-of-abstraction">
#title("Functions as a Simple Form of Abstraction")

#para("Given an expression exp of the type #dyncode("double"), we can
multiply exp by itself to compute its square. If exp is a complex
expression, we may introduce a binding between a name and exp so that exp
is only evaluated once. This idea is shown in the following example:

#atscode("\
let val x = 3.14 * (10.0 - 1.0 / 1.4142) in x * x end
")

Now suppose that we have found a more efficient way to do squaring. In
order to take full advantage of it, we need to modify each occurrence of
squaring in the current program accordingly. This style of programming is
clearly not modular, and it is of little chance to scale. To address this
problem, we can implement a function as follows to compute the square of a
given floating point number:

#atscode("\
fn square (x: double): double = x * x
")

The keyword #dyncode("fn") initiates the definition of a non-recursive
function, and the name following it is for the function to be defined.  In
the above example, the function #dyncode("square") takes one argument of
the name #dyncode("x"), which is assumed to have the type
#dyncode("double"), and returns a value of the type
#dyncode("double"). The expression on the right-hand side (RHS) of the
symbol #dyncode("=") is the body of the function, which is #dyncode("x *
x") in this case. If we have a more efficient way to do squaring, we
can just re-implement the body of the function #dyncode("square")
accordingly to take advantage of it, and there is no other changes needed
(assuming that squaring is solely done by calling #dyncode("square")).
")#comment("para")

#para("\

If #dyncode("square") is a name, what is the expression it refers to? It
turns out that the above function definition can also be written as
follows:

#atscode("\
val square = lam (x: double): double => x * x
")

where the RHS of the symbol #dyncode("=") is a lambda-expression
representing an anonymous function that takes one argument of the type
#dyncode("double") and returns a value of the type #dyncode("double"),
and the expression following the symbol #dyncode("=>") is the body of the
function. If we wish, we can change the name of the function argument as
follows:

#atscode("\
val square = lam (y: double): double => y * y
")

This is called alpha-renaming (of function arguments), and the new
lambda-expression is said to be alpha-equivalent to the original one.\

")#comment("para")

#para("\

A lambda-expression is a (function) value. Suppose we have a
lambda-expression representing a binary function, that is, a function
taking two arguments. In order to assign a type of the form (T1, T2) -> T
to the lambda-expression, we need to verify that the body of the function
can be given the type T if the two arguments of the function are assumed to
have the types T1 and T2.  What is stated also applies, <emphasis>mutatis
mutandis</emphasis>, to lambda-expressions representing functions of fewer
or more arguments. For instance, the lambda-expression #dyncode("lam (x:
double): double => x * x") can be assigned the function type
#dyncode("(double) -> double"), which may also be written as
#dyncode("double -> double").\

")#comment("para")

#para("\

Assume that exp is an expression of some function type (T1, T2) -> T. Note
that exp is not necessarily a name or a lambda-expression. If expressions
exp<subscript>1</subscript> and exp<subscript>2</subscript> can be assigned
the types T1 and T2, then the function application
exp(exp<subscript>1</subscript>, exp<subscript>2</subscript>), which may
also be referred to as a function call, can be assigned the type T.  Typing
a function application of fewer or more arguments is handled similarly.\

")#comment("para")

#para("Let us now see an example that builds on the previously defined
function #dyncode("square"). The boundary of a ring consists of two
circles centered at the same point. If the radii of the outer and inner
circles are R and r, respectively, then the area of the ring can be
computed by the following function #dyncode("area_of_ring"):

#atscode("\
fn area_of_ring
  (R: double, r: double): double = 3.1416 * (square(R) - square(r))
// end of [area_of_ring]
")

Given that the subtraction and multiplication functions (on floating point
numbers) are of the type #dyncode("(double, double) -> double") and
#dyncode("square") is of the type #dyncode("(double) -> double"), it is a
simple routine to verify that the body of #dyncode("area_of_ring") can be
assigned the type #dyncode("double").\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="function-arity">
#title("Function Arity")

#para("\

The arity of a function is the number of arguments the function
takes.  Functions of arity 0, 1, 2 and 3 are often called nullary, unary,
binary and ternary functions, respectively. For example, the following
function #dyncode("sqrsum1") is a binary function such that its two
arguments are of the type #dyncode("int"):

#atscode("\
fn sqrsum1 (x: int, y: int): int = x * x + y * y
")

We can define a unary function #dyncode("sqrsum2") as follows:
#atscode("\
typedef int2 = (int, int)
fn sqrsum2 (xy: int2): int =
  let val x = xy.0 and y = xy.1 in x * x + y * y end
")

The keyword #stacode("typedef") introduces a binding between the name
#stacode("int2") and the tuple type #stacode("(int, int)"). In other words,
#stacode("int2") is treated as an abbreviation or alias for #stacode("(int,
int)"). The function #dyncode("sqrsum2") is unary as it takes only one
argument, which is a tuple of the type #stacode("int2").  When applying
#dyncode("sqrsum2") to a tuple consisting of #dyncode("1") and
#dyncode("~1"), we need to write #dyncode("sqrsum2 @(1, ~1)"). If we simply
write #dyncode("sqrsum2 (1, ~1)"), then the typechecker is to report an
error of function arity mismatch as it assumes that #dyncode("sqrsum2") is
applied to two arguments (instead of one representing a pair).\

")#comment("para")

#para("\

Many functional languages (e.g., Haskell and ML) only allow unary
functions. A function of multiple arguments is encoded in these languages
as a unary function taking a tuple as its only argument or it is curried
into a function that takes these arguments sequentially. ATS, however,
provides direct support for functions of multiple arguments. There is even
some limited support in ATS for variadic functions, that is, functions of
indefinite number of arguments (e.g., the famous #dyncode("printf")
function in C). This is a topic I will cover elsewhere.\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="function-interface">
#title("Function Interface")

#para("\

The interface for a function specifies the type assigned to the
function. Given a binary function foo of the type (T1, T2) -> T3, its
interface can be written as follows:

#atscode("\
fun foo (arg1: T1, arg2: T2): T3
")

where #dyncode("arg1") and #dyncode("arg2") may be replaced with any
other legal identifiers for function arguments.  For functions of more or
fewer arguments, interfaces can be written in a similar fashion.  For
instance, we have the following interfaces for various functions on
integers:

#atscode("\
fun succ_int (x: int): int // successor
fun pred_int (x: int): int // predecessor

fun add_int_int (x: int, y: int): int // +
fun sub_int_int (x: int, y: int): int // -
fun mul_int_int (x: int, y: int): int // *
fun div_int_int (x: int, y: int): int // /

fun mod_int_int (x: int, y: int): int // modulo
fun gcd_int_int (x: int, y: int): int // greatest common divisor

fun lt_int_int (x: int, y: int): bool // <
fun lte_int_int (x: int, y: int): bool // <=
fun gt_int_int (x: int, y: int): bool // >
fun gte_int_int (x: int, y: int): bool // >=
fun eq_int_int (x: int, y: int): bool // =
fun neq_int_int (x: int, y: int): bool // <>

fun max_int_int (x: int, y: int): int // maximum
fun min_int_int (x: int, y: int): int // minimum

fun print_int (x: int): void
fun tostring_int (x: int): string
")

For now, I mostly use function interfaces for the purpose of presenting
functions.  I will show later how a function definition can be separated
into two parts: a function interface and an implementation that implements
the function interface. Note that separation as such is pivotal for
constructing (large) programs in a modular style.\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="evaluation-of-function-calls">
#title("Evaluation of Function Calls")

#para("\

Evaluating a function call is straightforward. Assume that we are to
evaluate the function call #dyncode("abs(0.0 - 1.0)") under some
environment ENV0, where the function #dyncode("abs") is defined as follows:

#atscode("\
fn abs (x: double): double = if x >= 0 then x else ~x
")

We first evaluate the argument of the call to #dyncode("~1.0") under ENV0;
we then extend ENV0 to ENV1 with a binding between #dyncode("x") and
#dyncode("~1.0") and start to evaluate the body of #dyncode("abs") under
ENV1; we evaluate the test #dyncode("x >= 0") to #dyncode("~1.0 >= 0") and
then to #dyncode("false"), which indicates that we take the else-branch
#dyncode("~x") to continue; we evaluate #dyncode("~x") to
#dyncode("~(~1.0)") and then to #dyncode("1.0"); so the evaluation of the
function call #dyncode("abs(0.0 - 1.0)") returns #dyncode("1.0").\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="recursive-functions">
#title("Recursive Functions")

#para("\
A recursive function is one that may make calls to itself in its
body. Therefore, a non-recursive function is just a special kind of of
recursive function: the kind that does not make any calls to itself in its
body. I consider recursion the most enabling feature a programming language
can provide. With recursion, we are enabled to do problem-solving based on
a strategy of reduction: In order to solve a problem to which a solution is
difficult to find immediately, we reduce the problem to problems that are
similar but simpler, and we repeat this reduction process if needed until
solutions become apparent. Let us now see some concrete examples of
problem-solving that make use of this reduction strategy.
")#comment("para")

#para("\
Suppose that we want to sum up all the integers ranging from 1 to n,
where n is a given integer. This can be readily done by implementing the
following recursive function #dyncode("sum1"):

#atscode("\
fun sum1 (n: int): int = if n >= 1 then sum1 (n-1) + n else 0
")

Note that the keyword #dyncode("fun") initiates the definition of a
recursive function. To find out the sum of all the integers ranging from
#dyncode("1") to #dyncode("n"), we call #dyncode("sum1 (n)"). The
reduction strategy for #dyncode("sum1 (n)") is straightforward: If
#dyncode("n") is greater than #dyncode("1"), then we can readily find the
value of #dyncode("sum1 (n)") by solving a simpler problem, that is,
finding the value of #dyncode("sum1 (n-1)").
")#comment("para")

#para("\
We can also solve the problem by implementing the following
recursive function #dyncode("sum2") that sums up all the integers in a
given range:

#atscode("\
fun sum2 (m: int, n: int): int = if m <= n then m + sum2 (m+1, n) else 0
")

This time, we call #dyncode("sum2 (1, n)") in order to find out the sum of
all the integers ranging from #dyncode("1") to #dyncode("n").  The
reduction strategy for #dyncode("sum2 (m, n)") is also straightforward: If
#dyncode("m") is less than #dyncode("n"), then we can readily find the
value of #dyncode("sum2 (m, n)") by solving a simpler problem, that is,
finding the value of #dyncode("sum2 (m+1, n)"). The reason for #dyncode("sum2
(m+1, n)") being simpler than #dyncode("sum2 (m, n)") is that
#dyncode("m+1") is closer to #dyncode("n") than #dyncode("m") is.
")#comment("para")

#para("\
Given integers m and n, there is another strategy for summing up all
the integers from m to n: If m does not exceed n, we can find the sum of
all the integers from m to (m+n)/2-1 and then the sum of all the integers
from (m+n)/2+1 to n and then sum up these two sums and (m+n)/2. The
following recursive function #dyncode("sum3") is implemented precisely
according to this strategy:

#atscode("\
fun sum3
  (m: int, n: int): int =
  if m <= n then let
    val mn2 = (m+n)/2 in sum3 (m, mn2-1) + mn2 + sum3 (mn2+1, n)
  end else 0 // end of [if]
// end of [sum3]
")

It should be noted that the division involved in the expression
#dyncode("(m+n)/2 ") is integer division for which rounding is done by
truncation.\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="evaluation-of-recursive-function-calls">
#title("Evaluation of Recursive Function Calls")

#para("\
Evaluating a call to a recursive function is not much different from
evaluating one to a non-recursive function.  Let #dyncode("fib") be the
following defined function for computing the Fibonacci numbers:

#atscode("\
fun fib (n: int): int =
  if n >= 2 then fib(n-1) + fib(n-2) else n
")

Suppose that we are to evaluate #dyncode("fib(2)") under some environment
ENV0. Given that #dyncode("2") is already a value, we extend ENV0 to ENV1
with a binding between #dyncode("n") and #dyncode("2") and start to
evaluate the body of #dyncode("fib") under ENV1; clearly, this evaluation
leads to the evaluation of #dyncode("fib(n-1) + fib(n-2)"); it is easy to
see that evaluating #dyncode("fib(n-1)") and #dyncode("fib(n-2)") under
ENV1 leads to #dyncode("1") and #dyncode("0"), respectively, and the
evaluation of #dyncode("fib(n-1) + fib(n-2)") eventually returns
#dyncode("1") (as the result of #dyncode("1+0")); thus the evaluation of
#dyncode("fib(2)") under ENV0 yields the integer value #dyncode("1").
")#comment("para")

#para("\
Let us now evaluate #dyncode("fib(3)") under ENV0; we extend ENV0
to ENV2 with a binding between #dyncode("n") and #dyncode("3"), and start
to evaluate the body of #dyncode("fib") under ENV2; we then reach the
evaluation of #dyncode("fib(n-1) + fib(n-2)") under ENV2; evaluating
#dyncode("fib(n-1)") under ENV2 leads to the evaluation of
#dyncode("fib(2)") under ENV2, which eventually returns #dyncode("1");
evaluating #dyncode("fib(n-2)") under ENV2 leads to the evaluation of
#dyncode("fib(1)") under ENV2, which eventually returns #dyncode("1");
therefore, evaluating #dyncode("fib(3)") under ENV0 returns #dyncode("2")
(as the result of #dyncode("1+1")).
")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-coin-changes-for-fun">
#title("Example: Coin Changes for Fun")

#para("\
Let S be a finite set of positive numbers.  The problem we want to
solve is to find out the number of distinct ways for a given integer x to
be expressed as the sum of multiples of the positive numbers chosen from
S. If we interpret each number in S as the denomination of a coin, then the
problem asks how many distinct ways there exist for a given value x to be
expressed as the sum of a set of coins. If we use cc(S, x) for this number,
then we have the following properties on the function cc:

<itemizedlist>

<listitem>
#para("\
cc(S, 0) = 1 for any S.
")
</listitem>

<listitem>
#para("\
If x < 0, then cc(S, x) = 0 for any S.
")
</listitem>

<listitem>
#para("\
If S is empty and x > 0, then cc(S, x) = 0.
")
</listitem>

<listitem>
#para("\
If S contains a number c, then
cc(S, x) = cc(S<subscript>1</subscript>, x) + cc(S, x-c),
where S<subscript>1</subscript> is the set formed by removing c from S.
")
</listitem>

</itemizedlist>

In the following implementation, we fix S to be the set consisting of
1, 5, 10 and 25.

#atscode("\
typedef int4 = (int, int, int, int)

val theCoins = (1, 5, 10, 25): int4

fun coin_get
  (n: int): int =
  if n = 0 then theCoins.0
  else if n = 1 then theCoins.1
  else if n = 2 then theCoins.2
  else if n = 3 then theCoins.3
  else ~1 (* erroneous value *)
// end of [coin_get]

fun coin_change (sum: int) = let
  fun aux (sum: int, n: int): int =
    if sum > 0 then
     (if n >= 0 then aux (sum, n-1) + aux (sum-coin_get(n), n) else 0)
    else (if sum < 0 then 0 else 1)
  // end of [aux]
in
  aux (sum, 3)
end // end of [coin_change]
")

The auxiliary function #dyncode("aux") defined in the body of
the function #dyncode("coin_change") corresponds to the cc function
mentioned above.

When applied to #dyncode("1000"), the function #dyncode("coin_change")
returns #dyncode("142511").
")#comment("para")

#para("\
Note that the entire code in this section plus some additional
code for testing is available #mycodelink("CHAP_FUNCTION/coinchange.dats", "on-line").
")

</sect1>

<!-- ****** ****** -->

<sect1
id="tail-call-and-tail-recursion">
#title("Tail-Call and Tail-Recursion")

#para("\

Suppose that a function foo makes a call in its body to a function
bar, where foo and bar may be the same function. If the return value of the
call to bar is also the return value of foo, then this call to bar is a
tail-call. If foo and bar are the same, then this is a (recursive) self
tail-call. For instance, there are two recursive calls in the body of the
function #dyncode("f91") defined as follows:

#atscode("\
fun f91 (n: int): int =
  if n >= 101 then n - 10 else f91 (f91 (n+11))
")

where the outer recursive call is a self tail-call while the inner one is
not.\

")#comment("para")

#para("\

If each recursive call in the body of a function is a tail-call,
then this function is a tail-recursive function. For instance, the
following function #dyncode("sum_iter") is tail-recursive:

#atscode("\
fun sum_iter
  (n: int, res: int): int =
  if n > 0 then sum_iter (n-1, n+res) else res
// end of [sum_iter]
")

A tail-recursive function is often referred to as an iterative function.\

")#comment("para")

#para("\

In ATS, the single most important optimization is probably the one
that turns a self tail-call into a local jump. This optimization
effectively turns every tail-recursive function into the equivalent of a
loop. Although ATS provides direct syntactic support for constructing
for-loops and while-loops, the preferred approach to loop construction in
ATS is in general through the use of tail-recursive functions. This is the
case primarily due to the fact that the syntax for writing tail-recursive
functions is compatible with the syntax for other programming features in
ATS while the syntax for loops is much less so.\

")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-the-eight-queens-puzzle">
#title("Example: The Eight-Queens Puzzle")

#para("\
The eight-queens puzzle is the problem of positioning on a 8x8
chessboard 8 queen pieces so that none of them can capture any other pieces
using the standard chess moves defined for a queen piece. I will present as
follows a solution to this puzzle in ATS, reviewing some of the programming
features that have been covered so far. In particular, please note that
every recursive function implemented in this solution is tail-recursive.
")#comment("para")

#para("\
First, let us introduce a name for the integer constant 8 as follows:

#atscode("\
\#define N 8
")

After this declaration, each occurrence of the name #dyncode("N") is to
be replaced with 8. For representing board configurations, we define
a type #dyncode("int8") as follows:

#atscode("\
typedef int8 =
(
  int, int, int, int, int, int, int, int
) // end of [int8]
")

A value of the type #dyncode("int8") is a tuple of 8 integers where the
first integer states the column position of the queen piece on the first
row (row 0), and the second integer states the column position of the queen
piece on the second row (row 1), and so on.
")#comment("para")

#para("\
In order to print out a board configuration, we define the following
functions:

#atscode('\
fun print_dots (i: int): void =
  if i > 0 then (print ". "; print_dots (i-1)) else ()
// end of [print_dots]

fun print_row (i: int): void =
(
  print_dots (i); print "Q "; print_dots (N-i-1); print "\\\n";
) // end of [print_row]

fun print_board (bd: int8): void =
(
  print_row (bd.0); print_row (bd.1); print_row (bd.2); print_row (bd.3);
  print_row (bd.4); print_row (bd.5); print_row (bd.6); print_row (bd.7);
  print_newline ()
) // end of [print_board]
')

The function #dyncode("print_newline") prints out a newline symbol and then
flushes the buffer associated with the standard output. If the reader is
unclear about what buffer flushing means, please feel free to ignore this
aspect of #dyncode("print_newline").\

")#comment("para")

#para("\

As an example, if #dyncode("print_board") is called on the board
configuration represented by @(0, 1, 2, 3, 4, 5, 6, 7), then the following
8 lines are printed out:

#atscode("\
Q . . . . . . . 
. Q . . . . . . 
. . Q . . . . . 
. . . Q . . . . 
. . . . Q . . . 
. . . . . Q . . 
. . . . . . Q . 
. . . . . . . Q 
")
")#comment("para")

#para("\

Given a board and the row number of a queen piece on the board, the
following function #dyncode("board_get") returns the column number of the piece:

#atscode("\
fun board_get
  (bd: int8, i: int): int =
  if i = 0 then bd.0
  else if i = 1 then bd.1
  else if i = 2 then bd.2
  else if i = 3 then bd.3
  else if i = 4 then bd.4
  else if i = 5 then bd.5
  else if i = 6 then bd.6
  else if i = 7 then bd.7
  else ~1 // end of [if]
// end of [board_get]
")
")#comment("para")

#para("\

Given a board, a row number i and a column number j, the following function
#dyncode("board_set") returns a new board that are the same as the original
board except for j being the column number of the queen piece on row i:

#atscode("\
fun board_set
  (bd: int8, i: int, j:int): int8 = let
  val (x0, x1, x2, x3, x4, x5, x6, x7) = bd
in
  if i = 0 then let
    val x0 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 1 then let
    val x1 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 2 then let
    val x2 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 3 then let
    val x3 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 4 then let
    val x4 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 5 then let
    val x5 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 6 then let
    val x6 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 7 then let
    val x7 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else bd // end of [if]
end // end of [board_set]
")

Clearly, the functions #dyncode("board_get") and #dyncode("board_set") are
defined in a rather unwieldy fashion. This is entirely due to the use of
tuples for representing board configurations. If we could use an array to
represent a board configuration, then the implementation would be much
simpler and cleaner. However, we have not yet covered arrays at this
point.\

")#comment("para")

#para("\
We now implement two testing functions #dyncode("safety_test1") and
#dyncode("safety_test2") as follows:

#atscode("\
fun safety_test1
(
  i0: int, j0: int, i1: int, j1: int
) : bool =
(*
** [abs]: the absolute value function
*)
  j0 != j1 andalso abs (i0 - i1) != abs (j0 - j1)
// end of [safety_test1]

fun safety_test2
(
  i0: int, j0: int, bd: int8, i: int
) : bool =
  if i >= 0 then
    if safety_test1 (i0, j0, i, board_get (bd, i))
      then safety_test2 (i0, j0, bd, i-1) else false
    // end of [if]
  else true // end of [if]
// end of [safety_test2]
")

The functionalities of these two functions can be described as such:

<itemizedlist>
<listitem>
#para("\
The function #dyncode("safety_test1") tests whether a queen piece on row
#dyncode("i0") and column #dyncode("j0") can capture another one on row
#dyncode("i") and column #dyncode("j").
")
</listitem>

<listitem>
#para("\
The function #dyncode("safety_test2") tests whether a queen piece on row
#dyncode("i0") and column #dyncode("j0") can capture any pieces on a
given board with a row number less than or equal to #dyncode("i").
")
</listitem>
</itemizedlist>
")#comment("para")

#para("\
We are now ready to implement the following function
#dyncode("search") based on a standard depth-first search (DFS) algorithm:

#atscode('\
fun search
(
  bd: int8, i: int, j: int, nsol: int
) : int =
  if j < N then let
    val test = safety_test2 (i, j, bd, i-1)
  in
    if test then let
      val bd1 = board_set (bd, i, j)
    in
      if i+1 = N then let
        val () = print! ("Solution #", nsol+1, ":\\\n\\\n")
        val () = print_board (bd1)
      in
        search (bd, i, j+1, nsol+1)
      end else
        search (bd1, i+1, 0(*j*), nsol) // positioning next piece
      // end of [if]
    end else
      search (bd, i, j+1, nsol)
  end else
  (
    if i > 0 then
      search (bd, i-1, board_get (bd, i-1) + 1, nsol)
    else nsol // end of [if]
  )
// end of [search]
')

The return value of #dyncode("search") is the number of distinct solutions
to the eight queens puzzle. The symbol #dyncode("print!") in the body of
#dyncode("search") is a special identifier in ATS: It takes an
indefinite number of arguments and then applies #dyncode("print") to each of
them. Here is the first solution printed out by a call to the function
#dyncode("search"):

#atscode("\
Q . . . . . . . 
. . . . Q . . . 
. . . . . . . Q 
. . . . . Q . . 
. . Q . . . . . 
. . . . . . Q . 
. Q . . . . . . 
. . . Q . . . . 
")

There are 92 distinct solutions in total.
")#comment("para")

#para("\

Note that the entire code in this section plus some additional code for
testing is available #mycodelink("CHAP_FUNCTION/queens.dats", "on-line").\

")

</sect1>

<!-- ****** ****** -->

<sect1
id="mutually-recursive-functions">
#title("Mutually Recursive Functions")

#para("\

A collection of functions are defined mutually recursively if each function
can make calls in its body to any functions in this collection.  Mutually
recursive functions are commonly encountered in practice.

")

#para("\

As an example, let P be a function on natural numbers defined as follows:

<itemizedlist>
<listitem>
#para("P(0) = 1")
</listitem>
<listitem>
#para("\
P(n+1) = 1 + the sum of the products of i and P(i) for i ranging from 1 to n
")
</listitem>
</itemizedlist>

Let us introduce a function Q such that Q(n) is the sum of the products of
i and P(i) for i ranging from 1 to n. Then the functions P and Q can be
defined mutually recursively as follows:

<itemizedlist>
<listitem>
#para("P(0) = 1")
</listitem>
<listitem>
#para("P(n+1) = 1 + Q(n)")
</listitem>

<listitem>
#para("Q(0) = 0")
</listitem>
<listitem>
#para("Q(n+1) = Q(n) + (n+1) * P(n+1)")
</listitem>
</itemizedlist>

The following implementation of P and Q is a direct translation of their
definitions into ATS:

#atscode("\
fun P (n:int): int = if n > 0 then 1 + Q(n-1) else 1
and Q (n:int): int = if n > 0 then Q(n-1) + n * P(n) else 0
")

Note that the keyword #dyncode("and") is used to combine function
definitions.\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="mutual-tail-recursion">
#title("Mutual Tail-Recursion")

#para("\

Suppose that foo and bar are two mutually defined recursive functions.  In
the body of foo or bar, a tail-call to foo or bar is a mutually recursive
tail-call. For instance, the following two functions #dyncode("isevn") and
#dyncode("isodd") are mutually recursive:

#atscode("\
fun isevn (n: int): bool = if n > 0 then isodd (n-1) else true
and isodd (n: int): bool = if n > 0 then isevn (n-1) else false
")

The mutually recursive call to #dyncode("isodd") in the body of
#dyncode("isevn") is a tail-call, and the mutually recursive call to
#dyncode("isevn") in the body of #dyncode("isodd") is also a tail-call.  If
we want that these two tail-calls be compiled into local jumps, we should
replace the keyword #dyncode("fun") with the keyword #dyncode("fnx") as
follows:

#atscode("\
fnx isevn (n: int): bool = if n > 0 then isodd (n-1) else true
and isodd (n: int): bool = if n > 0 then isevn (n-1) else false
")

What the ATS compiler does in this case is to combine these two functions
into a single one so that each mutually recursive tail-call in their bodies
can be turned into a self tail-call in the body of the combined function,
which is then ready to be compiled into a local jump.\

")#comment("para")

#para("\
When writing code corresponding to embedded loops in an imperative
programming language such as C or Java, we often need to make sure that
mutually recursive tail-calls are compiled into local jumps. The following
function #dyncode("print_multable") is implemented to print out a standard
multiplication table for nonzero digits:

#atscode('\
fun print_multable () = let
//
\#define N 9
//
fnx loop1 (i: int): void =
  if i <= N then loop2 (i, 1) else ()
//
and loop2 (i: int, j: int): void =
  if j <= i then let
    val () = if j >= 2 then print " "
    val () = printf ("%dx%d=%2.2d", @(j, i, j*i))
  in
    loop2 (i, j+1) 
  end else let
    val () = print_newline () in loop1 (i+1)
  end // end of [if]
//
in
  loop1 (1)
end // end of [print_multable]
')

The functions #dyncode("loop1") and #dyncode("loop2") are defined
mutually recursively, and the mutually recursive calls in their bodies are
all tail-calls. The keyword #dyncode("fnx") indicates to the ATS compiler
that the functions #dyncode("loop1") and #dyncode("loop2") should be
combined so that these tail-calls can be compiled into local jumps. In a
case where #dyncode("N") is a large number (e.g., 1,000,000), calling
#dyncode("loop1") may run the risk of stack overflow if these tail-calls
are not compiled into local jumps.
")#comment("para")

#para("\

When called, the function #dyncode("print_multable") prints out the
following multiplication table:

#atscode("\
1x1=01
1x2=02 2x2=04
1x3=03 2x3=06 3x3=09
1x4=04 2x4=08 3x4=12 4x4=16
1x5=05 2x5=10 3x5=15 4x5=20 5x5=25
1x6=06 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36
1x7=07 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49
1x8=08 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64
1x9=09 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81
")

")#comment("para")

#para("\

In summary, the very ability to turn mutually recursive tail-calls into
local jumps makes it possible to implement embedded loops as mutually
tail-recursive functions. This ability is indispensable for advocating the
practice of replacing loops with recursive functions in ATS.\

")

</sect1>

<!-- ****** ****** -->

<sect1
id="envless-functions-and-function-closures">
#title("Envless Functions and Closure Functions")

#para("\

I use <emphasis>envless</emphasis> as a shorthand for environmentless,
which is not a legal word but I suppose that you have no problem figuring
out what it means.\

")

#para("\

An envless function is represented by a pointer pointing to some place in a
code segment where the object code for executing a call to this function is
located. Every function in the programming language C is envless. A closure
function is also represented by a pointer, but the pointer points to some
place in a heap where a tuple is allocated (at run-time). Usually, the
first component of this tuple is a pointer representing an envless function
and the rest of the components represent some bindings. A tuple as such is
often referred to as a closure, which can be thought of as an envless
function paired with an environment. It is possible that the environment of
a closure function is empty, but this does not equate a closure function
with an envless function. Every function in functional languages such as ML
and Haskell is a closure function.\

")#comment("para")

#para("\

In the following example, the function #dyncode("sum"), which is assigned
the type #dyncode("(int) -> int"), sums up all the integers between 1 and a
given natural number:

#atscode("\
fun sum
  (n: int): int = let
  fun loop
  (
    i: int, res: int
  ) :<cloref1> int =
    if i <= n then loop (i+1, res+i) else res
  // end of [loop]
in
  loop (1(*i*), 0(*res*))
end // end of [sum]
")

The inner function #dyncode("loop") is a closure function as is indicated
by the special syntax #dyncode(":&lt;cloref1&gt;"), and the type assigned
to #dyncode("loop") is denoted by #dyncode("(int, int) -&lt;cloref1&gt;
int"). Hence, envless functions and closure functions can be distinguished
at the level of types.\

")#comment("para")

#para("\

If the syntax #dyncode(":&lt;cloref1&gt;") is replaced with the colon
symbol #dyncode(":") alone, the code can still pass typechecking but its
compilation may eventually lead to a warning or even an error indicating
that #dyncode("loop") cannot be compiled into a toplevel function in C. The
reason for this warning/error is due to the body of #dyncode("loop")
containing a variable #dyncode("n") that is neither at toplevel nor a part
of the arguments of #dyncode("loop") itself. It is straightforward to make
#dyncode("loop") an envless function by including #dyncode("n") as an
argument in addition to the original ones:

#atscode("\
fun sum
  (n: int): int = let
  fun loop
  (
    n:int, i: int, res: int
  ) : int =
    if i <= n then loop (n, i+1, res+i) else res
  // end of [loop]
in
  loop (n, 1(*i*), 0(*res*))
end // end of [sum]
")

As a matter of fact, what happens during compilation is that the first
implementation of #dyncode("sum") and #dyncode("loop") gets translated,
more or less, into the second implementation, and there is #emphasis("no")
actual creation of closures (for representing closure functions) at
run-time.\

")#comment("para")

#para("\

The need for creating closures often appears when a function is not
directly applied. For instance, the return value of a function call may
also be a function. In the following code, the defined function
#dyncode("addx") returns another function when applied to a given integer
#dyncode("x"), and the returned function is a closure function, which
always adds the integer #dyncode("x") to its own argument:


#atscode("\
fun addx (x: int): int -<cloref1> int = lam y => x + y

val plus1 = addx (1) // [plus1] is of the type int -<cloref1> int
val plus2 = addx (2) // [plus2] is of the type int -<cloref1> int
")

It should be clear that #dyncode("plus1(0)") and #dyncode("plus2(0)")
return #dyncode("1") and #dyncode("2"), respectively.  The closure that is
given the name #dyncode("plus1") consists of an envless function and an
environment binding #dyncode("x") to #dyncode("1"). The envless function
can essentially be described by the pseudo syntax #dyncode("lam (env, y) =>
env.x + y"), where #dyncode("env") and #dyncode("env.x") refer to an
environment and the value to which #dyncode("x") is bound in that
environment. When evaluating #dyncode("plus1(0)"), we can first bind
#dyncode("env") and #dyncode("y") to the environment in #dyncode("plus1")
and the argument #dyncode("0"), respectively, and then start to evaluate
the body of the envless function in #dyncode("plus1"), which is
#dyncode("env.x + y"). Clearly, this evaluation yields the value
#dyncode("1") as is expected.\

")#comment("para")

#para("\

Closures are often passed as arguments to functions that are referred to as
higher-order functions.  It is also fairly common for closures to be
embedded in data structures.\

")

</sect1>

<!-- ****** ****** -->

<sect1
id="higher-order-functions">
#title("Higher-Order Functions")

#para("\
A higher-order function is a function that take another function as
its argument. For instance, the following defined function
#dyncode("rtfind") is a higher-order one:

#atscode("\
fun rtfind
  (f: int -> int): int = let
  fun loop (
    f: int -> int, n: int
  ) : int =
    if f(n) = 0 then n else loop (f, n+1)
  // end of [loop]
in
  loop (f, 0)
end // end of [rtfind]
")

Given a function from integers to integers, #dyncode("rtfind") searches
for the first natural number that is a root of the function. For instance,
calling #dyncode("rtfind") on the polynomial function #dyncode("lam x => x * x
- x + 110") returns #dyncode("11").  Note that #dyncode("rtfind")
loops forever if it is applied to a function that does not have a root.
")#comment("para")

#para("\
Higher-order functions can greatly facilitate code reuse, and I now
present a simple example to illustrate this point.  The following defined
functions #dyncode("sum") and #dyncode("prod") compute the sum and
product of the integers ranging from 1 to a given natural number,
respectively:

#atscode("\
fun sum (n: int): int = if n > 0 then sum (n-1) + n else 0
fun prod (n: int): int = if n > 0 then prod (n-1) * n else 1
")

The similarity between the functions #dyncode("sum") and #dyncode("prod")
is evident.  We can define a higher-function #dyncode("ifold") and then
implement #dyncode("sum") and #dyncode("prod") based on
#dyncode("ifold"):

#atscode("\
fun ifold
  (n: int, f: (int, int) -> int, ini: int): int =
  if n > 0 then f (ifold (n-1, f, ini), n) else ini
// end of [ifold]

fun sum (n: int): int = ifold (n, lam (res, x) => res + x, 0)
fun prod (n: int): int = ifold (n, lam (res, x) => res * x, 1)
")

If we ever want to compute the sum of the squares of the integers ranging
from 1 to a given natural number n, we can readily do it by defining a
function based on #dyncode("ifold") as follows:

#atscode("\
fun sqrsum (n: int): int = ifold (n, lam (res, x) => res + x * x, 0)
")

Suppose we generalize #dyncode("sqrsum") to the following function
#dyncode("sqrmodsum") in order to compute the sum of the squares of the
integers ranging from 1 to n that are multiples of a given number d:

#atscode("\
fun sqrmodsum (n: int, d: int): int =
  ifold (n, lam (res, x) => if x mod d then res + x * x else res, 0)
// end of [sqrmodsum]
")

For someone unfamilar with the distinction between an envless function and
a closure function, it may be a bit suprising to learn that this
generalization does not actually work. The simple reason is that
#dyncode("ifold") expects its second argument to be an envless function but
the function passed to #dyncode("ifold") in the body of
#dyncode("sqrmodsum") is clearly not envless (due to its use of
#dyncode("d")). To address the issue, we can implement a variant of
#dyncode("ifold") as follows and then implement #dyncode("sqrmodsum") based
on this variant:

#atscode("\
fun ifold2
(
  n: int, f: (int, int) -<cloref1> int, ini: int
) : int =
  if n > 0 then f (ifold2 (n-1, f, ini), n) else ini
// end of [ifold2]

fun sqrmodsum (n: int, d: int): int =
  ifold2 (n, lam (res, x) => if x mod d then res + x * x else res, 0)
// end of [sqrmodsum]
")

While #dyncode("ifold2") is indeed more general than #dyncode("ifold"),
this generality does come with a price. Whenever #dyncode("sqrmodsum") is
called, a closure function must be created on heap and then passed to
#dyncode("ifold2"); this closure function is of no further use after the
call returns and the memory it occupies can only be properly relcaimed
through garbage collection (GC). Therefore, calling functions like
#dyncode("sqrmodsum") can readily result in memory leaks in a setting where
no GC is available. Fortunately, there are also linear closure functions in
ATS, which do not cause any memory leaks even in the absence of GC as they
are required to be explicitly freed by the programmer. I will cover this
interesting programming feature elsewhere.\

")#comment("para")

#para("\

As more features of ATS are introduced, higher-order functions will become
even more effective in facilitating code reuse.\

")#comment("para")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-binary-search-for-fun">
#title("Example: Binary Search for Fun")

#para("\

While binary search is often performed on an ordered array to check whether
a given element is stored in that array, it can also be employed to compute
the inverse of an increasing or decreasing function on integers. In the
following code, the defined function #dyncode("bsearch_fun") returns an
integer i0 such that f(i) <= x0 holds for i ranging from lb to i0,
inclusive, and x0 < f(i) holds for i ranging from i0+1 to ub, inclusive:

#atscode("\
//
// The type [uint] is for unsigned integers
//
fun bsearch_fun
(
  f: int -<cloref1> uint
, x0: uint, lb: int, ub: int
) : int =
  if lb <= ub then let
    val mid = lb + (ub - lb) / 2
  in
    if x0 < f (mid) then
      bsearch_fun (f, x0, lb, mid-1)
    else
      bsearch_fun (f, x0, mid+1, ub)
    // end of [if]
  end else ub // end of [if]
// end of [bsearch_fun]
")

As an example, the following function #dyncode("isqrt") is defined based
on #dyncode("bsearch_fun") to compute the integer square root of a given
natural number, that is, the largest integer whose square is less than or
equal to the given natural number:

#atscode("\
//
// Assuming that [uint] is of 32 bits
//
val ISQRT_MAX = (1 << 16) - 1 // = 65535
fun isqrt
  (x: uint): int =
  bsearch_fun (lam i => square ((g0i2u)i), x, 0, ISQRT_MAX)
// end of [isqrt]
")

Note that the function #dyncode("g0i2u") is for casting a signed integer
into an unsigned one and the function #dyncode("square") returns the square
of its argument.\

")#comment("para")

#para("\
Please find #mycodelink("CHAP_FUNCTION/bsearch.dats", "on-line")
the entire code in this section plus some additional code for testing.
")

</sect1>

<!-- ****** ****** -->

<sect1
id="example-a-higher-order-fun-puzzle">
#title("Example: A Higher-Order Fun Puzzle")

#para("\

Let us first introduce a type definition as follows:

#atscode("\
typedef I (a:t@ype) = a -<cloref1> a
")

Given a type T, I(T) is for a closure function that maps a given input
value of type T to an output value of the same type T. Given a function f
of type I(T), we can compose f with itself to form another function, which
just applies f twice to a given argument. The following function template
#dyncode("twice") does precisely the described function composition:

#atscode("\
fn{a:t0p}
twice (f: I(a)):<cloref> I(a) = lam (x) => f (f (x))
")

Let us now take a look at some interesting code involving #dyncode("twice")
that is also likely to be puzzling:

#atscode("\
//
typedef I0 = int
typedef I1 = I(I0)
typedef I2 = I(I1)
typedef I3 = I(I2)
//
val Z = 0
val S = lam (x: int): int =<cloref> x + 1
val ans0 = twice<I0>(S)(Z)
val ans1 = twice<I1>(twice<I0>)(S)(Z)
val ans2 = twice<I2>(twice<I1>)(twice<I0>)(S)(Z)
val ans3 = twice<I3>(twice<I2>)(twice<I1>)(twice<I0>)(S)(Z)
//
")

Note that the type definitions
#stacode("I0"),
#stacode("I1"),
#stacode("I2"), and
#stacode("I3") are introduced to make the above code more easily
accessible.\

")

#para("\

Obviously, #dyncode("Z") stands for the integer 0 and #dyncode("S") for the
successor function on integers. Also, #dyncode("ans0") equals 2 as it is
the result of applying #dyncode("S") to #dyncode("Z") twice. Let
#dyncode("S2") be the function that applies #dyncode("S") twice.  It is
clear that #dyncode("ans1") is the result of applying #dyncode("S2") to
#dyncode("Z") twice and thus equals 4. With a bit more effort, one should
be able to figure out that the value of #dyncode("ans2") is 16. What is the
value of #dyncode("ans3")? In general, what is the nth value in the
sequence of #dyncode("ans0"), #dyncode("ans1"), #dyncode("ans2"), etc.?
I leave these questions as exercises for the interested reader.

")

#para("\
Please find #mycodelink("CHAP_FUNCTION/twice.dats", "on-line")
the entire code in this section plus some additional code for testing.
")

</sect1>

<!-- ****** ****** -->

<sect1
id="currying-and-uncurrying">
#title("Currying and Uncurrying")

#para("\

Currying, which is named after the logician Haskell Curry, means to
turn a function taking multiple arguments simultaneously into a function of
the same body (modulo corresponding recursive function calls being changed
accordingly) that takes these arguments sequentially. Uncurrying means
precisely the opposite of currying. In the following code, both of the
defined functions #dyncode("acker1") and #dyncode("acker2") implement the
Ackermann's function (which is famous for being recursive but not primitive
recursive):

#atscode('\
fun acker1
  (m: int, n: int): int =
(
  if m > 0 then
    if n > 0 then acker1 (m-1, acker1 (m, n-1)) else acker1 (m-1, 1)
  else n+1 // end of [if]
)

fun acker2
  (m: int) (n: int): int =
(
  if m > 0 then
    if n > 0 then acker2 (m-1) (acker2 m (n-1)) else acker2 (m-1) 1
  else n+1 // end of [if]
)
')

The function #dyncode("acker2") is a curried version of #dyncode("acker1")
while the function #dyncode("acker1") in an uncurried version of
#dyncode("acker2"). Applying #dyncode("acker2") to an integer value
generates a linear function closure, which I will explain elsewhere.\

")#comment("para")

#para("\

In functional languages such as ML and Haskell, a function of multiple
arguments needs to be either curried or translated into a corresponding
unary function of a single argument that itself is a tuple. In such
languages, currying often leads to better performance at run-time and thus
is preferred. In ATS, functions of multiple arguments are supported
directly. Also, given a function of multiple arguments, a curried version
of the function is likely to perform less efficiently at run-time than the
function itself (due to the treatment of curried functions by the ATS
compiler <command>atsopt</command>).  Therefore, the need for currying in
ATS is greatly diminished. Unless convincing reasons can be given, currying
is in general #emphasis("not") a recommended programming style in ATS.\

")#comment("para")

#para("\

Please find
#mycodelink("CHAP_FUNCTION/acker.dats", "on-line")
the entire code in this section plus some additional
code for testing.\

")#comment("para")

</sect1>

</chapter><!--id="functions"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
