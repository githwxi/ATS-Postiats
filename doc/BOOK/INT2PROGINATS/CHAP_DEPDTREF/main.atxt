%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="datatype_refinement">
#title("Datatype Refinement")

#para("\

The datatype mechanism in ATS is adopted from ML directly, and it is really
a signatory feature in functional programming. However, the datatypes we
have seen so far are not very precise when employed to classify values. For
instance, given a type T, the type #stacode("list0(T)") is for values
representing both empty and non-empty lists consisting of elements of the
type T. Therefore, empty and non-empty lists cannot be distinguished at the
level of types. This limitation severely diminishes the effectiveness of
datatypes of ML-style in capturing program invariants. In ATS, datatypes of
ML-style can be refined into dependent datatypes of DML-style, where DML
refers to the programming language Dependent ML, the immediate precursor of
ATS. With such refinement, datatypes can classify values with greatly
enhanced precision.\

")#comment("para")

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_DEPDTREF/", "on-line").

")

<!-- ****** ****** -->

<sect1
id="dependent_datatypes">
#title("Dependent Datatypes")

#para("\

The syntax for declaring dependent datatypes is mostly similar to the
syntax for declaring non-dependent datatypes: For instance, the dependent
datatype #stacode("list") in ATS is declared as follows:

#atscode("\
datatype list (t@ype+, int) =
  | {a:t@ype} list_nil (a, 0) of () // [of ()] is optional
  | {a:t@ype} {n:nat} list_cons (a, n+1) of (a, list (a, n))
")

More precisely, #stacode("list") is declared as a type constructor of the
sort #emphasis("(t@ype, int) -> type"), which means that #stacode("list")
takes an unboxed type and a static integer to form a boxed type. The
keyword #keycode("t@ype+") indicates that #stacode("list") is covariant at
its first parameter (of the sort #emphasis("t@ype")), that is,
#stacode("list(T1, I)") is considered a subtype of #stacode("list(T2, I)")
if T1 is a subtype of T2.  There is also the keyword #keycode("t@ype-") for
indicating the declared type constructor being contravariant at a
parameter, but it is rarely used in practice. Also, keywords like
#keycode("type+") and #keycode("type-") are interpreted similarly.\

")#comment("para")

#para("\

There two data (or value) constructors #dyncode("list_nil") and
#dyncode("list_cons") associated with #stacode("list"), which are declared to be
of the following types:

#atscode("\
list_nil : {a:t@ype} () -> list(a, 0)
list_cons : {a:t@ype}{n:nat} (a, list(a, n)) -> list(a, n+1)
")

Given a type T and a static integer I, the type #stacode("list(T, I)") is
for values representing lists of length I in which each element is of the
type T. Hence, the types of #dyncode("list_nil") and #dyncode("list_cons")
mean that #dyncode("list_nil") forms a list of length 0 and
#dyncode("list_cons") forms a list of length n+1 if applied to an element
and a list of length n.  Note that it is also possible to declare
#stacode("list") as follows in a more concise style:

#atscode("\
datatype list (a:t@ype+, int) =
  | list_nil (a, 0) of () // [of ()] is optional
  | {n:nat} list_cons (a, n+1) of (a, list (a, n))
")

The use of #stacode("a:t@ype+") (instead of #keycode("t@ype+")) introduces
implicitly a universal quantifier over #stacode("a") for the type assigned
to each data constructor associated with the declared type constructor
#stacode("list").\

")#comment("para")

#para("\

As an example of programming with dependent datatypes, the following code
implements a function template for computing the length of a given list:

#atscode("\
fun{
a:t@ype
} list_length
  {n:nat} .<n>.
  // .<n>. is a termination metric
  (xs: list (a, n)): int (n) = case+ xs of
  | list_nil () => 0
  | list_cons (_, xs1) => 1 + list_length (xs1)
// end of [list_length]
")

The type assigned to the function #dyncode("list_length") indicates that
the function takes a list of length n for any natural number n and returns
an integer of value n. In addition, the function is verified to be
terminating. Therefore, #dyncode("list_length") is guaranteed to implement the
function that computes the length of a given list. I now briefly explain
how typechecking can be performed on the definition of
#dyncode("list_length"). Let us first see that the the following clause
typechecks:

#atscode("\
  | list_cons (_, xs1) => 1 + list_length (xs1)
")

What we need to verify is that the expression on the righthand side of the
symbol #keycode("=>") can be assigned the type #stacode("int(n)") under the
assumption that #dyncode("xs") matches the pattern on the lefthand side of
the symbol #keycode("=>").  Let us assume that #dyncode("xs1") is of the
type #stacode("list(a, n1)") for some natural number #stacode("n1"), and
this assumption implies that the pattern #dyncode("list_cons(_, xs1)") is
of the type #stacode("list(a, n1+1)").  Clearly, matching #dyncode("xs")
against the pattern #dyncode("list_cons(_, xs1)") generates a condition
#stacode("n=n1+1").  It is also clear that #dyncode("list_length(xs1)") is
of the type #stacode("int(n1)") and thus #dyncode("1 + list_length(xs1)")
is of the type #stacode("int(1+n1)"). As the condition #stacode("n=n1+1")
implies #stacode("n=1+n1"), #dyncode("1 + list_length(xs1)") can be given
the type #stacode("int(n)"). So this clause typechecks.  Note that matching
#dyncode("xs") against the pattern #dyncode("list_nil()") generates the
assumption #stacode("n=0"), which implies that #stacode("0") is of the type
#stacode("int(n)"). Therefore, the following clause typechecks: ")

#atscode("\
  | list_nil () => 0
")

#para("\

Given that the two clauses typecheck properly, the case-expression
containing them can be assigned the type #stacode("int(n)"). Therefore, the
definition of #dyncode("list_length") typechecks.\

")#comment("para")

#para('\

As the recursive call in the body of the above defined function
#dyncode("list_length") is not a tail-call, the function may not be able to
handle a long list (e.g., one that contains 1 million elements).  The
following code gives another implementation for computing the length of a
given list:

')

#atscode('\
fun{
a:t@ype
} list_length{n:nat} .<>.
  (xs: list (a, n)): int (n) = let
  // loop: {i,j:nat} (list (a, i), int (j)) -> int (i+j)
  fun loop {i,j:nat} .<i>.
    // .<i>. is a termination metric
    (xs: list (a, i), j: int j): int (i+j) = case+ xs of
    | list_cons (_, xs1) => loop (xs1, j+1) | list_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [list_length]
')

#para('\

This time, #dyncode("list_length") is based on a tail-recursive function
#dyncode("loop") and thus can handle lists of any length in constant stack
space. Note that the type assigned to #dyncode("loop") indicates that
#dyncode("loop") takes a list of length i and an integer of value j for some
natural numbers i and j and returns an integer of value i+j. Also,
#dyncode("loop") is verified to be terminating.

')#comment("para")

#para('\

There is also a dependent datatype #stacode("option") in ATS for forming
optional values:

')

#atscode('\
datatype
option (a:t@ype+, bool) =
  | Some (a, true) of a | None (a, false) of ()
// end of [option]
')

#para('\

As an example, the following function template #dyncode("list_last") tries to
find the last element in a given list:

')

#atscode('\
fun{
a:t@ype
} list_last
  {n:nat} .<>.
(
  xs: list (a, n)
) : option (a, n > 0) = let
//
fun loop
  {n:pos} .<n>.
(
  xs: list (a, n)
) : a = let
  val+ list_cons (_, xs1) = xs
in
  case+ xs1 of
  | list_cons _ => loop (xs1)
  | list_nil () => let
      val+ list_cons (x, _) = xs in x
    end // end of [list_nil]
end // end of [loop]
//
in
  case+ xs of
  | list_cons _ => Some (loop (xs)) | list_nil () => None ()
end // end of [list_last]
')

#para('\

The inner function #dyncode("loop") is evidently tail-recursive and it is
verified to be terminating.

')

#para('\

After a programmer becomes familar with #stacode("list") and
#stacode("option"), there is little incentive for him or her to use
#stacode("list0") and #stacode("option0") anymore. Internally, values of
#stacode("list") and #stacode("list0") have exactly the same representation and
there are cast functions of zero run-time cost in ATS for translating
between values of #stacode("list") and #stacode("list0").  The same applies
to values of #stacode("option") and #stacode("option0") as well.

')

</sect1><!--id="dependent_datatypes"-->

<!-- ****** ****** *-->

<sect1
id="example_function_templates_on_lists_redux">
#title("Example: Function Templates on Lists (Redux)")

#para("\

I have presented previously implementation of some commonly used function
templates on lists formed with the constructors #dyncode("list0_nil") and
#dyncode("list0_cons"). This time, I present as follows implementation of
the corresponding function templates on lists formed with the constructors
#dyncode("list_nil") and #dyncode("list_cons"), which make it possible to
assign more accurate types to these templates.

")

#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DEPDTREF/listfuns.dats", "on-line").
")

<sect2 id="list_append">
#title("Appending: #dyncode("list_append")")

#para("\

Given two lists xs and ys of the types #stacode("list(T, I1)") and
#stacode("list(T, I2)") for some type T and integers I1 and I2,
#dyncode("list_append(xs, ys)") returns a list of the type
#stacode("list(T,I1+I2)") that is the concatenation of xs and ys:

#atscode("\
fun{
a:t@ype
} list_append
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = case+ xs of
  | list_nil () => ys
  | list_cons (x, xs) => list_cons (x, list_append (xs, ys))
// end of [list_append]
")

Clearly, this implementation of #dyncode("list_append") is not
tail-recursive.\

")#comment("para")

</sect2><!--id="list_append"-->

<sect2 id="list_reverse_append">
#title("Reverse Appending: #dyncode("list_reverse_append")")

#para("\

Given two lists xs and ys of the type #stacode("list(T, I1)") and
#stacode("list(T, I2)") for some type T and integers I1 and I2,
#dyncode("list_reverse_append(xs, ys)") returns a list of the type
#stacode("list(T, I1+I2)") that is the concatenation of the reverse of xs
and ys:

#atscode("\
fun{
a:t@ype
} list_reverse_append
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = case+ xs of
  | list_nil () => ys
  | list_cons (x, xs) =>
      list_reverse_append (xs, list_cons (x, ys))
// end of [list_reverse_append]
")

Clearly, this implementation of #dyncode("list_reverse_append") is
tail-recursive.\

")#comment("para")

</sect2><!--id="list_reverse_append"-->

<sect2 id="list_reverse">
#title("Reversing: #dyncode("list_reverse")")

#para("\

Given a list xs, #dyncode("list_reverse(xs)") returns the reverse of xs,
which is of the same length as xs:

#atscode("\
fun{a:t@ype}
list_reverse{n:nat} .<>. // defined non-recursively
  (xs: list (a, n)): list (a, n) = list_reverse_append (xs, list_nil)
// end of [list_reverse]
")
")#comment("para")

</sect2><!--id="list_reverse"-->

<sect2 id="list_map">
#title("Mapping: #dyncode("list_map")")

#para("\

Given a list xs of the type #stacode("list(T1, I)") for some type T1 and
integer I and a closure function f of the type #stacode("T1 -&lt;cloref1&gt; T2")
for some T2, #dyncode("list_map(xs)") returns a list ys of the type #stacode("list(T2, I))":

#atscode("\
fun{
a:t@ype}
{b:t@ype
} list_map
  {n:nat} .<n>.
(
  xs: list (a, n), f: a -<cloref1> b
) : list (b, n) = case+ xs of
  | list_nil () => list_nil ()
  | list_cons (x, xs) => list_cons (f x, list_map (xs, f))
// end of [list_map]
")

Each element y in ys equals f(x), where x is the corresponding element in
xs.  Clearly, this implementation of #dyncode("list_map") is not
tail-recursive.\

")#comment("para")

</sect2><!--id="list_map"-->

<sect2 id="list_zip">
#title("Zipping: #dyncode("list_zip")")

#para("\

Given two lists xs and ys of the types #stacode("list(T1, I)") and
#stacode("list(T2, I)") for some types T1 and T2 and integer I, respectively,
#dyncode("list_zip(xs, ys)") returns a list zs of the type #stacode("list((T1,T2), I)").

#atscode("\
fun{
a,b:t@ype
} list_zip
  {n:nat} .<n>.
(
  xs: list (a, n), ys: list (b, n)
) : list ((a, b), n) =
(
  case+ (xs, ys) of
  | (list_cons (x, xs),
     list_cons (y, ys)) =>
      list_cons ((x, y), list_zip (xs, ys))
  | (list_nil (), list_nil ()) => list_nil ()
) (* end of [list_zip] *)
")

Each element z in zs equals the pair (x, y), where x and y are the
corresponding elements in xs and ys, respectively.  Clearly, this
implementation of #dyncode("list_zip") is not tail-recursive.\

")#comment("para")

</sect2><!--id="list_zip"-->

<sect2 id="list_zipwith">
#title("Zipping with: #dyncode("list_zipwith")")

#para("\

Given two lists xs and ys of the types #stacode("list(T1, I)") and
#stacode("list(T2, I)") for some types T1 and T2 and integer I,
respectively, and a closure function f of the type #stacode("(T1, T2)
-&lt;cloref1&gt; T3") for some type T3, #dyncode("list_zipwith(xs, ys, f)")
returns a list zs of the type #stacode("list(T3, I)"):

#atscode("\
fun{
a,b:t@ype
}{c:t@ype
} list_zipwith
  {n:nat} .<n>.
(
  xs: list (a, n)
, ys: list (b, n)
, f: (a, b) -<cloref1> c
) : list (c, n) = case+ (xs, ys) of
  | (list_cons (x, xs),
     list_cons (y, ys)) =>
      list_cons (f (x, y), list_zipwith (xs, ys, f))
  | (list_nil (), list_nil ()) => list_nil ()
// end of [list_zipwith]
")

Each element z in zs equals f(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
#dyncode("list_zipwith") is not tail-recursive.
")#comment("para")

</sect2><!--id="list_zipping_with"-->

</sect1><!--id="example_function_templates_on_lists_redux"-->

<!-- ****** ****** -->

<sect1 id="example_mergesort_redux">
#title("Example: Mergesort on Lists (Redux)")

#para('\

I have previously presented an <xref linkend="example_mergesort"/>
that are formed with the constructors #dyncode("list0_nil") and
#dyncode("list0_cons").  In this section, I give an implementation of
mergesort on lists formed with the constructors #dyncode("list_nil") and
#dyncode("list_cons"). This implementation is based on the same algorithm
as the previous one but it assigns a type to the implemented sorting
function that guarantees the function to be length-preserving, that is, the
function always returns a list of the same length as the list it sorts.

')#comment("para")

#para("\
The following defined function #dyncode("merge") combines two
ordered list (according to a given ordering) into a single ordered list:

#atscode("\
typedef lte (a:t@ype) = (a, a) -> bool

fun{
a:t@ype
} merge
  {m,n:nat} .<m+n>.
(
  xs: list (a, m), ys: list (a, n), lte: lte a
) : list (a, m+n) =
  case+ xs of
  | list_nil () => ys
  | list_cons (x, xs1) =>
    (
    case+ ys of
    | list_nil () => xs
    | list_cons (y, ys1) =>
        if x \lte y then
          list_cons (x, merge (xs1, ys, lte))
        else
          list_cons (y, merge (xs, ys1, lte))
        // end of [if]
    ) // end of [list_cons]
// end of [merge]
")

Clearly, the type assigned to #dyncode("merge") indicates that the function
returns a list whose length equals the sum of the lengths of the two input
lists. Note that a termination metric is present for verifying that
#dyncode("merge") is a terminating function.\

")#comment("para")

#para("\

The following defined function #dyncode("mergesort") mergesorts a
list according to a given ordering:

#atscode("\
fun{
a:t@ype
} mergesort{n:nat}
(
  xs: list (a, n), lte: lte a
) : list (a, n) = let
  fun msort
    {n:nat} .<n,n>.
  (
    xs: list (a, n), n: int n, lte: lte a
  ) : list (a, n) =
    if n >= 2 then split (xs, n, lte, n/2, list_nil) else xs
  // end of [msort]
  and split
    {n:int | n >= 2}{i:nat | i <= n/2} .<n,i>.
  (
    xs: list (a, n-n/2+i)
  , n: int n, lte: lte a, i: int i, xsf: list (a, n/2-i)
  ) : list (a, n) =
    if i > 0 then let
      val+ list_cons (x, xs) = xs
    in
      split (xs, n, lte, i-1, list_cons (x, xsf))
    end else let
      val xsf = list_reverse<a> (xsf) // make sorting stable!
      val xsf = list_of_list_vt (xsf) // linear list -> nonlinear list
      val xsf = msort (xsf, n/2, lte) and xs = msort (xs, n-n/2, lte)
    in
      merge (xsf, xs, lte)
    end // end of [if]
  // end of [split]
  val n = list_length<a> (xs)
in
  msort (xs, n, lte)
end // end of [mergesort]
")

The type assigned to #dyncode("mergesort") indicates that
#dyncode("mergesort") returns a list of the same length as its input list.
The two inner functions #dyncode("msort") and #dyncode("split") are
defined mutually recursively, and the termination metrics for them are
pairs of natural numbers that are compared according to the standard
lexicographic ordering on integer sequences. The type assigned to
#dyncode("msort") clearly indicates that its integer argument is required
to be the length of its list argument, and a mismatch between the two
surely results in a type-error.  The type assigned to #dyncode("split") is
particularly informative, depicting a relation between the arguments and
the return value of the function that can be of great help for someone
trying to understand the code.  The function #dyncode("list_reverse")
returns a linear list that is the reverse of its input, and the cast
function #dyncode("list_of_list_vt") turns a linear list into a nonlinear
one (while incuring no cost at run-time). I will explain what linear lists
are elsewhere.\

")#comment("para")

#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DEPDTREF/mergesort.dats", "on-line").
")

</sect1><!--id="example_mergesort_redux"-->

<!-- ****** ****** -->

<sect1
id="sequentiality_of_pattern_matching"
>#title("Sequentiality of Pattern Matching")

#para("\

In ATS, pattern matching is performed sequentially at run-time. In other
words, a clause is selected only if a given value matches the pattern
guard associated with this clause but the value fails to match the pattern
associated with any clause ahead of it. Naturally, one may expect that the
following implementation of #dyncode("list_zipwith") also typechecks:

#atscode("\
fun{
a1,
a2:t@ype
}{b:t@ype
} list_zipwith
  {n:nat}
(
  xs1: list (a1, n)
, xs2: list (a2, n)
, f: (a1, a2) -<cloref1> b
) : list (b, n) =
  case+ (xs1, xs2) of
  | (list_cons (x1, xs1),
     list_cons (x2, xs2)) =>
    (
      list_cons{b}(f (x1, x2), list_zipwith<a1,a2><b> (xs1, xs2, f))
    )
  | (_, _) => list_nil (*void*)
// end of [list_zipwith]
")

This, however, is not the case. In ATS, typechecking clauses is done
nondeterministically (rather than sequentially). In this example, the
second clause fails to typecheck as it is done without the assumption of
the given pair #dyncode("(xs1, xs2)") failing to match the pattern
guard associated with the first clause.  The second clause can be modified
slightly as follows to pass typechecking:

#atscode("\
  | (_, _) =>> list_nil ()
")

The use of the symbol #keycode("=>>") (in place of #keycode("=>"))
indicates to the typechecker that this clause needs to be typechecked under
the sequentiality assumption that the given value matching it does not
match the pattern guards associated with any previous clauses. Therefore,
when the modified second clause is typechecked, it can be assumed that the
pair #dyncode("(xs1, xs2)") matching the pattern #dyncode("(_, _)") must
match one of the following three patterns:

<itemizedlist>

<listitem>
#para("
#dyncode("(list_cons (_, _), list_nil ())")
")
</listitem>

<listitem>
#para("
#dyncode("(list_nil (), list_cons (_, _))")
")
</listitem>

<listitem>
#para("
#dyncode("(list_nil (), list_nil ())")
")
</listitem>

</itemizedlist>

Given that #dyncode("xs1") and #dyncode("xs2") are of the same length,
the typechecker can readily infer that #dyncode("(xs1, xs2)") cannot match
either of the first two patterns. After these two patterns are ruled out,
typechecking is essentially done as if the second clause was written as follows:

#atscode("\
  | (list_nil (), list_nil ()) => list_nil ()
")

")#comment("para")

#para("\

One may be wondering why typechecking clauses is not required to be
done sequentially by default. The simple reason is that this requirement,
if fully enforced, can have a great negative impact on the efficiency of
typechecking. Therefore, it is a reasonable design to provide the
programmer with an explict means to occasionally make use of the
sequentiality assumption needed for typechecking a particular clause.
")

</sect1><!--id="sequentiality_of_pattern_matching"-->

<!-- ****** ****** -->

<sect1
id="example_fun_red-black_trees"
xreflabel="implementation of functional red-black trees"
>#title("Example: Functional Red-Black Trees")

#para('\

A red-black tree is defined as a binary tree such that each node in it is
colored red or black and every path from the root to a leaf has the same
number of black nodes while containing no occurrences of two red nodes in a
row.  Clearly, the length of a longest path in each red-black tree is
bounded by 2 times the length of a shortest path in it. Therefore,
red-black trees are a family of balanced trees. The number of black nodes
occurring on each path in a red-black tree is often referred to as the
#emphasis("black height") of the tree.

')

#para('\

Formally, a datatype precisely for red-black trees can be declared in ATS
as follows:

')

#atscode('\
\#define BLK 0
\#define RED 1
sortdef clr = {c:nat | c <= 1}

datatype rbtree
  (a:t@ype+, int(*clr*), int(*bh*)) =
  | rbtree_nil (a, BLK, 0)
  | {c,cl,cr:clr | cl <= 1-c; cr <= 1-c} {bh:nat}
    rbtree_cons (a, c, bh+1-c) of (int c, rbtree (a, cl, bh), a, rbtree (a, cr, bh))
// end of [rbtree]
')

#para('\

The color of a tree is the color of its root node or is black if the tree
is empty.  Given a type T, a color C (represented by a integer) and an
integer BH, the type #stacode("rbtree(T, C, BH)") is for red-black trees
carrying elements of the type T that is of the color C and the black height
BH.

')

#para('\

When implementing various operations (such as insertion and deletion) on a
red-black tree, we often need to first construct intermediate trees that
contain color violations caused by a red node being followed by another red
node and then employ tree rotations to fix such violations. This need makes
the above datatype #stacode("rbtree") too rigid as it cannot be assigned to
any intermediate trees containing color violations. To address this issue,
we can declare #stacode("rbtree") as follows:

')

#atscode('\
datatype rbtree
(
  a:t@ype+
, int // color
, int // black height
, int // violations
) =
  | rbtree_nil (a, BLK, 0, 0) of ()
  | {c,cl,cr:clr}{bh:nat}{v:int}
      {c==BLK && v==0 || c == RED && v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of
    (
      int c, rbtree0 (a, cl, bh), a, rbtree0 (a, cr, bh)
    ) (* end of [rbtree_cons] *)
// end of [rbtree]

where rbtree0 (a:t@ype, c:int, bh:int) = rbtree (a, c, bh, 0)

')

#para('\

We count each occurrence of two red nodes in a row as one color violation.
Given a type T, a color C (represented by a integer), an integer BH and an
integer V, the type #stacode("rbtree(T, C, BH, V)") is for trees carrying
elements of the type T that is of the color C and the black height BH and
contains exactly V color violations. Therefore, the type
#stacode("rbtree(T, C, BH, 0)") is for valid red-black trees (containing no
color violations).

')

#para('\

Given a tree containing at most one color violation, an element and another
tree containing no violations, the following operation constructs a valid
red-black tree:

')

#atscode('\
fn{
a:t@ype
} insfix_l // right rotation for fixing left insertion
  {cl,cr:clr} {bh:nat} {v:nat} (
  tl: rbtree (a, cl, bh, v), x0: a, tr: rbtree (a, cr, bh, 0)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK; \#define R RED; \#define cons rbtree_cons
in
  case+ (tl, x0, tr) of
  | (cons (R, cons (R, a, x, b), y, c), z, d) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // shallow rot
  | (cons (R, a, x, cons (R, b, y, c)), z, d) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // deep rotation
  | (a, x, b) =>> cons (B, a, x, b)
end // end of [insfix_l]
')

#para('\

By simply reading the interface of #dyncode("insfix_l"), we can see that the
two tree arguments are required to be of the same black height bh for some
natural number bh and the returned tree is of the black height bh+1.

')

#para('\

The following operation #dyncode("insfix_r") is just the mirror image of
#dyncode("insfix_l"):

')

#atscode('\
fn{
a:t@ype
} insfix_r // left rotation for fixing right insertion
  {cl,cr:clr} {bh:nat} {v:nat} (
  tl: rbtree (a, cl, bh, 0), x0: a, tr: rbtree (a, cr, bh, v)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK; \#define R RED; \#define cons rbtree_cons
in
  case+ (tl, x0, tr) of
  | (a, x, cons (R, b, y, cons (R, c, z, d))) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // shallow rot
  | (a, x, cons (R, cons (R, b, y, c), z, d)) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // deep rotation
  | (a, x, b) =>> cons (B, a, x, b)
end // end of [insfix_r]
')

#para('\

The preparation for implementing insertion on a red-black tree is all done
by now, and we are ready to see an implementation of insertion guaranteeing
that the tree obtained from inserting an element into a given red-black
tree is always a valid red-black tree itself. This guarantee is precisely
captured in the following interface for insertion:

')

#atscode('\
extern
fun{
a:t@ype
} rbtree_insert
  {c:clr} {bh:nat}
(
  t: rbtree0 (a, c, bh), x0: a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)
')

#para('\

Interestingly, this interface also implies that the tree returned by a call
to #dyncode("rbtree_insert") is always black. The code presented below
gives an implementation of #dyncode("rbtree_insert"):

')

#atscode('\
implement{a}
rbtree_insert
  (t, x0, cmp) = let
//
\#define B BLK
\#define R RED
\#define nil rbtree_nil
\#define cons rbtree_cons
//
fun ins
  {c:clr}{bh:nat} .<bh,c>.
(
  t: rbtree0 (a, c, bh), x0: a
) :
[
  cl:clr;v:nat | v <= c
] rbtree (a, cl, bh, v) =
(
  case+ t of
  | nil ((*void*)) =>
      cons{..}{..}{..}{0} (R, nil, x0, nil)
  | cons (c, tl, x, tr) => let
      val sgn = compare (x0, x, cmp)
    in
      if sgn < 0 then let
        val [cl,v:int] tl = ins (tl, x0)
      in
        if c = B then insfix_l (tl, x, tr)
          else cons{..}{..}{..}{cl} (R, tl, x, tr)
        // end of [if]
      end else if sgn > 0 then let
        val [cr,v:int] tr = ins (tr, x0)
      in
        if c = B then insfix_r (tl, x, tr)
          else cons{..}{..}{..}{cr} (R, tl, x, tr)
        // end of [if]
      end else t // end of [if]
    end // end of [cons]
) (* end of [ins] *)
//
val t = ins (t, x0)
//
in
  case+ t of cons (R, tl, x, tr) => cons (B, tl, x, tr) | _ =>> t
end // end of [rbtree_insert]
')

#para('\

Note that the type assigned to the inner function #dyncode("ins") is so
informative that it literally gives an formal explanation about the way in
which insertion works on a red-black tree. Many a programmer implements
red-black trees by simply following an algorithm written in some format of
pseudo code while having little understanding about the innerworkings of
the algorithm. For instance, if the above inner function #dyncode("ins") is
implemented in C, few programmers are likely to see that the function
always maintain the black height of a given red-black tree after insertion
but may introduce one color violation if the root of the tree is red. On
the other hand, knowing this invariant is essential to gaining a thorough
understanding of the insertion algorithm on red-black trees.

')

#para('\

The insertion operation implemented above does not insert an element if it
is already in the given red-black tree. It may be desirable to require that
the operation inform the caller if such a case occurs. For instance, an
exception can be raised for this purpose. An alternative is to give
#dyncode("rbtree_insert") a call-by-reference argument so that a flag can be
returned in it to indicate whether the element to be inserted is actually
inserted. I will explain elsewhere what call-by-reference is and how it is
supported in ATS.

')

#para('\

Often deleting an element from a binary search tree is significantly more
difficult to implement than inserting one.  This is especially so in the
case of a red-black tree.  I refer the interested reader to the libats
library of ATS for some code implementing a deletion operation on red-black
trees that can guarantee based on types each tree returned by the operation
being a valid red-black tree (containing no color violations).

')

#para("\

Please find the entire code in this section plus some additional code for
testing #mycodelink("CHAP_DEPDTREF/rbtree.dats", "on-line").

")

</sect1><!--id="example_fun_red-black_trees"-->

</chapter><!--id="datatype_refinement"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
