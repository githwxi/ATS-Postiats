%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="preparation_for_starting"
>
#title("Preparation for Starting")

#para("\

It is likely that you want to write programs in the programming language
you are learning.  You may also want to try some of the examples included
in this book and see what really happens. So I will first show you how to
write in ATS a single-file program, that is, a program contained in a
single file, and compile it and then execute it.\

")

<sect1
id="a_running_program"
>
#title("A Running Program")

#para('\
The following example is a program in ATS that prints out (onto the
console) the string "Hello, world!" plus a newline before it terminates:

#atscode('\
val _ = print ("Hello, world!\\\n")

implement main0 () = () // a dummy for [main]
')

The keyword #dyncode("val") initiates a binding between the variable
#dyncode("_") (underscore) and the function call #dyncode('print ("Hello,
world!\\\n")').  However, this binding is never used after it is
introduced; its sole purpose is for the call to the #dyncode("print")
function to get evaluated.  ')#comment("para")

#para("\

The function #dyncode("main0") is a slight variant of another function
named #dyncode("main"), which is of certain special meaning in ATS. For a
programmer who knows the C or Java programming language, I simply point out
that the role of #dyncode("main") is essentially the same as its
counterpart of the same name in C or Java.  The keyword
#dyncode("implement") initiates the implementation of a function whose
interface has already been declared elsewhere. Following is the declared
interface for #dyncode("main0") in ATS:

#atscode("\
fun main0 (): void
")

which indicates that #dyncode("main0") is a nullary function, that is, a
function taking no arguments, and it returns no value (or it returns the
void value). The double slash symbol (#dyncode("//")) initiates a comment
that terminates at the end of the current line.\

")#comment("para")

#para("\
Suppose that you have already installed the ATS programming language
system. You can issue the following command-line to generate an executable
named <filename>hello</filename> in the current working directory:

<informalexample><programlisting>
<command>atscc</command> -o hello hello.dats
</programlisting></informalexample>

where <filename>hello.dats</filename> refers to a file containing the above
program.  The command #command("atscc") is essentially a convenience
wrapper around the command #command("atsopt"), which triggers the process
of typechecking and compiling ATS programs. Note that #command("atscc") and
#command("atsopt") may actually be given the names #command("patscc") and
#command("patsopt"), respectively, in certain installations of ATS.  The filename
extension #emphasis(".dats") should not be altered as it has already been
assigned a special meaning that the compilation command #command("atscc")
recognizes. Another special filename extension is #emphasis(".sats"), which
we will soon encounter.\

")#comment("para")

</sect1><!--id="a_running_example"-->

<!-- ****** ****** -->

<sect1
id="a_template_for_single-file_programs"
>

#title("A Template for Single-File Programs")

#para("
The following code template, which is available
#mycodelink("CHAP_START/mytest.dats", "on-line"), is designed for constructing a
single-file program in ATS:

#atscode('\
(*
**
** A template for single-file ATS programs
**
*)

(* ****** ****** *)
//
\#include "share/atspre_define.hats"
\#include "share/atspre_staload.hats"
//
(* ****** ****** *)

//
// please write you program in this section
//

(* ****** ****** *)

implement main0 () = () // a dummy implementation for [main]

')#comment("atscode")

The line starting with the keyword #dyncode("\#include") enables the ATS
compiler #command("atsopt") to gain access to certain external library
packages and the definitions of various library functions. I will cover
elsewhere in the book the topic on making use of library code in ATS.\

")#comment("para")

</sect1><!--id="a_template_for_single_file_programs"-->

<!-- ****** ****** -->

<sect1
id="a_makefile_template"
>
#title("A Makefile Template")

#para('\

The following Makefile template, which is available
#mycodelink("CHAP_START/Makefile_template", "on-line"), is provided to help
you construct your own Makefile for compiling ATS programs. If you are not
familiar with the #command("make") utility, you could readily find plenty
resources on-line to help yourself learn it.

#atscode('\
\#\#\#\#\#\#
\#
\# Note that
\# certain installations require the following changes:
\#
\# atscc -> patscc
\# atsopt -> patsopt
\# ATSHOME -> PATSHOME
\#
\#\#\#\#\#\#

ATSHOMEQ="$(ATSHOME)"

\#\#\#\#\#\#

ATSCC=$(ATSHOMEQ)/bin/atscc
ATSOPT=$(ATSHOMEQ)/bin/atsopt

\#\#\#\#\#\#

\#
\# HX: Please uncomment the one you want, or skip it entirely
\#
ATSCCFLAGS=
\#ATSCCFLAGS=-O2
\#
\# \'-flto\' enables link-time optimization such as inlining lib functions
\#
\#ATSCCFLAGS=-O2 -flto
\#

\#\#\#\#\#\#

cleanall::

\#\#\#\#\#\#

\#
\# Please uncomment the following three lines and replace the name [foo]
\# with the name of the file you want to compile
\#

\# foo: foo.dats ; \\\\
\#   $(ATSCC) $(ATSCCFLAGS) -o $@ $< || echo $@ ": ERROR!!!"
\# cleanall:: ; $(RMF) foo

\#\#\#\#\#\#

\#
\# You may find these rules useful
\#

\# %_sats.o: %.sats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"
\# %_dats.o: %.dats ; $(ATSCC) $(ATSCCFLAGS) -c $< || echo $@ ": ERROR!!!"

\#\#\#\#\#\#

RMF=rm -f

\#\#\#\#\#\#

clean:: ; $(RMF) *~
clean:: ; $(RMF) *_?ats.o
clean:: ; $(RMF) *_?ats.c

cleanall:: clean

\#\#\#\#\#\# end of [Makefile] \#\#\#\#\#\#
')#comment("atscode")
')#comment("para")

</sect1><!--id="a_makefile_template"-->

</chapter><!--"preparation_for_starting"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
