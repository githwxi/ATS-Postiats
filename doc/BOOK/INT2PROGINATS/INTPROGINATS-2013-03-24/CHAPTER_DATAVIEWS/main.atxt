%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="dataviews">
#title("Dataviews as Linear Dataprops")

#para("\

The at-views of the form T@L for types T and addresses L are building
blocks for constructing other forms of views. One mechanism for putting
together such building blocks is by declaring dataviews, which is mostly
identical to declaring dataprops. I now present in this chapter some
commonly encountered dataviews and their uses.

")

#para('\

Please find #mycodelink("CHAPTER_DATAVIEWS/", "on-line") the code presented
for illustration in this chapter.

')

<sect1>
#title("Optional Views")
#para("\

The dataview #code("option_v") is declared as follows:

")

#atscode('\
dataview option_v (v:view+, bool) =
  | Some_v (v, true) of (v) | None_v (v, false) of ()
// end of [option_v]
')

#para('\

By the declaration, the dataview #code("option_v") is covariant in its
first argument and there are two proof constructors associated with it:
#code("Some_v") and #code("None_v").  Given a view V, #code("option_v")(V,
b) is often called an optional view, where b is a boolean. Clearly, a proof
of the view #code("option_v")(V, #code("true")) contains a proof of the
view V while a proof the view #code("option_v")(V, #code("false")) contains
nothing. As an example, let us take a look at the following function
template interface:

')

#atscode('\
fun{a:t@ype}
ptr_alloc_opt (): [l:addr] (option_v (a? @ l, l > null) | ptr l)
')

#para('\

Given a type T, the function #code("ptr_alloc_opt")&lt;T&gt; returns a
pointer paired with a proof of an optional view; if the returned pointer is
not null, then the proof can be turned into a proof of the view T?@L, where
L is the location to which the pointer points; otherwise, there is no
at-view associated with the returned pointer.

')

#para('\

To see another example, let us assume that #code("get_width") is given the
interface below:

')

#atscode('\
fun get_width (x: &window): int
')

#para('\

where #code("window") is some (unboxed) abstract type. One may
think that #code("get_width") returns the width of a window object.
The following code shows a typical use of an optional view:

')

#atscode('\
viewdef optat
  (a:t@ype, l:addr) = option_v (a @ l, l > null)
// end of [optat]

fun get_width_alt {l:addr} (
  pf: !optat (int?, l) >> optat (int, l)
| x: &window, p: ptr l
) : void =
  if p > null then let
    prval Some_v (pf1) = pf
    val () = !p := get_width (x)
  in
    pf := Some_v (pf1)
  end else let
    prval None_v () = pf in pf := None_v ()
  end // end of [val]
// end of [get_width_alt]
')

#para('\

The function #code("get_width_alt") is a variation of #code("get_width").
In addtion to the window object, it takes a pointer which, if not null,
points to the location where the width information should be stored.

')

#para("\

Please find the entirety of the above presented code
#mycodelink("CHAPTER_DATAVIEWS/optview.dats", "on-line").

")

</sect1>#comment("sect1/id=optional_views")

<sect1>
#title("Linear Arrays")

#para('\

Unlike in most programming languages, arrays are not a primitive data
structure in ATS. More specifically, persistent arrays can be implemented
based on linear arrays, which allow for being freed safely by the
programmer, and linear arrays can be implemented based on
at-views. Intuitively, the view for an array containing N elements of type
T consists of N at-views: T@L#sub("0"), T@L#sub("1"), ..., and
T@L#sub("N-1"), where L#sub("0") is the starting address of the array and
each subsequent L equals the previous one plus the size of T, that is, the
number of bytes needed to store a value of the type T. The following
declared dataview #code("array_v") precisely captures the intuituion:

')

#atscode('\
dataview array_v
  (a:t@ype+, int(*size*), addr(*beg*)) =
  | {n:nat} {l:addr}
    array_v_cons (a, n+1, l) of (a @ l, array_v (a, n, l+sizeof(a)))
  | {l:addr} array_v_nil (a, 0, l)
// end of [array_v]
')

#para('\

Given a type T, an integer N and an address L, #code("array_v")(T, N, L) is
a view for the array starting at L that contains N elements of the type T.
As can be readily expected, the function templates for array accessing and
array updating are given the following interfaces:

')

#atscode('\
fun{a:t@ype}
arrget {n,i:nat | i < n} {l:addr}
  (pf: !array_v (a, n, l) | p: ptr l, i: int i): a
// end of [arrget]

fun{a:t@ype}
arrset {n,i:nat | i < n} {l:addr}
  (pf: !array_v (a, n, l) | p: ptr l, i: int i, x: a): void
// end of [arrset]
')

#para('\

Before implementing #code("arrget") and #code("arrset"), I present as
follows some code that implements a function template to access the first
element of a nonempty array:

')

#atscode('\
fun{a:t@ype}
arrgetfst {n:pos} {l:addr} (
  pf: !array_v (a, n, l) | p: ptr l
) : a = x where {
  prval array_v_cons (pf1, pf2) = pf
  // pf1: a @ l; pf2: array_v (a, n-1, l+sizeof(a))
  val x = !p
  prval () = pf := array_v_cons (pf1, pf2)
} // end of [arrgetfst]
')

#para('\

Obviously, the function template #code("arrget") can be implemented
based on #code("arrgetfst"):

')

#atscode('\
implement{a}
arrget (pf | p, i) =
  if i > 0 then let
    prval array_v_cons (pf1, pf2) = pf
    val x = arrget (pf2 | p+sizeof<a>, i-1)
    prval () = pf := array_v_cons (pf1, pf2)
  in
    x
  end else
    arrgetfst (pf | p)
  // end of [if]
')

#para('\

This implementation is of time-complexity O(n), and it is tail-recursive
(after the proofs are erased). However, the very point of having arrays is
to support O(1)-time accessing and updating operations. My initial effort
spent on implementing such operations immediately dawned on me the need to
construct proof functions for supporting view changes (of no run-time cost).

')

#para('\

Clearly, an array starting at L that contains N elements of type T can also
be thought of as two arrays: one starting at L that contains I elements while
the other starting at L+I*sizeof(T) that contains N-I elements, where I is
an natural number less that or equal to N. Formally, this statement can be
encoded in the type of the proof function #code("array_v_split"):

')

#atscode('\
prfun array_v_split
  {a:t@ype} {n,i:nat | i <= n} {l:addr} {ofs:int} (
  pfmul: MUL (i, sizeof(a), ofs), pfarr: array_v (a, n, l)
) : (array_v (a, i, l), array_v (a, n-i, l+ofs))
')

#para('\

The other direction of the above statement can be encoded in the type of
the proof function #code("array_v_unsplit"):

')

#atscode('\
prfun array_v_unsplit
  {a:t@ype} {n1,n2:nat} {l:addr} {ofs:int} (
  pfmul: MUL (n1, sizeof(a), ofs)
, pf1arr: array_v (a, n1, l), pf2arr: array_v (a, n2, l+ofs)
) : array_v (a, n1+n2, l)
')

#para('\

With #code("array_v_split") and #code("array_v_unsplit"), we can readily
give implementations of #code("arrget") and #code("arrset") that are
O(1)-time:

')

#atscode('\
implement{a}
arrget (pf | p, i) = x where {
  val tsz = int1_of_size1 (sizeof<a>)
  val (pfmul | ofs) = i imul2 tsz
  prval (pf1, pf2) = array_v_split {a} (pfmul, pf)
  prval array_v_cons (pf21, pf22) = pf2
  val x = ptr_get1<a> (pf21 | p+ofs)
  prval pf2 = array_v_cons (pf21, pf22)
  prval () = pf := array_v_unsplit {a} (pfmul, pf1, pf2)
} // end of [arrget]

implement{a}
arrset (pf | p, i, x) = () where {
  val tsz = int1_of_size1 (sizeof<a>)
  val (pfmul | ofs) = i imul2 tsz
  prval (pf1, pf2) = array_v_split {a} (pfmul, pf)
  prval array_v_cons (pf21, pf22) = pf2
  val () = ptr_set1<a> (pf21 | p+ofs, x)
  prval pf2 = array_v_cons (pf21, pf22)
  prval () = pf := array_v_unsplit {a} (pfmul, pf1, pf2)
} // end of [arrset]
')

#para('\

Note that the function #code("int1_of_size1") is called to turn a size
(i.e., an integer of the type #code("size_t")) into an int (i.e., an
integer of the type #code("int")). Of course, the proof functions
#code("array_v_split") and #code("array_v_split") are still to be
implemented, which I will do when covering the topic of view change.

')

#para('\

Given a type T and a natural number N, a proof of the view
#code("array_v")(T?, N, L) for some address L can be obtained and released
by calling the functions #code("malloc") and #code("free"), respectively,
which are to be explained in details elsewhere. I now give as follows an
implemention of a function template for array intialization:

')

#atscode('\
typedef natLt (n:int) = [i:nat | i < n] int (i)

fun{a:t@ype}
array_ptr_tabulate
  {n:nat} {l:addr} (
  pf: !array_v (a?,n,l) >> array_v (a,n,l)
| p: ptr (l), n: int (n), f: natLt(n) -<cloref1> a
) : void = let
  fun loop {i:nat | i <= n} {l:addr} .<n-i>. (
    pf: !array_v (a?,n-i,l) >> array_v (a,n-i,l)
  | p: ptr l, n: int n, f: natLt(n) -<cloref1> a, i: int i
  ) : void =
    if i < n then let
      prval array_v_cons (pf1, pf2) = pf
      val () = !p := f (i)
      val () = loop (pf2 | p+sizeof<a>, n, f, i+1)
    in
      pf := array_v_cons (pf1, pf2)
    end else let
      prval array_v_nil () = pf in pf := array_v_nil {a} ()
    end // end of [if]
  // end of [loop]
in
  loop (pf | p, n, f, 0)
end // end of [array_ptr_tabulate]
')

#para('\

Given a natural number n, the type #code("natLt")(n) is for all natural
numbers less than n. Given a type T, the function
#code("array_ptr_tabulate")&lt;T&gt; takes a pointer to an uninitialized
array, the size of the array and a function f that maps each natural number
less than n to a value of the type T, and it initializes the array with the
sequence of values of f(0), f(1), ..., and f(n-1). In other words, the
array contains a tabulation of the given function f after the
initialization is over.

')

#para('\

Given a type T and an integer N, @[T][N] is a built-in type in ATS for N
consecutive values of the type T. Therefore, the at-view @[T][N]@L for any
given address L is equivalent to the array-view #code("array_v")(T, N, L).
By making use of the feature of call-by-reference, we can also assign the
following interfaces to the previously presented functions #code("arrget")
and #code("arrset"):

')

#atscode('\
fun{a:t@ype}
arrget {n,i:nat | i < n} (A: &(@[a][n]), i: int i): a

fun{a:t@ype}
arrset {n,i:nat | i < n} (A: &(@[a][n]), i: int i, x: a): void
')

#para('\

These interfaces are more concise as they obviate the need to mention
explicitly where the array argument is located.

')

#para("\

Please find the entirety of the above presented code
#mycodelink("CHAPTER_DATAVIEWS/array.dats", "on-line").

")

</sect1>#comment("sect1/id=linear_arrays")


<sect1 id="singly-linked_lists">
#title("Singly-Linked Lists")

#para("
The following dataview #code("slseg_v") captures the notion of a
singly-linked list segment:
")

#atscode('\
dataview
slseg_v (
  a:t@ype+ // covariant argument
, int(*len*)
, addr(*beg*)
, addr(*end*)
) =
  | {l:addr} slseg_v_nil (a, 0, l, l) of ()
  | {n:nat} {l_fst:agz} {l_nxt,l_end:addr}
    slseg_v_cons (a, n+1, l_fst, l_end) of
      ((a, ptr l_nxt) @ l_fst, slseg_v (a, n, l_nxt, l_end))
// end of [slseg]_v
')

#para('\

There are two proof constructors #code("slseg_v_nil") and
#code("slseg_v_cons") associated with #code("slseg_v"), which are
assigned the following types:

')

#atscode('\
slseg_v_nil :
  {a:t@ype} {l:addr} () -> slseg_v (a, 0, l, l)
slseg_v_cons :
  {a:t@ype} {n:nat} {l_fst:agz} {l_nxt,l_end:addr}
  ((a, ptr l_nxt) @ l_fst, slseg_v (a, l_nxt, l_end)) -> slseg_v (a, n+1, l_fst, l_end)
')

#para('\

Note that #code("agz") is a subset sort for addresses that are not null.
Given a type T, a natural number N and two addresses L1 and L2, the view
#code("slseg_v (T, N, L1, L2)") is for a singly-linked list segment
containing N elements of the type T that starts at L1 and finishes at L2.
In the case where L2 is the null pointer, then the list segment is
considered a list as is formally defined below:

')

#atscode('\
viewdef sllst_v
  (a:t@ype, n:int, l:addr) = slseg_v (a, n, l, null)
// end of [sllst_v]
')

#para('\

Given a type T, a pointer pointing to L plus a proof of the view
#code("sllst_v(T, N, L)") for some natural number N is essentially the same
as a pointer to a struct of the following declared type
#code("sllst_struct") in C:

')

#atscode('\
typedef struct sllst {
  T data ; /* [T] matches the corresponding type in ATS */
  struct sllst *next ; /* pointing to the tail of the list */
} sllst_struct ;
')

#para('\

Let us now see a simple example involving singly-linked lists:

')

#atscode('\
fn{a:t@ype}
sllst_ptr_length
  {n:nat} {l:addr} (
  pflst: !sllst_v (a, n, l) | p: ptr l
) : int (n) = let
  fun loop {i,j:nat} {l:addr} .<i>. (
    pflst: !sllst_v (a, i, l) | p: ptr l, j: int (j)
  ) : int (i+j) =
    if p > null then let
      prval slseg_v_cons (pfat, pf1lst) = pflst
      val res = loop (pf1lst | !p.1, j+1) // !p.1 points to the tail
      prval () = pflst := slseg_v_cons (pfat, pf1lst)
    in
      res
    end else let // the length of a null list is 0
      prval slseg_v_nil () = pflst in pflst := slseg_v_nil (); j
    end (* end of [if] *)
  // end of [loop]
in
  loop (pflst | p, 0)
end // end of [sllst_ptr_length]
')

#para('\

The function template #code("sllst_ptr_length") computes the length of a
given singly-linked list. Note that the inner function #code("loop") is
tail-recursive. The above implementation of #code("sllst_ptr_length")
essentially corresponds to the following implementation in C:

')

#atscode('\
int sllst_ptr_length (sllst_struct *p) {
  int res = 0 ;
  while (p != NULL) { res = res + 1 ; p = p->next ; }
  return res ;
} // end of [sllst_ptr_length]
')

#para('\

As another example, the following function template
#code("sllst_ptr_reverse") turns a given linked list into its reverse:

')

#atscode('\
fn{a:t@ype}
sllst_ptr_reverse
  {n:nat} {l:addr} (
  pflst: sllst_v (a, n, l) | p: ptr l
) : [l:addr] (sllst_v (a, n, l) | ptr l) = let
  fun loop
    {n1,n2:nat}
    {l1,l2:addr} .<n1>. (
    pf1lst: sllst_v (a, n1, l1)
  , pf2lst: sllst_v (a, n2, l2)
  | p1: ptr l1, p2: ptr l2
  ) : [l:addr] (sllst_v (a, n1+n2, l) | ptr l) =
    if p1 > null then let
      prval slseg_v_cons (pf1at, pf1lst) = pf1lst
      val p1_nxt = !p1.1
      val () = !p1.1 := p2
    in
      loop (pf1lst, slseg_v_cons (pf1at, pf2lst) | p1_nxt, p1)
    end else let
      prval slseg_v_nil () = pf1lst in (pf2lst | p2)
    end // end of [if]
in
  loop (pflst, slseg_v_nil | p, null)
end // end of [sllst_ptr_reverse]
')

#para('\

By translating the tail-recursive function #code("loop") into a while-loop,
we can readily turn the implementation of #code("sllst_ptr_reverse") in ATS
into the following implementation in C:

')

#atscode('\
sllst_struct *sllst_ptr_reverse (sllst_struct *p) {
  sllst_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p->next ; p->next = res ; res = p ; p = tmp ;
  }
  return res ;
} // end of [sllst_ptr_reverse]
')

#para('\

Let us see yet another example.
List concatenation is a common operation on lists. This time, we first give
an implementation of list concatenation in C:

')

#atscode('\
sllst_struct *sllst_ptr_append
  (sllst_struct *p, sllst_struct *q) {
  sllst_struct *p1 = p ;
  if (p1 == NULL) return q ;
  while (p1->next != NULL) p1 = p1->next ; p1->next = q ;
  return p ;
} // end of [sllst_ptr_append]
')

#para('\

The algorithm is straightforward. If #code("p") is null, then #code("q") is
returned. Otherwise, the last node in the list pointed to by #code("p") is
first found and its field of the name #code("next") then replaced with
#code("q").  This implementation of #code("sllst_ptr_append") in C can be
translated directly into to following one in ATS:

')

#atscode('\
fn{a:t@ype}
sllst_ptr_append
  {n1,n2:nat} {l1,l2:addr} (
  pf1lst: sllst_v (a, n1, l1)
, pf2lst: sllst_v (a, n2, l2)  
| p1: ptr l1, p2: ptr l2
) : [l:addr] (sllst_v (a, n1+n2, l) | ptr l) = let
  fun loop
    {n1,n2:nat}
    {l1,l2:addr | l1 > null} .<n1>. (
    pf1lst: sllst_v (a, n1, l1)
  , pf2lst: sllst_v (a, n2, l2)  
  | p1: ptr l1, p2: ptr l2
  ) : (sllst_v (a, n1+n2, l1) | void) = let
    prval slseg_v_cons (pf1at, pf1lst) = pf1lst
    val p1_nxt = !p1.1
  in
    if p1_nxt > null then let
      val (pflst | ()) = loop (pf1lst, pf2lst | p1_nxt, p2)
    in
      (slseg_v_cons (pf1at, pflst) | ())
    end else let
      val () = !p1.1 := p2
      prval slseg_v_nil () = pf1lst
    in
      (slseg_v_cons (pf1at, pf2lst) | ())
    end (* end of [if] *)
  end // end of [loop]
in
  if p1 > null then let
    val (pflst | ()) = loop (pf1lst, pf2lst | p1, p2)
  in
    (pflst | p1)
  end else let
    prval slseg_v_nil () = pf1lst in (pf2lst | p2)
  end (* end of [if] *)
end // end of [sllst_ptr_append]
')

#para('\

In the above examples, it is evident that the code in ATS is a lot more
verbose than its counterpart in C. However, the former is also a lot more
robust than the latter in the following sense: If a minor change is made to
the code in ATS (e.g., renaming identifiers, reordering function
arguments), it is most likely that a type-error is to be reported when the
changed code is typechecked. On the other hand, the same thing cannot be
said about the code written in C. For instance, the following erroneous
implementation of #code("sllst_ptr_reverse") in C is certainly
type-correct:

')

#atscode('\
/*
** This implementation is *incorrect* but type-correct:
*/
sllst_struct *sllst_ptr_reverse (sllst_struct *p) {
  sllst_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p->next ; res = p ; p->next = res ; p = tmp ;
  }
  return res ;
} // end of [sllst_ptr_reverse]
')

#para('\

I now point out that the dataview #code("slseg_v") is declared here in a
manner that does not address the issue of allocating and freeing list
nodes, and it is done so for the sake of a less involved presentation. A
dataview for singly-linked lists that does handle allocation and
deallocation of list nodes can be found in the libats library of ATS.

')

#para('\

There is another method for handling singly-linked lists in ATS that is
based on the notion of dataviewtype (i.e., linear datatype). When compared
to the one presented above, this alternative is significantly simpler.
However, dataviews are more general and flexible than dataviewtypes, and
there are many common data structures (e.g. doubly-linked lists) that can
only be properly handled with the former in ATS.

')


</sect1>#comment("sect1/id=singly-linked_lists")

<sect1 id="view_change">
#title("Proof Functions for View Changes")

#para("\

By the phrase #emph("view change"), I mean applying a function to proofs of
a set of views to turn them into proofs of another set of views.  As this
function itself is a proof function, there is no run-time cost associated
with each view change. For instance, a proof of the at-view int32@L for any
address L can be turned into a proof of a tuple of 4 at-views: int8@L,
int8@L+1, int8@L+2 and int8@L+3, where int32 and int8 are types for 32-bit
and 8-bit integers, respectively. Often more interesting view changes
involve recursively defined proof functions, and I present several of such
cases in the rest of this section.

")

#para("\

When implementing an array subscripting operation of O(1)-time, we need a
proof function to change the view of one array into the views of two
adjacently located arrays and another proof function to do precisely the
opposite. Formally speaking, we need to construct the following two proof
functions #code("array_v_split") and #code("array_v_unsplit"):

")

#atscode('\
extern
prfun array_v_split
  {a:t@ype} {n,i:nat | i <= n} {l:addr} {ofs:int} (
  pfmul: MUL (i, sizeof(a), ofs), pfarr: array_v (a, n, l)
) : (array_v (a, i, l), array_v (a, n-i, l+ofs))

extern
prfun array_v_unsplit
  {a:t@ype} {n1,n2:nat} {l:addr} {ofs:int} (
  pfmul: MUL (n1, sizeof(a), ofs)
, pf1arr: array_v (a, n1, l), pf2arr: array_v (a, n2, l+ofs)
) : array_v (a, n1+n2, l)
')

#para('\

An implementation of #code("array_v_split") is given as follows:

')

#atscode('\
implement
array_v_split {a} (pfmul, pfarr) = let
  prfun split
    {n,i:nat | i <= n} {l:addr} {ofs:int} .<i>. (
    pfmul: MUL (i, sizeof(a), ofs), pfarr: array_v (a, n, l)
  ) : (array_v (a, i, l), array_v (a, n-i, l+ofs)) =
    sif i > 0 then let
      prval MULind (pf1mul) = pfmul
      prval array_v_cons (pf1at, pf1arr) = pfarr
      prval (pf1res1, pf1res2) = split (pf1mul, pf1arr)
    in
      (array_v_cons (pf1at, pf1res1), pf1res2)
    end else let
      prval MULbas () = pfmul in (array_v_nil (), pfarr)
    end // end of [sif]
in
  split (pfmul, pfarr)
end // end of [array_v_split]
')

#para('\

Clearly, the proof function #code("split") directly encodes a proof based
on mathematical induction. In addition, an implementation of
#code("array_v_unsplit") is given as follows:

')

#atscode('\
implement
array_v_unsplit {a}
  (pfmul, pf1arr, pf2arr) = let
  prfun unsplit
    {n1,n2:nat} {l:addr} {ofs:int} .<n1>. (
    pfmul: MUL (n1, sizeof(a), ofs)
  , pf1arr: array_v (a, n1, l)
  , pf2arr: array_v (a, n2, l+ofs)
  ) : array_v (a, n1+n2, l) =
    sif n1 > 0 then let
      prval MULind (pf1mul) = pfmul
      prval array_v_cons (pf1at, pf1arr) = pf1arr
      prval pfres = unsplit (pf1mul, pf1arr, pf2arr)
    in
      array_v_cons (pf1at, pfres)
    end else let
      prval MULbas () = pfmul
      prval array_v_nil () = pf1arr
    in
      pf2arr
    end // end of [sif]
in
  unsplit (pfmul, pf1arr, pf2arr)
end // end of [array_v_unsplit]
')

#para('\

The proof function #code("unsplit") also directly encodes a proof based on
mathematical induction.

')

#para('\

Let us now see an even more interesting proof function for performing view
change.  The interface of the proof function #code("array_v_takeout") is
given as follows:

')

#atscode('\
extern
prfun array_v_takeout
  {a:t@ype} {n,i:nat | i < n} {l:addr} {ofs:int} (
  pfmul: MUL (i, sizeof(a), ofs), pfarr: array_v (a, n, l)
) : (a @ l+ofs, a @ l+ofs -<lin,prf> array_v (a, n, l))
')

#para('\

Note that the following type is for a linear proof function that takes a
proof of an at-view to return a proof of an array-view:

')

#atscode('\
a @ l+ofs -<lin,prf> array_v (a, n, l)
')


#para('\

As such a function essentially represents an array with one missing cell,
we may simply say that #code("array_v_takeout") turns the view of an array
into an at-view (for one cell) and a view for the rest of the array.  By
making use of #code("array_v_takeout"), we can give another implementation
of #code("arrget"):

')

#atscode('\
implement{a}
arrget (pf | p, i) = x where {
  val tsz = int1_of_size1 (sizeof<a>)
  val (pfmul | ofs) = i imul2 tsz
  prval (pf1, fpf2) = array_v_takeout {a} (pfmul, pf)
  val x = ptr_get1<a> (pf1 | p+ofs)
  prval () = pf := fpf2 (pf1) // putting the cell and the rest together
} // end of [arrget]
')

#para('
The proof function #code("array_v_takeout") can be implemented as follows:
')

#atscode('\
implement
array_v_takeout
  {a} (pfmul, pfarr) = let
  prfun takeout
    {n,i:nat | i < n} {l:addr} {ofs:int} .<i>. (
    pfmul: MUL (i, sizeof(a), ofs), pfarr: array_v (a, n, l)
  ) : (a @ l+ofs, a @ l+ofs -<lin,prf> array_v (a, n, l)) = let
    prval array_v_cons (pf1at, pf1arr) = pfarr
  in
    sif i > 0 then let
      prval MULind (pf1mul) = pfmul
      prval (pfres, fpfres) = takeout (pf1mul, pf1arr)
    in
      (pfres, llam (pfres) => array_v_cons (pf1at, fpfres (pfres)))
    end else let
      prval MULbas () = pfmul
    in
      (pf1at, llam (pf1at) => array_v_cons (pf1at, pf1arr))
    end // end of [sif]
  end // end of [takeout]
in
  takeout (pfmul, pfarr)
end // end of [array_v_takeout]
')

#para('\

Note that #code("llam") is a keyword for forming linear functons.  Once a
linear function is applied, it is consumed and the resource in it, if not
reclaimed, moves into the result it returns.

')

#para('\

The proof functions presented so far for view changes are all manipulating
array-views. The following one is different in this regard as it combines
two views for singly-linked list segments into one:

')

#atscode('\
prfun slseg_v_unsplit
  {a:t@ype} {n1,n2:nat} {l1,l2,l3:addr} (
  pf1lst: slseg_v (a, n1, l1, l2), pf2lst: slseg_v (a, n2, l2, l3)
) : slseg_v (a, n1+n2, l1, l3)
')

#para('\

The type of #code("slseg_v_unsplit") essentially states that a list segment
from L1 to L2 that is of length N1 and another list segment from L2 to L3
that is of length N2 can be thought of as a list segment from L1 to L3 that
is of length N1+N2. The following implementation of
#code("slseg_v_unsplit") is largely parallel to that of
#code("array_v_unsplit"):

')

#atscode('\
implement
slseg_v_unsplit {a}
  (pf1lst, pf2lst) = let
  prfun unsplit
    {n1,n2:nat} {l1,l2,l3:addr} .<n1>. (
    pf1lst: slseg_v (a, n1, l1, l2), pf2lst: slseg_v (a, n2, l2, l3)
  ) : slseg_v (a, n1+n2, l1, l3) =
    sif n1 > 0 then let
      prval slseg_v_cons (pf1at, pf1lst) = pf1lst
    in
      slseg_v_cons (pf1at, unsplit (pf1lst, pf2lst))
    end else let
      prval slseg_v_nil () = pf1lst in pf2lst
    end // end of [sif]
in
  unsplit (pf1lst, pf2lst)
end // end of [slseg_v_unsplit]
')

#para('\

The reader may find it interesting to give an implementation of
#code("sllst_ptr_append") by making use of #code("slseg_v_unsplit").

')

#para('\

Please find on-line the files #mycodelink("CHAPTER_DATAVIEWS/array.dats",
"array.dats") and #mycodelink("CHAPTER_DATAVIEWS/sllst.dats",
"sllst.dats"), which contains the code employed for illustration in this
section.

')

</sect1>#comment("sect1/id=view_change")

<sect1 id="example_quicksort">
#title("Example: Quicksort")

#para('\

Quicksort is a commonly employed sorting algorithm in practice.  Given an
array of n elements for some n > 0 and an ordering on these elements, the
algorithm chooses one element in a more or less random fashion and then
uses the chosen element as a pivot to shuffle the rest of the array into
two parts separated by the pivot such that one part consists of all the
elements that are less than or equal to the pivot (according to the given
ordering) and the other part consists of the complement, that is, all the
elements that are greater than the pivot; then the algorithm is applied
recursively to each part unless it is empty. It is straightforward to see
that the array is sorted after the algorithm terminates. In terms of
time-complexity, quicksort is quadratic in the worst case and log-linear on
average. Note that quicksort is not a stable sorting algorithm in the sense
that the order of two equal elements may change after sorting.

')

#para('\

The following function #code("npivot") returns the index of the
element chosen to be the pivot:

')

#atscode('\
fun{a:t@ype}
npivot {n:pos} {l:addr} (
  pf: !array_v (a, n, l) | p: ptr l, n: int (n), cmp: cmp (a)
) : natLt (n) = n/2
')

#para('\

For simplicity, the index of the pivot for an array of size n is always n/2
(where integer division is used). Often a more elaborate method is to
choose the index among 0, n/2 and n-1 such that the element stored at that
index is between the elements stored at the other two indexes. Another
possibility is to choose the index of the pivot based on a pseudo random
number generator.

')

#para('\

The function template #code("array_ptr_exch") for exchanging two
elements in a given array is assgined the following interface:

')

#atscode('\
extern
fun{a:t@ype}
array_ptr_exch {n:nat} {l:addr} (
  pf: !array_v (a, n, l) | p: ptr l, i: natLt n, j: natLt n
) : void // end of [array_ptr_exch]
')

#para('\

I give no implementation of #code("array_ptr_exch") here as the reader
should have no difficulty constructing one by now.

')

#para('\

Given an array of elements, its size, an ordering on the elements and a
pivot, the following function template #code("split") turns the array into
two subarrays such that one subarray consists of all the elements in the
array that are less than or equal to the pivot and the other subarray
consists of the complement; it then returns the size of the first subarray
plus proofs of the views of the two subarrays (as well as a proof for
handling multiplication).

')

#atscode('\
extern
fun{a:t@ype}
split {n:nat} {l:addr} (
  pf: array_v (a, n, l) | p: ptr l, n: int n, cmp: cmp a, piv: &a
) : [n1,n2:nat | n1+n2==n] [ofs:int] (
  MUL (n1, sizeof(a), ofs), array_v (a, n1, l), array_v (a, n2, l+ofs) | int n1
) // end of [split]
')

#para('\

I postpone implementing #code("split") for the moment. Instead, let us
first see an implementation of quicksort based on #code("split"):

')

#atscode('\
fun{a:t@ype}
qsort {n:nat} {l:addr} .<n>. (
  pfarr: !array_v (a, n, l) | p: ptr l, n: int (n), cmp: cmp (a)
) : void =
  if n > 0 then let
    val tsz = int1_of_size1 (sizeof<a>)
    val npiv = npivot (pfarr | p, n, cmp)
    val () = array_ptr_exch (pfarr | p, 0, npiv) // move the pivot to the front
//
    val p1 = p+tsz
    prval array_v_cons (pfat, pf1arr) = pfarr
    val (pfmul, pf1arr_lte, pf1arr_gt | n1) = split (pf1arr | p1, n-1, cmp, !p)
// combining the pivot with the first segment
    prval pf1arr_lte = array_v_cons (pfat, pf1arr_lte)
// exchanging the pivot with the last element in the first segment
    val () = array_ptr_exch (pf1arr_lte | p, 0, n1)
// separating the pivot from all the elements in front of it
    prval (pf1arr_lte, pflast) = array_v_split {a} (pfmul, pf1arr_lte)
    val () = qsort (pf1arr_lte | p, n1, cmp) // recursive all to qsort
// combining the pivot with all the elements in front of it
    prval pf1arr_lte = array_v_unsplit {a} (pfmul, pf1arr_lte, pflast)
//
    val (pfmul_alt | ofs) = n1 imul2 tsz
    prval () = mul_isfun (pfmul, pfmul_alt)
    val () = qsort (pf1arr_gt | p1+ofs, n-n1-1, cmp) // recursive call to qsort
// combining the first and the second segments together
    prval () = pfarr := array_v_unsplit {a} (MULind (pfmul), pf1arr_lte, pf1arr_gt)
  in
    // nothing
  end else () // empty array
// end of [qsort]
')

#para('\

The comments given in the implementation of #code("qsort") should make it
reasonably clear as to how quicksort formally operates on a given array.

')

#para('\

Let us now implement the function template #code("split"). Given an array,
one common approach is to have two pointers pointing to the first and last
elements of the array; the front pointer moves forward until an element
that is not less than or equal to the pivot is encountered; the rear
pointer moves backward until an element that is not greater than the pivot
is encountered; the elements pointed to by the front and rear pointers are
exchanged and the process is repeated; the process finishes at the moment
when the front pointer either encounters or crosses over the rear one.  As
it is considerably involved to present an implementation based on this
approach, I will use an alternative one, which I learned from the K&amp;R
book on the C programming language. This alternative approach starts with
two pointers p1 and p2 pointing to the beginning of the given array and
maintains the invariant that each element between p1 and p2 is greater than
the pivot; first p2 moves forward until an element that is less than or
equal to the pivot is encountered; then the elements stored at p1 and p2
are exchanged and both p1 and p2 move forward by one unit; the process
repeats until p2 reaches the end of the array.  For a slightly cleaner
presentation, p1 is represented as a real pointer (p) in the implementation
of the following inner function #code("loop") while p2 is represented as an
integer (k):

')

#atscode('\
implement{a}
split {n} (
  pfarr | p, n, cmp, piv
) = let
  fun loop
    {n1:nat}
    {k:nat | n1+k <= n}
    {l:addr} {ofs:int} .<n-n1-k>. (
    pfmul: MUL (n1, sizeof(a), ofs)
  , pf1arr: array_v (a, n1, l)
  , pf2arr: array_v (a, n-n1, l+ofs)
  | p: ptr (l+ofs), n: int n, n1: int n1, k: int k, cmp: cmp(a), piv: &a
  ) : [n1,n2:nat | n1+n2==n] [ofs:int] (
    MUL (n1, sizeof(a), ofs), array_v (a, n1, l), array_v (a, n2, l+ofs)
  | int (n1)
  ) = // [loop] is tail-recursive
    if n1+k < n then let
      val (pfat, fpf2 | pk) = array_ptr_takeout (pf2arr | p, k)
      val sgn = compare (!pk, piv, cmp)
      prval () = pf2arr := fpf2 (pfat)
    in
      if sgn > 0 then
        loop (pfmul, pf1arr, pf2arr | p, n, n1, k+1, cmp, piv)
      else let
        val () = array_ptr_exch (pf2arr | p, 0, k) // no work is done if k = 0
        prval array_v_cons (pfat, pf2arr) = pf2arr
        prval () = pf1arr := array_v_extend {a} (pfmul, pf1arr, pfat)
      in
        loop (MULind (pfmul), pf1arr, pf2arr | p+sizeof<a>, n, n1+1, k, cmp, piv)
      end (* end of [if] *)
    end else (
      pfmul, pf1arr, pf2arr | n1
    ) // end of [if]
in
  loop (MULbas (), array_v_nil (), pfarr | p, n, 0, 0, cmp, piv)
end // end of [split]
')

#para('\

Note the proof function #code("array_v_extend") is given the following
interface:

')

#atscode('\
prfun array_v_extend
  {a:t@ype} {n:nat} {l:addr} {ofs:int} (
  pfmul: MUL (n, sizeof(a), ofs), pfarr: array_v (a, n, l), pfat: a @ l+ofs
) : array_v (a, n+1, l)
')

#para('\

This proof function can be thought of as a special case of
#code("array_v_unsplit") where the second array is a singleton, that is, it
contains exactly one element.

')

#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAPTER_DATAVIEWS/quicksort.dats", "on-line").
")

</sect1>#comment("sect1/id=example_quicksort")

</chapter><!--id="dataviews"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
