<!--
The file is automatically generated by [atsdoc] from main.atxt.
-->
<!--
Time of Generation: Sun Dec 22 16:38:58 2013
-->
<chapter id="parametric_polymorphism">
<title>Parametric Polymorphism</title>

<para>Code sharing is of paramount importance in programming language
design.  In a typed programming language, we often encounter a situation
where the same functionality is needed for values of different types. For
instance, we need a function to compute the length of a list while the
elements in the list may be characters, integers, strings, etc. Evidently,
we want to avoid implementing such a function for each element type as it
would probably be the worst form of code duplication otherwise. We want to
implement a single function that can be applied to any list to compute the
length of the list. The length-computing function parameterizes over the
element type of a list it is applied to, and it behaves uniformly
regardless what the element type is.  This is a form of code sharing that is
given the name: parametric polymorphism, which should be distinguished from
other forms of polymorphism such as inheritance polymorphism in
object-oriented programming.
</para><!--para-->

<para>The code employed for illustration in this chapter plus some
additional code for testing is available <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_POLYMORPHISM">on-line</ulink>.
</para>

<sect1 id="function_templates">
<title>Function Templates</title>

<para>A function template is a code template that implements a function.
In the following code, two functions are defined to swap values:

<informalexample><programlisting><![CDATA[typedef charint = (char, int)
typedef intchar = (int, char)
fun swap_char_int (xy: charint): intchar = (xy.1, xy.0)
fun swap_int_char (xy: intchar): charint = (xy.1, xy.0)
]]></programlisting></informalexample>


If types are ignored, the bodies of <code>swap_char_int</code> and
<code>swap_int_char</code> are identical. In order to avoid this kind of
code duplication, we can first implement a function template
<code>swap</code> as follows and then implement <code>swap_char_int</code>
and <code>swap_int_char</code> based on <code>swap</code>:

<informalexample><programlisting><![CDATA[fun{a,b:t@ype} swap (xy: (a, b)): (b, a) = (xy.1, xy.0)
fun swap_char_int (xy: charint): intchar = swap<char,int> (xy)
fun swap_int_char (xy: intchar): charint = swap<int,char> (xy)
]]></programlisting></informalexample>


It should be noted that a function template is not a first-class value in
ATS: There is no expression for representing a function template.  The
syntax <code>{a,b:t@ype}</code> following the keyword <code>fun</code> represents
template parameters or arguments. The unusual symbol <code>t@ype</code> is a
sort for static terms representing types of unspecified size, where the
size of a type is the number of bytes needed for representing a value of
the type. There is another sort <code>type</code> in ATS, which is for static
terms representing types of size equal to one word exactly, that is, 4
bytes on a 32-bit machine or 8 bytes on a 64-bit machine.  The syntax
<code>swap&lt;char,int&gt;</code>, where no space is allowed between
<code>swap</code> and <code>&lt;</code> , stands for an instance of the function
template <code>swap</code> in which the parameters <code>a</code> and <code>b</code>
are replaced with <code>char</code> and <code>int</code>, respectively.  The syntax
<code>swap&lt;int,char&gt;</code> is interpreted similarly.
</para><!--para-->

<para>
A different style of implementation of <code>swap</code> is given
as follows:

<informalexample><programlisting><![CDATA[fun{a:t@ype}{b:t@ype} swap2 (xy: (a, b)): (b, a) = (xy.1, xy.0)
]]></programlisting></informalexample>


where the template parameters are given sequentially (instead of
simultaneously). The following code shows how <code>swap2</code> can be
instantiated to form instances:

<informalexample><programlisting><![CDATA[fun swap_char_int (xy: charint): intchar = swap2<char><int> (xy)
fun swap_int_char (xy: intchar): charint = swap2<int><char> (xy)
]]></programlisting></informalexample>


Note that <code>&gt;&lt;</code> is a special symbol (of the name GTLT) and
no space is allowed between <code>&gt;</code> and <code>&lt;</code>.
</para><!--para-->

<para>As another example, a higher-order function template for composing
(closure) functions is given as follows:

<informalexample><programlisting><![CDATA[typedef cfun (t1:t@ype, t2:t@ype) = t1 -<cloref1> t2

fun{a,b,c:t@ype} compose
  (f: cfun (a, b), g: cfun (b, c)):<cloref1> cfun (a, c) = lam x => g(f(x))
// end of [compose]

val plus1 = lam (x:int): int =<cloref1> x+1
val times2 = lam (x:int): int =<cloref1> x*2

val f_2x_1: cfun (int, int) = compose (times2, plus1)
val f_2x_2: cfun (int, int) = compose (plus1, times2)
]]></programlisting></informalexample>


It should be clear that the value <code>f_2x_1</code> represents the
function that multiplies its integer argument by 2 and then adds 1 to it.
Similarly, the value <code>f_2x_2</code> represents the function that adds
1 to its integer argument and then multiplies it by 2.
</para><!--para-->

<para>In ATS, function templates are typechecked but not compiled.  Only
instances of a function template can be compiled. Suppose we have a
function template foo taking one type parameter and two instances
foo&lt;T1&gt; and foo&lt;T2&gt; are used in a program for some types T1 and
T2. In general, one function in C is generated for each instance of foo
when the program is compiled. However, if T1 and T2 have the same name,
then the two instances share one function in C. In particular, if both T1
and T2 are boxed types, which are always given the same name, only one
function in C is generated for them.
</para><!--para-->

<para>Please note that I may simply use the name function to refer to a
function template from now on if no confusion is expected.
</para>

</sect1><!--id="function_templates"-->

<!-- ****** ****** -->

<sect1 id="polymorphic_functions">
<title>Polymorphic Functions</title>

<para>A polymorphic function is rather similar to a function template.
However, the former is a first-class value in ATS while the latter is not.
As an example, the following defined function <code>swap_boxed</code> is
polymorphic:

<informalexample><programlisting><![CDATA[fun swap_boxed {a,b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)
]]></programlisting></informalexample>


The type variables <code>a</code> and <code>b</code> are often referred as
static arguments while <code>xy</code> is a dynamic argument. Here is some
code that makes use of the polymorphic function <code>swap_boxed</code>:

<informalexample><programlisting><![CDATA[val AB = ("A", "B")
val BA1 = swap_boxed {string,string} (AB) // [string] is boxed
val BA2 = swap_boxed (AB) // this is fine, too
]]></programlisting></informalexample>


If <code>swap_boxed</code> is called on a pair of the type (T1, T2) for
some types T1 and T2, both T1 and T2 are required to be boxed. Otherwise, a
type-error is reported. For instance, calling <code>swap_boxed</code> on
<code>(0, 1)</code> yields a type-error as the type <code>int</code> is not
boxed.
</para><!--para-->

<para>When calling a polymorphic function, we often omit passing static
arguments explicitly and expect them to be synthesized by the
compiler. However, there are also occasions, which are not uncommon, where
static arguments need to be supplied explicitly as either they cannot be
successfully synthesized or what is synthesized is not exactly what is
expected.
</para>

<para>It is also possible to pass static arguments sequentially as is
shown in the following style of implementation of a polymorphic function:

<informalexample><programlisting><![CDATA[fun swap2_boxed {a:type} {b:type} (xy: (a, b)): (b, a) = (xy.1, xy.0)

val AB = ("A", "B")
val BA1 = swap2_boxed {string} {string} (AB)
val BA2 = swap2_boxed (AB) // this is fine, too
val BA3 = swap2_boxed {..} {string} (AB) // 1st static argument to be synthesized
val BA4 = swap2_boxed {string} {..} (AB) // 2nd static argument to be synthesized
val BA5 = swap2_boxed {..} {..} (AB) // both arguments to be synthesized
val BA6 = swap2_boxed {...} (AB) // every static argument to be synthesized
]]></programlisting></informalexample>


The special syntax <code>{..}</code> indicates to the typechecker that the
static argument (or arguments) involved in the current application should
be synthesized while the special syntax <code>{...}</code> means that the
rest of static arguments should all be synthesized.
</para><!--para-->

<para>I have seen two kinds of errors involving polymorphic functions that are
extremely common in practice.

<itemizedlist>

<listitem>

<para>The first kind is depicted in the following example:

<informalexample><programlisting><![CDATA[fun swap_boxed {a,b:t@ype} (xy: (a, b)): (b, a) = (xy.1, xy.0)
]]></programlisting></informalexample>


Notice that the sort for type variables <code>a</code> and <code>b</code>
is <code>t@ype</code> (instead of <code>type</code>). While this example
can pass typechecking, its compilation results in an error that may seem
mysterious to many programmers. The simple reason for this error is that
the compiler cannot figure out the size of <code>a</code> and
<code>b</code> when trying to generate code in C as the sort
<code>t@ype</code> is for types of unspecified size.
</para><!--para-->

</listitem>

<listitem>
<para>The second kind is depicted in the following example:

<informalexample><programlisting><![CDATA[fun{a,b:type} swap_boxed (xy: (a, b)): (b, a) = (xy.1, xy.0)
]]></programlisting></informalexample>


Strictly speaking, there is really no error in this case. If defined as
such, <code>swap_boxed</code> is a function template instead of a
polymorphic function. However, such a function template is severely
restricted as it cannot be instantiated with types that are not boxed.
While this could be intended, it is likely not.
</para><!--para-->
</listitem>

</itemizedlist>

Given the potential confusion, why do we need both function templates and
polymorphic functions?  At this stage, it is certainly plausible that we
program only with function templates and make no use of polymorphic
functions. However, polymorphic functions can hardly be missed in the
presence dependent types. There will actually be numerous occasions where
we encounter polymorphic function templates, that is, templates for
polymorphic functions.
</para><!--para-->

</sect1><!--id="polymorphic_functions"-->

<!-- ****** ****** -->

<sect1 id="polymorphic_datatypes">
<title>Polymorphic Datatypes</title>

<para>Code sharing also applies to datatype declarations. For instance,
a commonly used polymorphic datatype <code>list0</code> is declared as follows:

<informalexample><programlisting><![CDATA[datatype list0 (a:t@ype) =
  | list0_nil (a) of () | list0_cons (a) of (a, list0 a)
// end of [list0]
]]></programlisting></informalexample>


More precisely, <code>list0</code> is a type constructor. Given a type T,
we can form a type <code>list0</code>(T) for lists consisting of elements
of the type T. For instance, <code>list0(char)</code> is for character
lists, <code>list0(int)</code> for integer lists,
<code>list0(list0(int))</code> for lists whose elements themselves are
integer lists, etc.  To a great extent, the need for function templates or
polymorphic functions largely stems from the availability of polymorphic
datatypes. As an example, a function template <code>list0_length</code> is
implemented as follows for computing the length of any given list:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
list0_length (xs: list0 a): int = case+ xs of
  | list0_cons (_, xs) => 1 + list0_length (xs) | list0_nil () => 0
// end of [list0_length]
]]></programlisting></informalexample>


When applying <code>list0_length</code> to a list xs, we can in general
write <code>list0_length</code>(xs), expecting the typechecker to
synthesize a proper type parameter for <code>list0_length</code>.  We may
also write <code>list0_length&lt;</code>T<code>&gt;</code>(xs) if the
elements of xs are of the type T. The latter style, though a bit more
verbose, is likely to yield more informative messages in case type-errors
occur.

</para><!--para-->

<para>Another commonly used polymorphic datatype <code>option0</code> is
declared as follows:

<informalexample><programlisting><![CDATA[datatype option0 (a:t@ype) =
  | option0_none (a) of () | option0_some (a) of a
// end of [option0]
]]></programlisting></informalexample>


A typical use of <code>option0</code> is to perform some kind of
error-handling. Suppose that we are to implement a function doing integer
division and we want to make sure that the function returns even if it is
called in a case where the divisor equals 0. This can be done as follows:

<informalexample><programlisting><![CDATA[fun divopt (x: int, y: int): option0 (int) =
  if y = 0 then option0_none () else option0_some (x/y)
// end of [divopt]
]]></programlisting></informalexample>


By inspecting what <code>divopt</code> returns, we can tell whether integer
division has been done normally or an error of divsion-by-zero has
occurred. A realistic use of <code>option0</code> is shown in the following
implementation of <code>list0_last</code>:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
list0_last (xs: list0 a): option0 (a) = let
  fun loop (x: a, xs: list0 a): a = case+ xs of
    | list0_nil () => x | list0_cons (x, xs) => loop (x, xs)
  // end of [loop]
in
  case+ xs of
  | list0_nil () => option0_none ()
  | list0_cons (x, xs) => option0_some (loop (x, xs))
end // end of [list0_last]
]]></programlisting></informalexample>


When applied to a list, <code>list0_last</code> returns an optional
value. If the value matches the pattern <code>option0_none()</code>, then
the list is empty. Otherwise, the value is formed by applying
<code>option0_some</code> to the last element in the list.
</para><!--para-->

</sect1><!--id="polymorphic_datatypes"-->

<!-- ****** ****** -->

<sect1 id="example_function_templates_on_lists">
<title>Example: Function Templates on Lists</title>

<para>In functional programming, lists are ubiquitous. We implement as
follows some commonly used function templates on lists. It should be noted
that these templates are all available in a library of ATS, where they may
be implemented in a significantly more efficient manner due to the use of
certain programming features that have not been covered so far.
</para>

<para>Please find the entire code in this section plus some additional
code for testing <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_POLYMORPHISM/listfun.dats">on-line</ulink>.
</para>

<sect2 id="list0_append">
<title>
Appending: <code>list0_append</code>
</title>

<para>Given two lists xs and ys of the type <code>list0</code>(T) for some
type T, <code>list0_append</code>(xs, ys) returns a list that is the
concatenation of xs and ys:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
list0_append (
  xs: list0 a, ys: list0 a
) : list0 a = case+ xs of
  | list0_cons (x, xs) => list0_cons (x, list0_append (xs, ys))
  | list0_nil () => ys
// end of [list0_append]
]]></programlisting></informalexample>


Clearly, this implementation of <code>list0_append</code> is not
tail-recursive.
</para><!--para-->

</sect2><!--id="list0_append"-->

<sect2 id="list0_reverse_append">
<title>
Reverse Appending: <code>list0_reverse_append</code>
</title>

<para>Given two lists xs and ys of the type <code>list0</code>(T) for some
type T, <code>list0_reverse_append</code>(xs, ys) returns a list that is the
concatenation of the reverse of xs and ys:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
list0_reverse_append (
  xs: list0 a, ys: list0 a
) : list0 a = case+ xs of
  | list0_cons (x, xs) =>
      list0_reverse_append (xs, list0_cons (x, ys))
  | list0_nil () => ys
// end of [list0_reverse_append]
]]></programlisting></informalexample>


Clearly, this implementation of <code>list0_reverse_append</code> is
tail-recursive.
</para><!--para-->

</sect2><!--id="list0_reverse_append"-->

<sect2 id="list0_reverse">
<title>
Reversing: <code>list0_reverse</code>
</title>

<para>Given a list xs, <code>list0_reverse</code>(xs) returns the reverse
of xs:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
list0_reverse
  (xs: list0 a): list0 a = list0_reverse_append (xs, list0_nil)
// end of [list0_reverse]
]]></programlisting></informalexample>

</para><!--para-->

</sect2><!--id="list0_reverse"-->

<sect2 id="list0_map">
<title>
Mapping: <code>list0_map</code>
</title>

<para>Given a list xs of the type <code>list0</code>(T1) for some type T1 and a
closure function f of the type T1 -&lt;cloref1&gt; T2 for some type T2,
<code>list0_map</code>(xs) returns a list ys of the type
<code>list0</code>(T2):

<informalexample><programlisting><![CDATA[fun{a:t@ype}{b:t@ype}
list0_map (
  xs: list0 a, f: a -<cloref1> b
) : list0 b = case+ xs of
  | list0_cons (x, xs) => list0_cons (f x, list0_map (xs, f))
  | list0_nil () => list0_nil ()
// end of [list0_map]
]]></programlisting></informalexample>


The length of ys equals that of xs and each element y in ys equals f(x),
where x is the corresponding element in xs.  Clearly, this implementation
of <code>list0_map</code> is not tail-recursive.
</para><!--para-->

</sect2><!--id="list0_map"-->

<sect2 id="list0_zip">
<title>
Zipping: <code>list0_zip</code>
</title>

<para>Given two lists xs and ys of the types <code>list0</code>(T1) and
<code>list0</code>(T2) for some types T1 and T2, respectively,
<code>list0_zip</code>(xs, ys) returns a list zs of the type list0 @(T1,
T2):

<informalexample><programlisting><![CDATA[fun{a,b:t@ype}
list0_zip (
  xs: list0 a, ys: list0 b
) : list0 @(a, b) = case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => list0_cons ((x, y), list0_zip (xs, ys))
  | (_, _) => list0_nil ()
// end of [list0_zip]
]]></programlisting></informalexample>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs @(x, y), where x and y are the corresponding elements in xs
and ys, respectively.  Clearly, this implementation of
<code>list0_zip</code> is not tail-recursive.
</para><!--para-->

</sect2><!--id="list0_zip"-->

<sect2 id="list0_zipwith">
<title>
Zipping with: <code>list0_zipwith</code>
</title>

<para>Given two lists xs and ys of the types <code>list0</code>(T1) and
<code>list0</code>(T2) for some types T1 and T2, respectively, and a closure
function f of the type (T1, T2) -&lt;cloref1&gt; T3 for some type T3,
<code>list0_zipwith</code>(xs, ys, f) returns a list zs of the type
<code>list0</code>(T3):

<informalexample><programlisting><![CDATA[fun{a,b:t@ype}{c:t@ype}
list0_zipwith (
  xs: list0 a
, ys: list0 b
, f: (a, b) -<cloref1> c
) : list0 c = case+ (xs, ys) of
  | (list0_cons (x, xs), list0_cons (y, ys)) =>
      list0_cons (f (x, y), list0_zipwith (xs, ys, f))
  | (_, _) => list0_nil ()
// end of [list0_zipwith]
]]></programlisting></informalexample>


The length of zs is the minimum of the lengths of xs and ys and each
element z in zs is f(x, y), where x and y are the corresponding elements in
xs and ys, respectively.  Clearly, this implementation of
<code>list0_zipwith</code> is not tail-recursive.  Note that
<code>list0_zipwith</code> behaves exactly like <code>list0_zip</code> if
its third argument <code>f</code> is replaced with <code>lam (x, y) => @(x,
y)</code>.  This function template is also named <code>list0_map2</code>
for the obvious reason.
</para><!--para-->

</sect2><!--id="list0_zipping_with"-->

</sect1><!--id="example_function_templates_on_lists"-->

<!-- ****** ****** -->

<sect1 id="example_mergesort" xreflabel="implementation of mergesort on lists">

<title>Example: Mergesort on Lists</title>

<para>
Mergesort is simple sorting algorithm that is guaranteed to be log-linear.
It is stable in the sense that the order of two equal elements always stay
the same after sorting. I give as follows a typical functional style of
implementation of mergesort on lists.

</para>

<para>
First, let us introduce abbreviations
for the list constructors <code>list0_nil</code> and <code>list0_cons</code>:

<informalexample><programlisting><![CDATA[#define nil list0_nil // writing [nil] for list0_nil
#define :: list0_cons // writing [::] for list0_cons
#define cons list0_cons // writing [cons] for list0_cons
]]></programlisting></informalexample>


Note that the operator <code>::</code> is already given the infix status.
For instance, the list consisting of the first 5 natural numbers can be
constructed as follows:

<informalexample><programlisting><![CDATA[cons (0, cons (1, 2 :: 3 :: 4 :: nil ()))
]]></programlisting></informalexample>


In practice, there is of course no point in mixing <code>cons</code>
with <code>::</code>.

</para><!--para-->

<para>We next implement a function template <code>merge</code> to merge
two given ordered lists into a single ordered one:

<informalexample><programlisting><![CDATA[typedef lte (a:t@ype) = (a, a) -> bool

fun{a:t@ype}
merge (
  xs: list0 a, ys: list0 a, lte: lte a
) : list0 a =
  case+ xs of
  | x :: xs1 => (
    case+ ys of
    | y :: ys1 =>
        if x \lte y then
          x :: merge (xs1, ys, lte))
        else
          y :: merge (xs, ys1, lte))
        // end of [if]
    | nil () => xs
    ) // end of [::]
  | nil () => ys
// end of [merge]
]]></programlisting></informalexample>


For instance, suppose that the two given lists are (1, 3, 4, 8) and (2, 5,
6, 7, 9), and the comparison function (the third argument of
<code>merge</code>) is the standard less-than-or-equal-to function on
integers. Then the list returned by <code>merge</code> is (1, 2, 3, 4, 5,
6, 7, 8, 9). The syntax <code>\lte</code> means that the particular
occurrence of <code>lte</code> following the backslash symbol
(<code>\</code>) is given the infix status, and thus the expression
<code>x \lte y</code> means the same as <code>lte(x, y)</code>.
</para><!--para-->

<para>The following function template <code>mergesort</code> implements
the standard mergesort algorithm:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
mergesort
  (xs: list0 a, lte: lte a): list0 a = let
//
  fun msort (
    xs: list0 a, n: int, lte: lte a
  ) : list0 a =
    if n >= 2 then split (xs, n, lte, n/2, nil) else xs
  and split (
    xs: list0 a, n: int, lte: lte a, i: int, xsf: list0 a
  ) : list0 a =
    if i > 0 then let
      val- cons (x, xs) = xs
    in
      split (xs, n, lte, i-1, cons (x, xsf))
    end else let
      val xsf = list0_reverse<a> (xsf) // make sorting stable!
      val xsf = msort (xsf, n/2, lte) and xs = msort (xs, n-n/2, lte)
    in
      merge (xsf, xs, lte)
    end // end of [if]
//
  val n = list0_length<a> (xs)
//
in
  msort (xs, n, lte)
end // end of [mergesort]
]]></programlisting></informalexample>
<!--atscode-->

Suppose we want to sort the list (8, 3, 4, 1, 2, 7, 6, 5, 9); we first
divide it into two lists: (8, 3, 4, 1) and (2, 7, 6, 5, 9); by performing
mergesort on each of them, we obtain two ordered lists: (1, 3, 4, 8) and
(2, 5, 6, 7, 9); by merging these two ordered list, we obtain the ordered
list (1, 2, 3, 4, 5, 6, 7, 8, 9), which is a permutation of the original
one.
</para><!--para-->

<para>Note that the function template <code>merge</code> is not
tail-recursive as the call to <code>merge</code> in its body is not a
tail-call. This is a serious problem in practice: It is almost certain that
a stack overflow is to occur if the above implementation of mergesort is
employed to sort a list that is very long (e.g., containing 1,000,000
elements or more). I will later give a tail-recursive implementation of the
<code>merge</code> function in ATS that makes use of linear types.
</para>

<para>Please find the entire code in this section plus some additional
code for testing <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_POLYMORPHISM/mergesort.dats">on-line</ulink>.
</para>

</sect1><!--id="example_mergesort"-->

</chapter><!--id="parametric_polymorphism"-->

<!-- ****** ****** -->

<!-- end of [main.atxt] -->


