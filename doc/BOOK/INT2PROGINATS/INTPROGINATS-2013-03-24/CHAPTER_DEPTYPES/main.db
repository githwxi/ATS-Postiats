<!--
The file is automatically generated by [atsdoc] from main.atxt.
-->
<!--
Time of Generation: Sun Dec 22 16:39:00 2013
-->
<chapter
id="introduction_to_dependent_types"
><title>Introduction to Dependent Types</title>

<para>
The types we have encountered so far in this book cannot offer
adequate precision for capturing programming invariants. For instance, if
we assign the type <code>int</code> to both of 0 and 1, then we simply
cannot distinguish 0 from 1 at the level of types. This means that 0 and 1
are interchangeable as far as typechecking is concerned. In other words, we
cannot expect a program error to be caught during typechecking if the error
is caused by 0 being mistyped as 1. This form of imprecision in types is a
crippling limitation if we ever want to build a type-based specification
language that is reasonably expressive for practical use.
</para><!--para-->

<para>
Please find <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_DEPTYPES/">on-line</ulink>
the code employed for illustration in this chapter plus some additional
code for testing.
</para>

<sect1
id="enhanced_expressiveness_for_specification">
<title>Enhanced Expressiveness for Specification</title>

<para>
The primary purpose of introducing dependent types into the type
system of ATS is to greatly enhance the expressiveness of types so that
they can be employed to capture program invariants with much more
precision.  Generally speaking, dependent types are types dependent on
values of expressions. For instance, <code>bool</code> is a type
constructor in ATS that forms a type <code>bool</code>(b) when applied to a
given boolean value b. As this type can only be assigned to a boolean
expression of the value b, it is often referred to as a singleton type,
that is, a type for exactly one value. Clearly, the meaning of
<code>bool</code>(b) depends on the boolean value b.  Similarly,
<code>int</code> is a type constructor in ATS that forms a type
<code>int</code>(i) when applied to a given integer i. This type is also a
singleton type as it can only be assigned to an integer expression of the
value i. Note that both <code>bool</code> and <code>int</code> are
overloaded as they also refer to (non-dependent) types.  I will gradually
introduce many other examples of dependent types.  In particular, I will
present a means for the programmer to declare dependent datatypes.
</para><!--para-->

<para>
The statics of ATS is a simply-typed language, and the types in this
language are called <emphasis>sorts</emphasis> so as to avoid some
potential confusion (with the types for dynamic terms). The following four
listed sorts are commonly used:

<itemizedlist>

<listitem>
<para>
<emphasis>bool</emphasis>: for static terms of boolean values
</para>
</listitem>

<listitem>
<para>
<emphasis>int</emphasis>: for static terms of integer values
</para>
</listitem>

<listitem>
<para>
<emphasis>type</emphasis>: for static terms representing boxed types (for dynamic terms)
</para>
</listitem>

<listitem>
<para>
<emphasis>t@ype</emphasis>: for static terms representing unboxed types (for dynamic terms)
</para>
</listitem>

</itemizedlist>

The sorts <emphasis>bool</emphasis> and <emphasis>int</emphasis> are
classified as predicative sorts while the sorts <emphasis>type</emphasis>
and <emphasis>t@ype</emphasis> are impredicative. A boxed type is a static
term of the sort <emphasis>type</emphasis> while an unboxed type is a
static term of the sort <emphasis>t@ype</emphasis>. As types,
<code>bool</code> and <code>int</code> are static terms of the sort
<emphasis>t@ype</emphasis>. As type constructors, <code>bool</code> and
<code>int</code> are static terms of the sorts (<emphasis>bool</emphasis>)
-> <emphasis>t@ype</emphasis> and (<emphasis>int</emphasis>) ->
<emphasis>t@ype</emphasis>, respectively.  Also note that the type
constructor <code>list0</code> is of the sort (<emphasis>t@ype</emphasis>)
-> <emphasis>type</emphasis>, which indicates that <code>list0</code> forms
a boxed type when applied to an unboxed one.  There are also various
built-in static functions in ATS for constructing static terms of the sorts
<emphasis>bool</emphasis> and <emphasis>int</emphasis>, and I list as
follows some of these functions together with the sorts assigned to them:

<itemizedlist>

<listitem>
<para>
~ (integer negation): (<emphasis>int</emphasis>) -> <emphasis>int</emphasis>
</para>
</listitem>

<listitem>
<para>
+ (addition): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>int</emphasis>
</para>
</listitem>

<listitem>
<para>
- (subtraction): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>int</emphasis>
</para>
</listitem>

<listitem>
<para>
* (multiplication): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>int</emphasis>
</para>
</listitem>

<listitem>
<para>
/ (division): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>int</emphasis>
</para>
</listitem>

<listitem>
<para>
> (greater-than): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
>= (greater-than-or-equal-to): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
< (less-than): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
<= (less-than-or-equal-to): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
== (equal-to): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
<> (not-equal-to): (<emphasis>int</emphasis>, <emphasis>int</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
~ (boolean negation): (<emphasis>bool</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
|| (disjunction): (<emphasis>bool</emphasis>, <emphasis>bool</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

<listitem>
<para>
&& (conjunction) : (<emphasis>bool</emphasis>, <emphasis>bool</emphasis>) -> <emphasis>bool</emphasis>
</para>
</listitem>

</itemizedlist>

By combining a sort with one or more predicates, we can define a subset
sort. For instance, the following subset sorts are defined in the file <ulink
url="http://www.ats-lang.org/DOCUMENT/ANAIRIATS/prelude/sortdef.sats"><filename>prelude/sortdef.sats</filename></ulink>,
which is automatically loaded by the ATS compiler:

<informalexample><programlisting><![CDATA[sortdef nat = {a: int | a >= 0} // for natural numbers
sortdef pos = {a: int | a > 0}  // for positive numbers
sortdef neg = {a: int | a < 0}  // for negative numbers

sortdef two = {a: int | 0 <= a; a <= 1} // for 0 or 1
sortdef three = {a: int | 0 <= a; a <= 2} // for 0, 1 or 2
]]></programlisting></informalexample>


Note that predicates can be sequenced together with the semicolon symbol
(;).  It is also possible to define the subset sorts
<emphasis>two</emphasis> and <emphasis>three</emphasis> as follows:

<informalexample><programlisting><![CDATA[sortdef two = {a: int | a == 0 || a == 1} // for 0 or 1
sortdef three = {a: int | 0 <= a && a <= 2} // for 0, 1 or 2
]]></programlisting></informalexample>


Another possibility is to define a subset sort based on an existing one
plus some predicates. For instance, the subset sorts
<emphasis>two</emphasis> and <emphasis>three</emphasis> can also be given
the following definitions:

<informalexample><programlisting><![CDATA[sortdef two = {a: nat | a <= 1} // for 0 or 1
sortdef three = {a: nat | a <= 2} // for 0, 1 or 2
]]></programlisting></informalexample>

</para><!--para-->

<para>In order to unleash the expressiveness of dependent types, we need
to employ both universal and existential quantification over static
variables. For instance, the type <code>Int</code> in ATS is defined as
follows:

<informalexample><programlisting><![CDATA[typedef Int = [a:int] int (a) // for unspecified integers
]]></programlisting></informalexample>


where the syntax <code>[a:int]</code> means existential quantification over
a static variable <code>a</code> of the sort
<emphasis>int</emphasis>. Essentially, this means that for each value of
the type <code>Int</code>, there exists an integer I such that the value is
of the type <code>int</code>(I). Therefore, any value that can be given the
type <code>int</code> can also be given the type <code>Int</code>. A type
like <code>Int</code> is often referred to as an existentially quantified
type.  As another example, the type <code>Nat</code> in ATS is defined as
follows:

<informalexample><programlisting><![CDATA[typedef Nat = [a:int | a >= 0] int (a) // for natural numbers
]]></programlisting></informalexample>


where the syntax <code>[a:int | a >= 0]</code> means existential
quantification over a static variable <code>a</code> of the sort
<emphasis>int</emphasis> that satisfies the constraint <code>a >= 0</code>.
Therefore, each value of the type <code>Nat</code> can be assigned the type
<code>int</code>(I) for some integer I satisfying I >= 0. Given that
<code>int</code>(I) is a singleton type, the value equals I and thus is a
natural number. This means that the type <code>Nat</code> is for natural
numbers. The definition of <code>Nat</code> can also be given as follows:

<informalexample><programlisting><![CDATA[typedef Nat = [a:nat] int (a) // for natural numbers
]]></programlisting></informalexample>


where the syntax <code>[a:nat]</code> is just a form of syntactic sugar
that automatically expands into <code>[a:int | a >= 0]</code>.
</para><!--para-->

<para>At this point, types have already become much more expressive. For
instance, we could only assign the type <code>(int) -> int</code> to a
function that maps integers to natural numbers (e.g., the function that
computes the absolute value of a given integer), but we can now do better
by assigning it the type <code>(Int) -> Nat</code>, which is clearly more
precise. In order to relate at the level of types the return value of a
function to its arguments, we need universal quantification. For instance,
the following universally quantified type is for a function that returns
the successor of its integer argument:

<informalexample><programlisting><![CDATA[{i:int} int (i) -> int (i+1)
]]></programlisting></informalexample>


where the syntax <code>{i:int}</code> means universal quantification over a
static variable <code>i</code> of the sort <code>int</code> and the scope
of this quantification is the function type following it.  One may think
that this function type is also a singleton type as the only function of
this type is the successor function on integers. Actually, there are
infinitely may partial functions that can be given this type as well.  For
the successor function on natural numbers, we can use the following type:

<informalexample><programlisting><![CDATA[{i:int | i >= 0} int (i) -> int (i+1)
]]></programlisting></informalexample>


where the syntax <code>{i:int | i >= 0}</code> means universal
quantification over a static variable <code>i</code> of the sort
<emphasis>int</emphasis> that satisfies the constraint <code>i >= 0</code>.
This type can also be written as follows:

<informalexample><programlisting><![CDATA[{i:nat} int (i) -> int (i+1)
]]></programlisting></informalexample>


where the syntax <code>{i:nat}</code> automatically expands into
<code>{i:int | i >= 0}</code>.  I list as follows the interfaces for some
commonly used functions on integers:

<informalexample><programlisting><![CDATA[fun ineg {i:int} (i: int i): int (~i) // negation
fun iadd {i,j:int} (i: int i, j: int j): int (i+j) // addition
fun isub {i,j:int} (i: int i, j: int j): int (i-j) // subtraction
fun imul {i,j:int} (i: int i, j: int j): int (i*j) // multiplication
fun idiv {i,j:int} (i: int i, j: int j): int (i/j) // division

fun ilt {i,j:int} (i: int i, j: int j): bool (i < j) // less-than
fun ilte {i,j:int} (i: int i, j: int j): bool (i <= j) // less-than-or-equal-to
fun gt {i,j:int} (i: int i, j: int j): bool (i > j) // greater-than
fun gte {i,j:int} (i: int i, j: int j): bool (i >= j) // greater-than-or-equal-to
fun eq {i,j:int} (i: int i, j: int j): bool (i == j) // equal-to
fun neq {i,j:int} (i: int i, j: int j): bool (i <> j) // not-equal-to
]]></programlisting></informalexample>


These interfaces are all declared in the file <ulink
url="http://www.ats-lang.org/DOCUMENT/ANAIRIATS/prelude/SATS/integer.sats"><filename>prelude/SATS/integer.sats</filename></ulink>,
which is automatically loaded by the ATS compiler.
</para><!--para-->

<para>It is now a proper moment for me to raise an interesting question:
What does a dependently typed interface for the factorial function look
like?  After seeing the above examples, it is natural for one to expect
something along the following line:

<informalexample><programlisting><![CDATA[fun ifact {i:nat} (i: int i): int (fact (i))
]]></programlisting></informalexample>


where <emphasis>fact</emphasis> is a static version of the factorial
function. The problem with this solution is that a static function like
<emphasis>fact</emphasis> cannot be defined in ATS.  The statics of ATS is
a simply-typed language that does not allow any recursive means to be
employed in the construction of static terms. This design is adopted
primarily to ensure that the equality on static terms can be decided based
on a practical algorithm. As typechecking involving dependent types
essentially turns into verifying whether a set of equalities (and some
built-in predicates) on static terms hold, such a design is of vital
importance to the goal of supporting practical programming with dependent
types.

In order to assign an interface to the factorial function that precisely
matches the definition of the function, we need to employ a mechanism in ATS
for combining programming with theorem-proving.  This is a topic I will
cover later.
</para><!--para-->

</sect1><!--id="enhanced_expressiveness_for_specification"-->

<!-- ****** ****** -->

<sect1
id="constraint-solving_during_typechecking">
<title>Constraint-Solving during Typechecking</title>

<para>
Typechecking in ATS involves generating and solving constraints.  As an
example, the code below gives an implementation of the factorial function:

<informalexample><programlisting><![CDATA[fun fact {n:nat}
  (x: int n): [r:nat] int r = if x > 0 then x * fact (x-1) else 1
// end of [fact]
]]></programlisting></informalexample>


In this implementation, the function <code>fact</code> is assigned the
following type:

<informalexample><programlisting><![CDATA[{n:nat} int(n) -> [r:nat] int(r)
]]></programlisting></informalexample>


which means that <code>fact</code> returns a natural number r when applied to
a natural number n. When the code is typechecked, the following
constraints need to be solved:

<itemizedlist>

<listitem>
<para>
For each natural number n, n &gt; 0 implies n - 1 &gt;= 0
</para>
</listitem>

<listitem>
<para>For each natural number n and each natural number
r<subscript>1</subscript>, n &gt; 0 implies n * r<subscript>1</subscript>&gt;= 0</para>
</listitem>

<listitem>
<para>
For each natural number n, 1 &gt;= 0 holds.
</para>
</listitem>

</itemizedlist>

The first constraint is generated due to the call <code>fact(x-1)</code>,
which requires that <code>x-1</code> be a natural number. The second
constraint is generated in order to verify that <code>x * fact(x-1)</code>
is a natural number under the assumption that <code>fact(x-1)</code> is a
natural number.  The third constraint is generated in order to verify that
<code>1</code> is a natural number.  The first and the third constraints
can be readily solved by the constraint solver in ATS, which is based on
the Fourier-Motzkin variable elimination method. However, the second
constraint cannot be handled by the constraint solver as it is nonlinear:
The constraint cannot be turned into a linear integer programming problem
due to the occurrence of the nonlinear term (n*r<subscript>1</subscript>).
While nonlinear constraints cannot be handled automatically by the
constraint solver in ATS, the programmer can verify them by constructing
proofs in ATS explicitly. I will cover the issue of explicit proof
construction in an elaborated manner elsewhere.
</para><!--para-->

<para>As a more interesting example, the following code implements
MacCarthy's famous 91-function:

<informalexample><programlisting><![CDATA[fun f91 {i:int} (x: int i)
  : [j:int | (i < 101 && j==91) || (i >= 101 && j==i-10)] int (j) =
  if x >= 101 then x-10 else f91 (f91 (x+11))
// end of [f91]
]]></programlisting></informalexample>


The type assigned to <code>f91</code> clearly indicates that the function
always returns 91 if its argument is less than 101 or it returns the
difference between its argument and 10. The constraints generated during
typechecking in this example are all linear and can be readily solved by
the constraint-solver employed by the typechecker of ATS.
</para><!--para-->

<para>
Currently, the constraint-solver implemented for ATS/Anairiats makes
use of machine-level arithmetic (in contrast to the standard arithmetic of
infinite precision). This is done primarily for the sake of efficiency. In
the presence of machine-level arithmetic overflow during
constraint-solving, results returned by the constraint-solver are possibly
incorrect. While such cases can be readily constructed, their
appearances in practice seem rare.
</para><!--para-->

</sect1><!--id="constraint-solving_during_typechecking"-->

<!-- ****** ****** -->

<sect1
id="example_string_processing">
<title>Example: String Processing</title>

<para>
A string in ATS is represented in the same manner as in C: It is
sequence of adjacently stored non-null characters followed by the null
character, and its length is the number of non-null characters in the
sequence.  Conventionally, such strings are often referred to as C-style
strings, which are notoriously difficult to be processed safely (as
indicated by so many bugs and breaches due to misusing such strings). As a
matter of fact, ATS is the first practical programming language that I know
can fully support safe processing of C-style strings. In ATS,
<code>string</code> is a type constructor of the sort <emphasis> (int) ->
type </emphasis>.  Given a static integer n, <code>string</code>(n) is the
type for strings of the length n. Note that <code>string</code> also refers
to a non-dependent type for strings of unspecified length, which is
basically equivalent to the type <code>String</code> defined as follows:

<informalexample><programlisting><![CDATA[typedef String = [n:nat] string (n)
]]></programlisting></informalexample>


The following two functions are commonly used for traversing a given string:

<informalexample><programlisting><![CDATA[fun string_is_at_end
  {n:int}{i:nat | i <= n}
  (str: string n, i: size_t i): bool (i == n)
// end of [string_is_at_end]

fun string_isnot_at_end
  {n:int}{i:nat | i <= n}
  (str: string n, i: size_t i): bool (i < n)
// end of [string_isnot_at_end]
]]></programlisting></informalexample>


Obviously, either one of them can be implemented based on the other. As an
example, the following code implements a function that computes the length
of a string:

<informalexample><programlisting><![CDATA[fun string_length {n:nat}
  (str: string n): size_t n = let
  fun loop {i:nat | i <= n}
    (str: string n, i: size_t i): size_t (n) =
    if string_isnot_at_end (str, i) then loop (str, i+1) else i
  // end of [loop]
in
  loop (str, 0)
end // end of [string_length]
]]></programlisting></informalexample>


Note that the function <code>loop</code> in the body of
<code>string_length</code> is defined tail-recursively.  Although this
implementation of <code>string_length</code> looks fairly plain now, it was
actually an exciting achievement in the pursuit of supporting practical
programming with dependent types.
</para><!--para-->

<para>
The following two functions are for accessing and updating characters
stored in strings:

<informalexample><programlisting><![CDATA[typedef c1har = [c:char | c <> '\000'] char (c)

fun string_get_char_at
  {n:int} {i:nat | i < n} (str: string n, i: size_t i): c1har
overload [] with string_get_char_at

fun string_set_char_at {n:int}
  {i:nat | i < n} (str: string n, i: size_t i, c: c1har): void
overload [] with string_set_char_at
]]></programlisting></informalexample>


The type constructor <code>char</code> is of the sort <emphasis>(char) ->
t@ype</emphasis>, which takes a static character c to form a singleton type
<code>char</code>(c) for the only character equal to c. Thus, the type
<code>c1har</code> is for all non-null characters. The following defined
function <code>string_find</code> traverses a string from left to right to
see if a given character occurs in the string:

<informalexample><programlisting><![CDATA[typedef sizeLt (n:int) = [i:nat | i < n] size_t (i)

fun string_find {n:nat}
  (str: string n, c0: char): option0 (sizeLt n) = let
  fun loop {i:nat | i <= n}
    (str: string n, c0: char, i: size_t i): option0 (sizeLt n) =
    if string_isnot_at_end (str, i) then
      if (c0 = str[i]) then option0_some (i) else loop (str, c0, i+1)
    else option0_none () // end of [if]
  // end of [loop]
in
  loop (str, c0, 0)
end // end of [string_find]
]]></programlisting></informalexample>


If the character <code>c0</code> occurs in the string <code>str</code>,
then a value of the form <code>option0_some</code>(i) is returned, when i
refers to the position of the first occurrence of <code>c0</code> (counting
from left to right). Otherwise, the value <code>option0_none()</code> is
returned.
</para><!--para-->

<para>There is some inherent inefficiency in the implementation of
<code>string_find</code>: A given position <code>i</code> is first checked
to see if it is strictly less than the length of the string
<code>str</code> by calling <code>string_isnot_at_end</code>, and, if it
is, the character stored at the position in the string is fetched by
calling <code>string_get_char_at</code>. These two function calls are
merged into one function call in the following implementation:

<informalexample><programlisting><![CDATA[//
// This implementation does the same as [string_find]
// but should be more efficient.
//
fun string_find2 {n:nat}
  (str: string n, c0: char): option0 (sizeLt n) = let
  fun loop {i:nat | i <= n} (
    str: string n, c0: char, i: size_t i
  ) : option0 (sizeLt n) = let
    val c = string_test_char_at (str, i)
  in
    if c != '\000' then
      if (c0 = c) then option0_some (i) else loop (str, c0, i+1)
    else option0_none () // end of [if]
  end // end of [loop]
in
  loop (str, c0, 0)
end // end of [string_find2]
]]></programlisting></informalexample>


The interface for the function <code>string_test_char_at</code>
is given as follows:

<informalexample><programlisting><![CDATA[fun string_test_char_at {n:int}
  {i:nat | i <= n} (str: string n, i: size_t i)
  : [c:char | (c <> NUL && i < n) || (c == NUL && i >= n)] char c
// end of [string_test_char_at]
]]></programlisting></informalexample>


By checking the return value of a call to <code>string_test_char_at</code>,
we can readily tell whether the position <code>i</code> is at the end of
the string <code>str</code>.
</para><!--para-->

<para>
Handling strings safely and efficiently is a complicated matter in
programming language design, and a great deal of information about a
programming language can often be revealed by simply studying its treatment
of strings. In ATS, properly processing C-style strings also makes
essential use of linear types, which I will cover in another part of this
book.
</para><!--para-->

</sect1><!--id="example_string_processing"-->

<!-- ****** ****** -->

<sect1
id="example_binary_search_on_arrays">
<title>Example: Binary Search on Arrays</title>

<para>Given a type T (of the sort <emphasis>t@ype</emphasis>) and a static
integer I (i.e., a static term of the sort <emphasis>int</emphasis>),
<code>array</code>(T, I) is a boxed type for arrays of size I in which each
stored element is of the type T. Note that such arrays are without size
information attached to them. The following interface is for a function
template <code>array_make_elt</code> that can be called to create an array
(with no size information attached to it):

<informalexample><programlisting><![CDATA[fun{a:t@ype}
array_make_elt {n:nat} (asz: size_t n, elt: a): array (a, n)
]]></programlisting></informalexample>


Given a static integer I, the type <code>size_t</code>(I) is a singleton
type for the value of the type size_t in C that represents the integer
equal to I. The function templates for reading from and writing to an array
cell have the following interfaces:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
array_get_elt_at {n:int}
  {i:nat | i < n} (A: array (a, n), i: size_t i): a
overload [] with array_get_elt_at

fun{a:t@ype}
array_set_elt_at {n:int}
  {i:nat | i < n} (A: array (a, n), i: size_t i, x: a): void
overload [] with array_set_elt_at
]]></programlisting></informalexample>


Note that these two function templates do not incur any run-time
array-bounds checking: The types assigned to them guarantee that each index
used for array subscripting is always legal, that is, within the bounds of
the array being subscripted.
</para><!--para-->

<para>As a convincing example of practical programming with dependent
types, the following code implements the standard binary search algorithms
on an ordered array:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
bsearch_arr {n:nat} (
  A: array (a, n), n: int n, x0: a, cmp: (a, a) -> int
) : int = let
  fun loop
    {i,j:int |
     0 <= i; i <= j+1; j+1 <= n} (
    A: array (a, n), l: int i, u: int j
  ) :<cloref1> int =
    if l <= u then let
      val m = l + (u - l) / 2
      val x = A[m]
      val sgn = cmp (x0, x)
    in
      if sgn >= 0 then loop (A, m+1, u) else loop (A, l, m-1)
    end else u // end of [if]
  // end of [loop]
in
  loop (A, 0, n-1)
end // end of [bsearch_arr]
]]></programlisting></informalexample>


The function <code>loop</code> defined in the body of
<code>bsearch_arr</code> searches the segment of the array <code>A</code>
between the indices <code>l</code> and <code>u</code>, inclusively.
Clearly, the type assigned to <code>loop</code> indicates that the integer
values i and j of the arguments <code>l</code> and <code>u</code> must
satisfy the precondition consisting of the constraints 0 <= i, i <= j+1,
and j+1 <= n, where n is the size of the array being searched.  The
progress we have made by introducing dependent types into ATS should be
evident in this example: We can not only specify much more precisely than
before but also enforce effectively the enhanced precision in
specification.
</para><!--para-->

<para>Please find <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_DEPTYPES/bsearch_arr.dats">on-line</ulink>
the code employed for illustration in this section plus some additional
code for testing.
</para><!--para-->

</sect1><!--id="example_binary_search_on_arrays"-->

<!-- ****** ****** -->

<sect1
id="termination-checking_for_recursive_functions">
<title>Termination-Checking for Recursive Functions</title>

<para>There is a mechanism in ATS that allows the programmer to supply
termination metrics for checking whether recursively defined functions are
terminating.  It will soon become clear that this mechanism of
termination-checking plays a fundamental role in the design of ATS/LF, a
theorem-proving subsystem of ATS, where proofs are constructed as total
functional programs.
</para>

<para>A termination metric is just a tuple of natural numbers and the
standard lexicographic ordering on natural numbers is used to order such
tuples. In the following example, a singleton metric <code>n</code> is
supplied to verify that the recursive function <code>fact</code> is
terminating, where <code>n</code> is the value of the integer argument of
<code>fact</code>:

<informalexample><programlisting><![CDATA[fun fact {n:nat} .<n>.
  (x: int n): int = if x > 0 then x * fact (x-1) else 1
// end of [fact]
]]></programlisting></informalexample>


Note that the metric attached to the recursive call <code>fact(x-1)</code>
is <code>n-1</code>, which is strictly less than the initial metric
<code>n</code>. Essentially, termination-checking in ATS verifies that the
metric attached to each recursive call in the body of a function is
strictly less that the initial metric attached to the function.
</para><!--para-->

<para>A more difficult and also more interesting example is given as follows,
where the MacCarthy's 91-function is implemented:

<informalexample><programlisting><![CDATA[fun f91 {i:int} .<max(101-i,0)>. (x: int i)
  : [j:int | (i < 101 && j==91) || (i >= 101 && j==i-10)] int (j) =
  if x >= 101 then x-10 else f91 (f91 (x+11))
// end of [f91]
]]></programlisting></informalexample>


The metric supplied to verify the termination of <code>f91</code> is
<code>max(101-i,0)</code>, where <code>i</code>. is the value of the
integer argument of <code>f91</code>. Please try to verify manually that
this metric suffices for verifying the termination of <code>f91</code>.
</para><!--para-->

<para>As another example, the following code implements the Ackermann's
function, which is well-known for being recursive but not primitive
recursive:

<informalexample><programlisting><![CDATA[fun acker
  {m,n:nat} .<m,n>.
  (x: int m, y: int n): Nat =
  if x > 0 then
    if y > 0 then acker (x-1, acker (x, y-1)) else acker (x-1, 1)
  else y + 1
// end of [acker]
]]></programlisting></informalexample>


The metric supplied for verifying the termination of <code>acker</code> is
a pair <code>(m,n)</code>, where <code>m</code> and <code>n</code> are
values of the two integer arguments of <code>acker</code>. The metrics
attached to the three recursive calls to <code>acker</code> are, from left
to right, <code>(m-1,k)</code> for some natural number k,
<code>(m,n-1)</code>, and <code>(m-1,1)</code>. Clearly, these metrics are
all strictly less than the initial metric <code>(m,n)</code> according to
the lexicographic ordering on pairs of natural numbers.
</para><!--para-->

<para>Termination-checking for mutually recursive functions is similar.
In the following example, <code>isevn</code> and <code>isodd</code> are
defined mutually recursively:

<informalexample><programlisting><![CDATA[fun isevn {n:nat} .<2*n>.
  (n: int n): bool = if n = 0 then true else isodd (n-1)
and isodd {n:nat} .<2*n+1>.
  (n: int n): bool = not (isevn n)
]]></programlisting></informalexample>


The metrics supplied for verifying the termination of <code>isevn</code>
and <code>isodd</code> are <code>2*n</code> and <code>2*n+1</code>,
respectively, where <code>n</code> is the value of the integer argument of
<code>isevn</code> and also the value of the integer argument of
<code>isodd</code>.  Clearly, if the metrics <code>(n, 0)</code> and
<code>(n, 1)</code> are supplied for <code>isevn</code> and
<code>isodd</code>, respectively, the termination of these two functions
can also be verified.  Note that it is required that the metrics for
mutually recursively defined functions be tuples of the same length.
</para><!--para-->

</sect1><!--id="termination-checking_for_recursive_functions"-->

<!-- ****** ****** -->

<sect1
id="dependent_types_for_debugging">
<title>Example: Dependent Types for Debugging</title>

<para>Given an integer x >= 0, the integer square root of x is the greatest
integer i satisfying i * i <= x.  An implementation of the
integer square root function is given as follows based on the method of
binary search:

<informalexample><programlisting><![CDATA[fun isqrt (x: int): int = let
  fun search (x: int, l: int, r: int): int = let
    val diff = r - l
  in
    case+ 0 of
    | _ when diff > 0 => let
        val m = l + (diff / 2)
      in
        // x < m * m is more efficient but can overflow easily
        if x / m < m then search (x, l, m) else search (x, m, r)
      end // end of [if]
    | _ => l (* the result is found *)
  end // end of [search]
in
  search (x, 0, x)
end // end of [isqrt]
]]></programlisting></informalexample>


This implementation passes typechecking, but it seems to be looping forever
when tested. Instead of going into the standard routine of debugging (e.g.,
by inserting calls to some printing functions), let us attempt to identify
the cause for infinite looping by proving the termination of the function
<code>search</code> through the use of dependent types. Clearly, the
function <code>search</code> is assigned the function type
(<code>int</code>, <code>int</code>, <code>int</code>) -> <code>int</code>,
meaning that <code>search</code> takes three integers as its arguments and
returns an integer as its result, and there is not much else that can be
gathered from a non-dependent type as such. However, the programmer may
have thought that the function <code>search</code> should possess the
following invariants (if implemented correctly):

<itemizedlist>

<listitem>
<para>
l * l <= x and x <= r * r must hold when <code>search</code>(x, l, r) is called.
</para>
</listitem>

<listitem>
<para>
Assume l * l <= x < r * r for some integers x, l, r.  If a recursive call
<code>search</code>(x, l1, r1) for some integers l1 and r1 is encountered in
the body of <code>search</code>(x, l, r), then r1-l1 < r-l must hold. This
invariant implies that <code>search</code> is terminating.
</para>
</listitem>

</itemizedlist>

Though the first invariant can be captured in the type system of ATS, it is
somewhat involved to do so due to the need for handling nonlinear
constraints. Instead, we try to assign <code>search</code> the following
dependent function type:

<informalexample><programlisting><![CDATA[{x:nat} {l,r:nat | l < r} .<r-l>. (int(x), int(l), int(r)) -> int
]]></programlisting></informalexample>


which captures a weaker invariant stating that l < r must hold when
<code>search</code>(x, l, r) is called. The termination metric
<code>.&lt;r-l&gt;.</code> is provided for checking that the function
<code>search</code> is terminating. When we assign <code>search</code> the
dependent function type, we have to modify its body as certain errors are
otherwise reported during typechecking. The following code we obtain after
proper modification does pass typechecking:

<informalexample><programlisting><![CDATA[fun
isqrt{x:nat}
  (x: int x): int = let
//
fun search
  {x,l,r:nat | l < r} .<r-l>.
(
  x: int x, l: int l, r: int r
) : int = let
  val diff = r - l
in
  case+ 0 of
  | _ when diff > 1 => let
      val m = l + (diff / 2)
    in
      if x / m < m then search (x, l, m) else search (x, m, r)
    end // end of [if]
  | _ => l (* the result is found *)
end // end of [search]
//
in
  if x > 0 then search (x, 0, x) else 0
end // end of [isqrt]
]]></programlisting></informalexample>


It is now rather clear that infinite looping in the previous implementation
of <code>search</code> may happen if <code>search</code>(x, l, r) is called
in a situaltion where r-l equals 1 as this call can potentially lead to
another call to <code>search</code> of the same arguments. However, such a
call leads to a type-error after <code>search</code> is assigned the
aforementioned dependent function type.
</para><!--para-->

<para>By being precise and being able to enforce precision effectively,
the programmer will surely notice that his or her need for run-time
debugging is diminishing rapidly.
</para>

</sect1><!--id="dependent_types_for_debugging"-->

</chapter><!--id="introduction_to_dependent_types"-->

<!-- ****** ****** -->

<!-- end of [main.atxt] -->


