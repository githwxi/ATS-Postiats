<!--
The file is automatically generated by [atsdoc] from main.atxt.
-->
<!--
Time of Generation: Sun Dec 22 16:38:59 2013
-->
<chapter id="effecftul_programming_features">
<title>Effectful Programming Features</title>

<para>Effectful programming features are those that can generate
effects at run-time. But what is really an effect? The answer to this
question is rather complex as it depends on the model of evaluation. I will
gradually introduce various kinds of effects in this book. In sequential
programming, that is, constructing programs to be evaluated sequentially
(in contrast to concurrently), an expression is effectless if there exists
a value such that the expression and the value cannot be distinguished as
far as evaluation is concerned. For instance, the expression
<code>1+2</code> is effectless as it cannot be distinguished from the value
<code>3</code>. An effectless expression is also said to be pure.  On the
other hand, an effectful expression is one that can be distinguished from
any given values. For instance, the expression <code>print("Hello")</code>
is effectful as its evaluation results in an observable behavior that
distinguishes the expression from any values.  In this case,
<code>print("Hello")</code> is said to contain certain I/O effect.  If the
evaluation of an expression never terminates, then the expression is also
effectul. For instance, let us define a function <code>loop</code> as
follows:

<informalexample><programlisting><![CDATA[fun loop (): void = loop ()
]]></programlisting></informalexample>


Then the expression <code>loop()</code> can be distinguished from
any values in the following context:

<informalexample><programlisting><![CDATA[let val _ = [] in print ("Terminated") end
]]></programlisting></informalexample>


If the hole <code>[]</code> in the context is replaced with
<code>loop()</code>, then the evaluation of the resulting expression
continues forever.  If the hole <code>[]</code> is replaced with any value,
then the evaluation leads to the string "Terminated" being printed out.
The expression <code>loop</code> is said to contain the non-termination
effect.
</para><!--para-->

<para>I will cover programming features related to exceptional
control-flow, persistent memory storage and simple I/O in this chapter,
which are all of common use in practical programming.
</para>

<para>The code employed for illustration in this chapter plus some
additional code for testing is available <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_EFFECTFUL/">on-line</ulink>.
</para>

<sect1
id="exceptions">
<title>Exceptions</title>

<para>The exception mechanism provides an efficient means for reporting a
special condition encountered during program evaluation. Often such a
special condition indicates an error, but it is not uncommon to use the
exception mechanism for addressing issues that are not related to errors.
</para>

<para>The type <code>exn</code> is predefined in ATS. One may think of
<code>exn</code> as an extensible datatype for which new constructors can
always be declared. For instance, two exception constructors are declared
as follows:

<informalexample><programlisting><![CDATA[exception FatalError0 of ()
exception FatalError1 of (string)
]]></programlisting></informalexample>


The constructor <code>FatalError0</code> is nullary while the constructor
<code>FatalError1</code> is unary.  Exception values, that is, values of
the type <code>exn</code> can be formed by applying exception constructors
to proper arguments. For instance, <code>FatalError0()</code> and
<code>FatalError1("division-by-zero")</code> are two exception values (or
simply exceptions). In the following program, a function for integer
division is implemented:

<informalexample><programlisting><![CDATA[exception DivisionByZero of ()
fun divexn (x: int, y: int): int =
  if y <> 0 then then x / y else $raise DivisionByZero()
// end of [divexn]
]]></programlisting></informalexample>


When the function call <code>divexn(1, 0)</code> is evaluated, the exception
<code>DivisionByZero()</code> is raised. The keyword <code>$raise</code> in
ATS is solely for raising exceptions.
</para><!--para-->

<para>A raise-expression is of the form (<code>$raise</code> exp) for some
expression exp.  Clearly, if the evaluation of exp returns a value, then
the evaluation of (<code>$raise</code> exp) leads to a raised
exception. Therefore, the evaluation of a raise-expression can never return
a value, and this justifies that a raise-expression can be given any type.
</para><!--para-->

<para>A raised exception can be captured. If it is not captured, the
raised exception aborts the program evaluation that issued it in the first
place. In ATS, a try-expression is of the form (<code>try</code> exp
<code>with</code> clseq), where <code>try</code> is a keyword, exp is an
expression, <code>with</code> is also a keyword, and clseq is a sequence of
matching clauses. When evaluating such a try-expression, we first evaluate
exp. If the evaluation of exp leads to a value, then the value is also the
value of the try-expression. If the evaluation of exp leads to a raised
exception, then we match the exception against the guards of the matching
clauses in clseq. If there is a match, the raised exception is caught and
we continue to evaluate the body of the first clause whose guard is
matched. If there is no match, the raised exception is uncaught. In a
try-expression, the with-part is often referred to as an exception-handler.
</para>

<para>Let us now see an example that involves raising and capturing an
exception. In the following program, three functions are defined to compute
the product of the integers in a given list:

<informalexample><programlisting><![CDATA[fun listprod1
  (xs: list0 (int)): int = case+ xs of
  | list0_cons (x, xs) => x * listprod1 (xs) | list0_nil () => 1
// end of [listprod1]

fun listprod2
  (xs: list0 (int)): int = case+ xs of
  | list0_cons (x, xs) => if x = 0 then 0 else x * listprod2 (xs)
  | list0_nil () => 1
// end of [listprod2]

fun listprod3
  (xs: list0 (int)): int = let
  exception ZERO of ()
  fun aux (xs: list0 (int)): int =
    case+ xs of
    | list0_cons (x, xs) =>
        if x = 0 then $raise ZERO() else x * aux (xs)
    | list0_nil () => 1
  // end of [aux]
in
  try aux (xs) with ~ZERO () => 0
end // end of [listprod3]
]]></programlisting></informalexample>


While these functions can all be defined tail-recursively, they are not so
as to make a point that should be clear shortly. Undoubtedly, we all know the
following simple fact:

<itemizedlist>

<listitem>
<para>If the integer 0 occurs in a given list, then the product
of the integers in the list is 0 regardless what other integers are.
</para>
</listitem>

</itemizedlist>

The function <code>listprod1</code> is defined in a standard manner, and it
does not make any use of the fact.  The function <code>listprod2</code> is
defined in a manner that makes only partial use of the fact. To see the
reason, let us evaluate a call to <code>listprod2</code> on <code>[1, 2, 3, 0,
4, 5, 6]</code>, which denotes a list consisting of the 7 mentioned
integers. The evaluation of this call eventually leads to the evaluation of
<code>1*(2*(3*(listprod([0,4,5,6]))))</code>, which then leads to
<code>1*(2*(3*0))</code>, and then to <code>1*(2*0)</code>, and then to
<code>1*0</code>, and finally to <code>0</code>. However, what we really want is
for the evaluation to return 0 immediately once the integer 0 is
encountered in the list, and this is accomplished by the function
<code>listprod3</code>. When evaluating a call to <code>listprod3</code> on
<code>[1, 2, 3, 0, 4, 5, 6]</code>, we eventually reach the evaluation of the
following expression:

<informalexample><programlisting><![CDATA[try 1*(2*(3*(aux([0,4,5,6])))) with ~ZERO() => 0
]]></programlisting></informalexample>


Evaluating <code>aux([0,4,5,6])</code> leads to the exception
<code>ZERO()</code> being raised, and the raised exception is caught and
<code>0</code> is returned as the value of the call to
<code>listprod3</code>.  Note that the pattern guard of the matching clause
following the keyword <code>with</code> is <code>~ZERO()</code>.  I will
explain the need for the tilde symbol <code>~</code> elsewhere. For now, it
suffices to say that <code>exn</code> is a linear type and each exception
value is a linear value, which must be consumed or re-raised. The tilde
symbol <code>~</code> indicates that the value matching the pattern
following <code>~</code> is consumed (and the memory for holding the value
is freed).
</para>

<para>Exceptions are not a programming feature that is easy to master, and
misusing exceptions is abundant in practice. So please be patient when
learning the feature and be cautious when using it!
</para>

</sect1><!--id="exceptions"-->

<sect1 id="example_testing_for_braun_trees">
<title>Example: Testing for Braun Trees</title>

<para>Braun trees are special binary trees that can be defined
inductively as follows:

<itemizedlist>

<listitem>
<para>If a binary tree is empty, then it is a Braun tree.
</para>
</listitem>

<listitem>
<para>If both children of a binary tree are Braun trees and the
size of the left child minus the size of the right child equals 0 or 1,
then the binary tree is a Braun tree.
</para>
</listitem>

</itemizedlist>

Given a natural number n, there is exactly one Braun tree whose size is n.
It is straightforward to prove that Braun trees are balanced.
</para>

<para>
A polymorphic datatype is declared as follows for representing binary trees:

<informalexample><programlisting><![CDATA[datatype tree (a:t@ype) =
  | tree_nil (a) of ()
  | tree_cons (a) of (a, tree(a)(*left*), tree(a)(*right*))
// end of [tree]
]]></programlisting></informalexample>


The following defined function <code>brauntest0</code> tests whether a
given binary tree is a Braun tree:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
size (t: tree a): int = case+ t of
  | tree_nil () => 0
  | tree_cons (_, tl, tr) => 1 + size(tl) + size(tr)
// end of [size]

fun{a:t@ype}
brauntest0 (t: tree a): bool = case+ t of
  | tree_nil () => true
  | tree_cons (_, tl, tr) => let
      val cond1 = brauntest0(tl) andalso brauntest0(tr)
    in
      if cond1 then let
        val df = size(tl) - size(tr) in (df = 0) orelse (df = 1)
      end else false
    end // end of [tree_cons]
// end of [brauntest0]
]]></programlisting></informalexample>


The implementation of <code>brauntest0</code> follows the definition of
Braun trees closely. If applied to binary trees of size n, the
time-complexity of the function <code>size</code> is O(n) and the
time-complexity of the function <code>brauntest0</code> is O(n log(n)).
</para><!--para-->

<para>In the following program, the defined function <code>brauntest1</code> also
tests whether a given binary tree is a Braun tree:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
brauntest1 (t: tree a): bool = let
  exception Negative of ()
  fun aux (t: tree a): int = case+ t of
    | tree_nil () => 0
    | tree_cons (_, tl, tr) => let
        val szl = aux (tl) and szr = aux (tr)
        val df = szl - szr
      in
        if df = 0 orelse df = 1 then 1+szl+szr else $raise Negative()
      end // end of [tree_cons]
   // end of [aux]
in
  try let
    val _ = aux (t)
  in
    true // [t] is a Braun tree
  end with
    ~Negative() => false // [t] is not a Braun tree
  // end of [try]
end // end of [brauntest1]
]]></programlisting></informalexample>


Clearly, a binary tree cannot be a Braun tree if one of its subtrees,
proper or improper, is not a Braun tree. The auxiliary function
<code>aux</code> is defined to return the size of a binary tree if the tree
is a Braun tree or raise an exception otherwise. When the evaluation of the
try-expression in the body of <code>brauntest1</code> starts, the call to
<code>aux</code> on a binary tree t is first evaluated. If the evaluation
of this call returns, then t is a Braun tree and the boolean value
<code>true</code> is returned as the value of the
try-expression. Otherwise, the exception <code>Negative()</code> is raised
and then caught, and the boolean value <code>false</code> is returned as
the value of the try-expression.  The time complexity of
<code>brauntest1</code> is the same as that of <code>aux</code>, which is O(n).
</para>

<para>The use of the exception mechanism in the implementation
<code>brauntest1</code> is a convincing one because the range between the
point where an exception is raised and the point where the raised exception
is captured can span many function calls. If this range is short (e.g.,
spanning only one function call) in a case, then the programmer should
probably investigate whether it is a sensible use of the exception
mechanism.</para>

<para>Please find the entire code in this section plus some additional
code for testing <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_EFFECTFUL/brauntest.dats">on-line</ulink>.
</para>

</sect1><!--id="example_testing_for_braun_trees"-->

<!-- ****** ****** -->

<sect1
id="references">
<title>References</title>

<para>A reference is just an array containing one element.  Given a type
T, a reference for storing a value of the type T is given the type ref(T).
The following program makes use of all the essential functionalities on
references:

<informalexample><programlisting><![CDATA[val intr = ref<int> (0) // create a ref and init. it with 0
val () = !intr := !intr + 1 // increase the integer at [intr] by 1
]]></programlisting></informalexample>


The first line creates a reference for storing an integer and initializes
it with the value 0 and then names it <code>intr</code>. Note that the
creation of a reference cannot be separated from its initialization. The
second line updates the reference <code>intr</code> with its current value
plus 1. In general, given a reference r of type ref(T) for some T, the
expression !r means to fetch the value stored at r, which is of the type
T. However, !r can also be used as a left-value. For instance, the
assignment (!r := exp) means to evaluate exp into a value and then store
the value into r. Therefore, the value stored in <code>intr</code> is 1
after the second line in the above program is evaluated.
</para><!--para-->

<para>Various functions and function templates on references are declared in the file <ulink
url="http://www.ats-lang.org/DOCUMENT/ANAIRIATS/prelude/SATS/reference.sats"><filename>prelude/SATS/reference.sats</filename></ulink>,
which is automatically loaded by <command>atsopt</command>. In particular,
it is also possible to read from and write to a reference by using the
function templates <code>ref_get_elt</code> and <code>ref_set_elt</code> of
the following interfaces, respectively:

<informalexample><programlisting><![CDATA[fun{a:t@ype} ref_get_elt (r: ref a): a // !r
fun{a:t@ype} ref_set_elt (r: ref a, x: a): void // !r := x
]]></programlisting></informalexample>


If you implement a program that
makes use of references, please do not forget to include the following line
somewhere in the program:

<informalexample><programlisting><![CDATA[staload _(*anon*) = "prelude/DATS/reference.dats"
]]></programlisting></informalexample>


This line allows the ATS compiler <command>atsopt</command> to gain access
to the defintion of various functions and function templates on references.
</para><!--para-->

<para>
References are often misused in practice, especially, by beginners
of functional programming who had some previous exposure to imperative
programming languages such C and Java. Such programmers often think that
they can just "translate" their programs in C or Java into functional
programs. For example, the following defined function <code>sum</code> is
such an example, which sums up all the integers between 1 and a given
integer, inclusive:

<informalexample><programlisting><![CDATA[fun sum
  (n: int): int = let
  val i = ref<int> (1)
  val res = ref<int> (0)
  fun loop ():<cloref1> void =
    if !i <= n then (!res := !res + !i; !i := !i + 1; loop ())
  // end of [loop]
in
  loop (); !res
end // end of [sum]
]]></programlisting></informalexample>


This is a correct but poor implementation, and its style, though not the
worst of its kind, is deplorable. As references are allocated in heap,
reading from or writing to a reference can be much more time-consuming than
reading from or writing to a register. So, this implementation of
<code>sum</code> is unlikely to be time-efficient.  Every call to
<code>sum</code> creates two references in heap and leaves them there when
it returns, and the memory allocated for such references can only be
reclaimed by a garbage collector (GC). So, this implementation of
<code>sum</code> is not memory-efficient.  More importantly, a program
making heavy use of references is often difficult to reason about.
</para><!--para-->

<para>
I consider references a dangerous feature in functional
programming. If you want to run your program without GC, please do not
create references in the body of a function (besides many other
restrictions). If you find that you are in need of references to
"translate" imperative programs into functional ones, then it is most
likely that you are lost and you have not learned well to program in a
functional style yet.

</para><!--para-->

</sect1><!--id="references"-->

<!-- ****** ****** -->

<sect1
id="example_counter_implementation">
<title>Example: A Counter Implemention</title>

<para>
We implement a counter-like an object in object-oriented programming (OOP).
The type <code>counter</code> for counters is defined as follows:

<informalexample><programlisting><![CDATA[typedef
counter = '{
  get= () -<cloref1> int
, inc= () -<cloref1> void
, reset= () -<cloref1> void
} // end of [counter]
]]></programlisting></informalexample>


The three fields of <code>counter</code> are closure functions that
correspond to methods associated with an object: getting the count of the
counter, increasing the count of the counter by 1 and resetting the count
of the counter to 0. The following defined function <code>newCounter
</code> is for creating a counter object (represented as a boxed record of
closure functions):

<informalexample><programlisting><![CDATA[fun newCounter
  (): counter = let
  val count = ref<int> (0)
in '{
  get= lam () => !count
, inc= lam () => !count := !count + 1
, reset= lam () => !count := 0
} end // end of [newCounter]
]]></programlisting></informalexample>


The state of each created counter object is stored in a reference, which
can only be accessed by the three closure functions in the record that
represents the object. This is often referred to as state encapsulation
in OOP.</para>

</sect1><!--id="example_counter_implementation"-->

<!-- ****** ****** -->

<sect1
id="arrays">

<title>Arrays</title>

<para>I mentioned earlier that a reference is just an array of size 1.  I
would now like to state that an array of size n is just n references
allocated consecutively.  These references can also be called cells, and
they are numbered from 0 until n-1, inclusive.
</para>

<para>Given an array of size n, an integer is a valid index for this array
if it is a natural number strictly less than n. Otherwise, the integer is
out of the bounds of the array.  For an array named A, the expression A[i]
means to fetch the content of the cell in A that is numbered i if i is a
valid index for A. The expression A[i] can also be used as a left
value. For instance, the assignment (A[i] := exp) means to evaluate exp to a
value and then store the value into the cell in A that is numbered i if i
is a valid index.
</para>

<para>What happens if the index i in A[i] is invalid, that is, it is out
of the bounds of the array A?  In this case, A[i] is referred to as
out-of-bounds array subscription and evaluating A[i] leads to a raised
exception where the exception is <code>ArraySubscriptException()</code>.  One
simple and reliable way to tell whether an integer is a valid index for a
given array is to compare it with the size of the array at run-time.  Given
a type T, the type <code>array0</code>(T) is for an array paired with its size
in which elements of the type T are stored. I will loosely refer to values
of the type <code>array0</code>(T) as arrays from now on.  In case there is a
clear need to avoid potential confusion, I may also refer to them as
array0-values.
</para>

<para>Various functions and function templates on array0-values are declared in the file <ulink
url="http://www.ats-lang.org/DOCUMENT/ANAIRIATS/prelude/SATS/array0.sats"><filename>prelude/SATS/array0.sats</filename></ulink>,
which is automatically loaded by <command>atsopt</command>. For instance,
three function templates and one polymorphic function on arrays are
depicted by the following interfaces:

<informalexample><programlisting><![CDATA[fun{a:t@ype} // a template
array0_make_elt (asz: size_t, x: a): array0 a // array creation

// a polymorphic function
fun array0_size {a:t@ype} (A: array0 a): size_t // size of an array

fun{a:t@ype} // a template
array0_get_elt_at (A: array0 a, i: size_t): a // A[i]

fun{a:t@ype} // a template
array0_set_elt_at (A: array0 a, i: size_t, x: a): void // A[i] := x
]]></programlisting></informalexample>


If you implement a program that
makes use of array0-values, please do not forget to include the following
two lines somewhere in the program:

<informalexample><programlisting><![CDATA[
staload _(*anon*) = "prelude/DATS/array.dats"
staload _(*anon*) = "prelude/DATS/array0.dats"
]]></programlisting></informalexample>


These lines allow the ATS compiler <command>atsopt</command> to gain access
to the definition of various functions and function templates on arrays and
array0-values. The topic on programming with arrays that carry no size
information will be covered after dependent types are introduced.
</para><!--para-->

<para>Like in C, there are many types of integer values in ATS. The type
<code>size_t</code> is essentially for unsigned long integers. The functions
for converting between the type <code>int</code> and the type <code>size_t</code>
are <code>int_of_size</code> and <code>size_of_int</code>.  Given a type T and two
values <code>asz</code> and <code>init</code> of the types <code>size_t</code> and T,
respectively, <code>array0_make_elt&lt;T&gt; (asz, init)</code> returns an
array of the type <code>array0</code> (T) such that the size of the array is
<code>asz</code> and each cell in the array is initialized with the value
<code>init</code>. Given an array A of the type <code>array0</code> (T) for some T,
<code>array0_size(A)</code> returns the size of A, which is of the type
<code>size_t</code>.
</para>

<para>In the following program, the function template
<code>insertion_sort</code> implements the standard insertion sort on
arrays:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
insertion_sort (
  A: array0 (a), cmp: (a, a) -> int
) : void = let
  val asz = array0_size (A)
  val n = int_of_size (asz)
  fun ins (x: a, i: int):<cloref1> void =
    if i >= 0 then
      if cmp (x, A[i]) < 0
        then (A[i+1] := A[i]; ins (x, i-1)) else A[i+1] := x
      // end of [if]
    else A[0] := x // end of [if]
  // end of [ins]
  fun loop (i: int):<cloref1> void =
    if i < n then (ins (A[i], i-1); loop (i+1)) else ()
  // end of [loop]
in
  loop (1)
end // end of [insertion_sort]
]]></programlisting></informalexample>


The comparison function <code>cmp</code> should return 1 if its first
argument is greater than the second one, and -1 if its first argument is
less than the second one, and 0 if they are equal.
</para><!--para-->

<para>Note that the entire code in this section plus some additional code
for testing is available <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_EFFECTFUL/insort.dats">on-line</ulink>.
</para>

</sect1><!--id="arrays"-->

<!-- ****** ****** -->

<sect1
id="example_ordering_permutations">

<title>Example: Ordering Permutations</title>

<para>Given a natural number n, we want to print out all the permutations
consisting of integers ranging from 1 to n, inclusive. In addition, we
want to print them out according to the lexicographic ordering on integer
sequences. For instance, we want the following output to be generated when
n is 3:

<informalexample><programlisting><![CDATA[1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
]]></programlisting></informalexample>

</para>

<!--
<para><informalexample><programlisting><![CDATA[1, 2, 3, 4
1, 2, 4, 3
1, 3, 2, 4
1, 3, 4, 2
1, 4, 2, 3
1, 4, 3, 2
2, 1, 3, 4
2, 1, 4, 3
2, 3, 1, 4
2, 3, 4, 1
2, 4, 1, 3
2, 4, 3, 1
3, 1, 2, 4
3, 1, 4, 2
3, 2, 1, 4
3, 2, 4, 1
3, 4, 1, 2
3, 4, 2, 1
4, 1, 2, 3
4, 1, 3, 2
4, 2, 1, 3
4, 2, 3, 1
4, 3, 1, 2
4, 3, 2, 1
]]></programlisting></informalexample>

</para>
-->

<para>Let us first define a function as follows for printing out an array
of integers:

<informalexample><programlisting><![CDATA[
fun print_intarray
  (A: array0 (int)): void = let
  val asz = array0_size (A) // get the size of the array
  val asz = int_of_size (asz) // turn [asz] to be of the type [int]
//
// The integers are to be separated by the string [sep]
//
  fun loop (i: int, sep: string):<cloref1> void =
    if i < asz then
      (if i > 0 then print sep; print A[i]; loop (i+1, sep))
    // end of [if]
in
  loop (0, ", ")
end // end of [print_intarray]
]]></programlisting></informalexample>

</para><!--para-->

<para>We next implement two functions <code>lrotate</code> and
<code>rrotate</code> for rearranging the elements in a given integer array:

<informalexample><programlisting><![CDATA[fun lrotate (
  A: array0 int, i: int, j: int
) : void = let
  fun lshift (
    A: array0 int, i: int, j: int
  ) : void =
  if i < j then (A[i] := A[i+1]; lshift (A, i+1, j))
in
  if i < j then let
    val tmp = A[i] in lshift (A, i, j); A[j] := tmp
  end // end of [if]
end // end of [lrotate]

fun rrotate (
  A: array0 int, i: int, j: int
) : void = let
  fun rshift (
    A: array0 int, i: int, j: int
  ) : void =
  if i < j then (A[j] := A[j-1]; rshift (A, i, j-1))
in
  if i < j then let
    val tmp = A[j] in rshift (A, i, j); A[i] := tmp
  end // end of [if]
end // end of [rrotate]
]]></programlisting></informalexample>


When applied to an array and two valid indexes i and j for the array such
that i is less than or equal to j, <code>lrotate</code> moves
simultaneously the content of cell i into cell j and the content of cell k
to cell k-1 for k ranging from i+1 to j, inclusive. The function
<code>rrotate</code> is similar to <code>lrotate</code> but shuffles
elements in the opposite direction.
</para><!--para-->

<para>Given a natural number n, the following defined function
<code>permute</code> prints out all the permutations consisting of integers
ranging from 1 to n, inclusive while arranging the output according to
the lexicographic ordering on integer sequences.

<informalexample><programlisting><![CDATA[fun permute
  (n: int): void = let
//
  val asz = size_of_int (n)
  val A = array0_make_elt<int> (asz, 0)
//
// Initializing A with integers from 1 to n, inclusive
//
  val () = init (0) where {
    fun init (i: int):<cloref1> void =
      if i < n then (A[i] := i+1; init (i+1))
  } // end of [val]
//
  fun aux (
      i: int
    ) :<cloref1> void =
    if i <= n then aux2 (i, i) else (
      print_intarray (A); print_newline ()
    ) // end of [if]
  and aux2 (
      i: int, j: int
    ) :<cloref1> void =
    if j <= n then let
      val () = (
        rrotate (A, i-1, j-1); aux (i+1); lrotate (A, i-1, j-1)
      ) // end of [val]
    in
      aux2 (i, j+1)
    end // end of [if]
//
in
  aux (1)
end // end of [permute]
]]></programlisting></informalexample>


Note that <code>where</code> is a keyword, and the expression (exp
<code>where</code> <code>{</code> decseq <code>}</code>) for some
expression exp and declaration sequence decseq is equivalent to the
let-expression of the form (<code>let</code> decseq <code>in</code> exp
<code>end</code>). To understand the behavior of the function
<code>aux</code>, let us evaluate <code>aux(1)</code> while assuming that
<code>n</code> is 4 and the 4 elements of the array <code>A</code> are 1,
2, 3, and 4. It should be fairly straightforward to see that this
evaluation leads to the evaluation of <code>aux(2)</code> for 4 times: the
array <code>A</code> contains (1, 2, 3, 4) for the first time, and (2, 1,
3, 4) for the second time, and (3, 1, 2, 4) for the third time, and (4, 1,
2, 3) for the fourth time. With some inductive reasoning, it should not be
difficult to see that evaluating <code>aux(1)</code> indeed leads to all
the permutations being output according to the lexicographic ordering on
integer sequences.
</para><!--para-->

<para>Please find the entire code in this section plus some additional
code for testing <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_EFFECTFUL/permord.dats">on-line</ulink>.
</para>

</sect1><!--id="example_ordering_permutations"-->

<!-- ****** ****** -->

<sect1
id="matrices">

<title>Matrices</title>

<para>A matrix in ATS is just a two-dimensional array but it is
represented by a one-dimensional array and the representation is of the
row-major style (in contrast to the column-major style).  Given a type T,
the type <code>matrix0</code>(T) is for a matrix combined with its number of
rows and number of columns such that each element stored in the matrix is
of the type T. I will loosely refer to values of the type
<code>matrix0</code>(T) as matrices from now on.  If there is a clear need to
avoid potential confusion, I may also refer to them as matrix0-values.
</para><!--para-->

<para>Given a matrix M of dimension m by n, the expression M[i,j] means to
fetch the content of the cell in M that is indexed by (i, j), where i and j
are natural numbers strictly less than m and n, respectively.  The
expression M[i,j] can also be used as a left value. For instance, the
assignment (M[i,j] := exp) means to evaluate exp to a value and then store
the value into the cell in M that is indexed by (i, j).
</para><!--para-->

<para>Various functions and function templates on matrix0-values are declared in the file <ulink
url="http://www.ats-lang.org/DOCUMENT/ANAIRIATS/prelude/SATS/matrix0.sats"><filename>prelude/SATS/matrix0.sats</filename></ulink>,
which is automatically loaded by <command>atsopt</command>. For instance,
three function templates and two polymorphic functions on matrices are
depicted by the following interfaces:

<informalexample><programlisting><![CDATA[fun{a:t@ype} // template
matrix0_make_elt
  (row: size_t, col: size_t, x: a): matrix0 (a)

fun matrix0_row {a:t@ype} (M: matrix0 a): size_t // polyfun
fun matrix0_col {a:t@ype} (M: matrix0 a): size_t // polyfun

fun{a:t@ype}
matrix0_get_elt_at // template
  (M: matrix0 a, i: size_t, j: size_t): a // M[i,j]

fun{a:t@ype}
matrix0_set_elt_at // template
  (M: matrix0 a, i: size_t, j: size_t, x: a): void // M[i,j] := x
]]></programlisting></informalexample>

</para><!--para-->

<para>Given a type T and three values <code>row</code>, <code>col</code> and
<code>init</code> of the types <code>size_t</code>, <code>size_t</code> and T,
respectively, <code>matrix0_make_elt&lt;T&gt; (row, col, init)</code> returns a
matrix of the type <code>matrix0</code>(T) such that the dimension of the
matrix is <code>row</code> by <code>col</code> and each cell in the matrix is
initialized with the value <code>init</code>. Given a matrix M of the type
<code>matrix0</code>(T) for some T, <code>matrix0_row</code>(M) and
<code>matrix0_col</code>(M) return the number of rows and the number of columns
of M, respectively, which are both of the type <code>size_t</code>.  Also,
matrix access and update can be done by calling the function templates
<code>matrix0_get_elt_at</code> and <code>matrix0_set_elt_at</code>, respectively.
</para><!--para-->

<para>As an example, the following defined function
<code>matrix0_transpose</code> turns a given matrix into its transpose:

<informalexample><programlisting><![CDATA[fun{a:t@ype}
matrix0_transpose
  (M: matrix0 a): void = let
//
  val nrow = matrix0_row (M)
//
  fn* loop1
    (i: size_t):<cloref1> void =
    if i < nrow then loop2 (i, 0) else ()
  and loop2
    (i: size_t, j: size_t):<cloref1> void =
    if j < i then let
      val tmp = M[i,j]
    in
      M[i,j] := M[j,i]; M[j,i] := tmp; loop2 (i, j+1)
    end else
      loop1 (i+1)
    // end of [if]
//
in
  loop1 (0)
end // end of [matrix0_transpose]
]]></programlisting></informalexample>


The matrix M is assumed to be a square, that is, its number of rows equals
its number of columns. Note that the two functions <code>loop1</code> and
<code>loop2</code> are defined mutually tail-recursively, and the keyword
<code>fn*</code> indicates the need to combine the bodies of
<code>loop1</code> and <code>loop2</code> so that mutual recursive
tail-calls in these bodies can be compiled into local jumps.
</para><!--para-->

</sect1><!--id="matrices"-->

<!-- ****** ****** -->

<sect1
id="example_estimating_the_constant_pi">

<title>Example: Estimating the Constant Pi</title>

<para>I present as follows a Monte Carlo approach to estimating the
constant Pi, the ratio of the circumference of a circle over its diameter.
</para><!--para-->

<para>Assume that we have a square of the dimension N by N, where N is a
relatively large natural number (e.g., 1000), and a disk of radius 1 that
is contained in the square. Let N2 stand for N*N, that is, the square of N.
If we randomly choose a point inside the square, then the probability for
the point to hit the disk is Pi/N2.
</para><!--para-->

<para>The experiment we use to estimate the constant Pi can be described
as follows.  Given a natural number K, let us randomly choose K points
inside the square in K rounds. In each round, we choose exactly one
point. If the point chosen in round k hits on the disk centered at a
previously chosen point, then we record one hit. Clearly, the expected
number of hits recorded in round k is (k-1)*Pi/N2 as k-1 points have
already being chosen in the previous rounds. Therefore, in K rounds, the
expected total number of hits is (K*(K-1)/2)*Pi/N2. If K is fixed to be N2,
then the expected total number of hits is (N2-1)*Pi/2. It can be proven
that the total number of hits divided by N2 converges to Pi/2 (with
probability 1) as N approaches infinity.
</para><!--para-->

<para>If we implement the above experiment directly based on the given
description, the time-complexity of the implementation is evidently
proportional to N2*N2 as the time spent in round k is proportional to k,
where k ranges from 1 to N2. An implementation as such is simply
impractical for handling N around the order 1000 (and thus N2 around the
order of 1,000,000). To address the issue, we can impose a grid on the
square, dividing it into N2 unit squares (of the dimension 1 by 1).  We
then associate with each unit square a list of chosen points that are
inside it. In each round, we first choose a point randomly inside the
original square; we next locate the unit square that contains this point;
we then only search the lists associated with the unit square or any of its
neighbors to count the number of hits generated by the point chosen in this
round as this point cannot hit any disks centered at points that are not on
these lists.  As each unit square can have at most 8 neighbors and the
average length of the list associated with each square is less than 1
during the experiment, the time spent during each round is O(1), that is,
bounded by a constant. Hence, the time taken by the entire experiment is
O(N2).
</para><!--para-->

<para>An implementation that precisely matches the above description plus
some testing code is available <ulink url="http://www.ats-lang.org/DOCUMENT/INTPROGINATS/CODE/CHAPTER_EFFECTFUL/montecarlo.dats">on-line</ulink>.
</para>

</sect1><!--id="example_estimating_the_constant_pi"-->

<!-- ****** ****** -->

<sect1
id="basic_input_and_output">
<title>Simple Input and Output</title>

<para>Handling I/O in ATS properly requires the availability of both
dependent types and linear types, which I will cover elsewhere. In this
section, I only present a means for allowing the programmer to access
certain very basic I/O functionalities.
</para><!--para-->

<para>A file handle essentially associates a stream (of bytes) with a file
identifier (represented as an integer).  In ATS, the type for file handles
is <code>FILEref</code>. There are three standard file handles, which
are listed as follows:

<itemizedlist>

<listitem>
<para><code>stdin_ref</code>: standard input
</para>
</listitem>

<listitem>
<para><code>stdout_ref</code>: standard output
</para>
</listitem>

<listitem>
<para><code>stderr_ref</code>: standard error output
</para>
</listitem>

</itemizedlist>

Various functions on file handles are declared in the file <ulink
url="http://www.ats-lang.org/DOCUMENT/ANAIRIATS/prelude/SATS/filebas.sats"><filename>prelude/SATS/filebas.sats</filename></ulink>,
which is automatically loaded by <command>atsopt</command>. For instance,
the functions for opening and closing file handles have the following interfaces:

<informalexample><programlisting><![CDATA[fun open_file_exn
  (path: string, mode: file_mode): FILEref
// end of [open_file_exn]

fun close_file_exn (fil: FILEref): void
]]></programlisting></informalexample>


Note that these two functions abort immediately whenever an error occurs.
The type <code>file_mode</code> is for values representing file modes,
which are listed as follows:

<itemizedlist>

<listitem>

<para><code>file_mode_r</code>: opening a file for reading and
positioning the associated stream at the beginning of the file.
</para>

</listitem>

<listitem>

<para><code>file_mode_rr</code>: opening a file for both reading and and
writing and positioning the associated stream at the beginning of the file.
</para>

</listitem>

<listitem>

<para><code>file_mode_w</code>: truncating a given file to zero length or
creating a new one for writing and positioning the associated stream at the
beginning of the file.
</para>

</listitem>

<listitem>

<para><code>file_mode_ww</code>: truncating a given file to zero length or
creating a new one for both reading and writing and positioning the
associated stream at the beginning of the file.
</para>

</listitem>

<listitem>

<para><code>file_mode_a</code>: opening a file for writing and positioning
the associated stream at the end of the file.
</para>

</listitem>

<listitem>

<para><code>file_mode_aa</code>: opening a file for both reading and writing
and positioning the associated stream at the beginning of the file
for reading and at the end for writing.
</para>

</listitem>

</itemizedlist>

As an example, the following short program opens a file handle, outputs the
string "Hello, world!" plus a newline into the stream associated with the
file handle and then closes the file handle:

<informalexample><programlisting><![CDATA[//
// The following line is needed for the compiler
// to gain access to some library I/O functions:
//
staload _(*anon*) = "libc/SATS/stdio.sats"

implement
main () = () where {
  val out = open_file_exn ("hello.txt", file_mode_w)
  val () = fprint_string (out, "Hello, world!\n")
  val () = close_file_exn (out)
} // end of [main]
]]></programlisting></informalexample>


After executing the program, we obtain a file of the name "hello.txt" in
the current working directory containing the expected content. There are
various fprint-functions in ATS for printing out data into the stream in a
given file handle. Often the programmer can simply use the name
<code>fprint</code> to refer to these functions due to the support for
overloading in ATS.
</para><!--para-->

<para>Another two common I/O functions are given the following interfaces:

<informalexample><programlisting><![CDATA[fun input_line (fil: FILEref): Stropt
fun output_line (fil: FILEref, line: string): void
]]></programlisting></informalexample>


The function <code>input_line</code> reads a line from the stream in a
given file handle, and it returns a value of the type
<code>Stropt</code>. For the moment, let us equate <code>Stropt</code> with
the type <code>option0(string)</code>. If the return value is constructed
by <code>option0_none</code>, then the stream has reached the end when
<code>input_line</code> is called. Otherwise, the return value is of the
form <code>option0_some</code>(str), where str represents the line read
from the stream minus the ending newline symbol.  The function
<code>output_line</code> writes its second argument, which is a string, and
a newline symbol into the stream associated with its first argument, which
is a file handle. As an example, the following short program echos each
line received from the standard input onto the standard output:

<informalexample><programlisting><![CDATA[staload _(*anon*) = "libc/SATS/stdio.sats"

implement
main () = loop () where {
  fun loop (): void = let
    val line = input_line (stdin_ref)
  in
    if stropt_is_some (line) then let
      val () = output_line (stdout_ref, stropt_unsome (line))
    in
      loop ()
    end else
      () // loop exits as the end-of-file is reached
    // end of [if]
  end (* end of [loop] *)
} // end of [main]
]]></programlisting></informalexample>


The function <code>stropt_is_some</code> essentially checks whether a given
value is constructed by <code>option0_some</code> (if we equate
<code>Stropt</code> with <code>option0(string)</code>) and the function
<code>stropt_unsome</code> extracts out the argument of
<code>option0_some</code> in a value constructed by
<code>option0_some</code>. Often, typing the CTRL-D character can terminate
the above program for echoing each line of input.
</para><!--para-->

</sect1><!--id="basic_input_and_output"-->

</chapter><!--id="effectful_programming_features"-->


