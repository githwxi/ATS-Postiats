%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="functions">
#title("Functions")

#para("\
Functions play a foundational role in programming.  While it may be
theoretically possible to program without functions (but with loops), such
a programming style is of little practical value. ATS does provide some
language constructs for implementing for-loops and while-loops directly. I,
however, strongly recommend that the programmer implement loops as
recursive functions or more precisely, as tail-recursive functions. This is
a programming style that matches well with more advanced programming
features in ATS that will be presented in this book later.
")

#para("\
The code employed for illustration in this chapter plus some
additional code for testing is available #mycodelink("CHAPTER_FUNCTIONS/", "on-line").
")

<sect1 id="functions_as_a_simple_form_of_abstraction">
#title("Functions as a Simple Form of Abstraction")

#para("Given an expression exp of the type #code("double"), we can
multiply exp by itself to compute its square. If exp is a complex
expression, we may introduce a binding between a name and exp so that exp
is only evaluated once. This idea is shown in the following example:

#atscode("\
let val x = 3.14 * (10.0 - 1.0 / 1.4142) in x * x end
")

Now suppose that we have found a more efficient way to do squaring. In
order to take full advantage of it, we need to modify each occurrence of
squaring in the current program accordingly. This style of programming is
clearly not modular, and it is of little chance to scale. To address this
problem, we can implement a function as follows to compute the square of a
given floating point number:

#atscode("\
fn square (x: double): double = x * x
")

The keyword #code("fn") initiates the definition of a non-recursive
function, and the name following it is for the function to be defined.  In
the above example, the function #code("square") takes one argument of
the name #code("x"), which is assumed to have the type
#code("double"), and returns a value of the type
#code("double"). The expression on the right-hand side (RHS) of the
symbol #code("=") is the body of the function, which is #code("x *
x") in this case. If we have a more efficient way to do squaring, we
can just re-implement the body of the function #code("square")
accordingly to take advantage of it, and there is no other changes needed
(assuming that squaring is solely done by calling #code("square")).
")#comment("para")

#para("\
If #code("square") is a name, what is the expression it refers to? It
turns out that the above function definition can also be written as follows:

#atscode("\
val square = lam (x: double): double => x * x
")

where the RHS of the symbol #code("=") is a lambda-expression
representing an anonymous function that takes one argument of the type
#code("double") and returns a value of the type #code("double"),
and the expression following the symbol #code("=>") is the body of the
function. If we wish, we can change the name of the function argument as
follows:

#atscode("\
val square = lam (y: double): double => y * y
")

This is called alpha-renaming (of function arguments), and the new
lambda-expression is said to be alpha-equivalent to the original one.
")#comment("para")

#para("A lambda-expression is a (function) value. Suppose we have a
lambda-expression representing a binary function, that is, a function
taking two arguments. In order to assign a type of the form (T1, T2) -> T
to the lambda-expression, we need to verify that the body of the function
can be given the type T if the two arguments of the function are assumed to
have the types T1 and T2.  What is stated also applies, <emphasis>mutatis
mutandis</emphasis>, to lambda-expressions representing functions of fewer
or more arguments. For instance, the lambda-expression #code("lam (x:
double): double => x * x") can be assigned the function type
#code("(double) -> double"), which may also be written as #code("double
-> double").
")#comment("para")

#para("Assume that exp is an expression of some function type (T1, T2) ->
T. Note that exp is not necessarily a name or a lambda-expression. If
expressions exp<subscript>1</subscript> and exp<subscript>2</subscript> can
be assigned the types T1 and T2, then the function application
exp(exp<subscript>1</subscript>, exp<subscript>2</subscript>), which may
also be referred to as a function call, can be assigned the type T.  Typing
a function application of fewer or more arguments is handled similarly.
")#comment("para")

#para("Let us now see an example that builds on the previously defined
function #code("square"). The boundary of a ring consists of two
circles centered at the same point. If the radii of the outer and inner
circles are R and r, respectively, then the area of the ring can be
computed by the following function #code("area_of_ring"):

#atscode("\
fn area_of_ring
  (R: double, r: double): double = 3.1416 * (square(R) - square(r))
// end of [area_of_ring]
")

Given that the subtraction and multiplication functions (on floating point
numbers) are of the type #code("(double, double) -> double") and
#code("square") is of the type #code("(double) -> double"), it is a
simple routine to verify that the body of #code("area_of_ring") can be
assigned the type #code("double").
")#comment("para")

</sect1><!--id="functions_as_a_simple_form_of_abstraction"-->

<!-- ****** ****** -->

<sect1 id="function_arity">
#title("Function Arity")

#para("\
The arity of a function is the number of arguments the function
takes.  Functions of arity 0, 1, 2 and 3 are often called nullary, unary,
binary and ternary functions, respectively. For example, the following
function #code("sqrsum1") is a binary function such that its two
arguments are of the type #code("int"):

#atscode("\
fn sqrsum1 (x: int, y: int): int = x * x + y * y
")

We can define a unary function #code("sqrsum2") as follows:
#atscode("\
typedef int2 = (int, int)
fn sqrsum2 (xy: int2): int =
  let val x = xy.0 and y = xy.1 in x * x + y * y end
// end of [sqrsum2]
")

The keyword #code("typedef") introduces a binding between the name
#code("int2") and the tuple type #code("(int, int)"). In other
words, #code("int2") is treated as an abbreviation or alias for
#code("(int, int)"). The function #code("sqrsum2") is unary as it
takes only one argument, which is a tuple of the type #code("int2").
When applying #code("sqrsum2") to a tuple consisting of #code("1")
and #code("~1"), we need to write #code("sqrsum2 @(1, ~1)"). If we
simply write #code("sqrsum2 (1, ~1)"), then the typechecker is to
report an error of arity mismatch as it assumes that #code("sqrsum2")
is applied to two arguments (instead of one that is a tuple).
")#comment("para")

#para("\
Many functional languages (e.g., Haskell and ML) only allow unary
functions. A function of multiple arguments is encoded in these languages
as a unary function taking a tuple as its only argument or it is curried
into a function that takes these arguments sequentially. ATS, however,
provides direct support for functions of multiple arguments. There is even
some limited support in ATS for variadic functions, that is, functions of
indefinite number of arguments (e.g., the famous #code("printf")
function in C). This is a topic I will cover elsewhere.
")#comment("para")

</sect1><!--id="function_arity"-->

<!-- ****** ****** -->

<sect1 id="function_interface">
#title("Function Interface")

#para("\
The interface for a function specifies the type assigned to the
function.  It offers a means to describe a function that is both efficient
and informative. Given a binary function foo of the type (T1, T2) -> T3,
its interface can be written as follows:

#atscode("\
fun foo (arg1: T1, arg2: T2): T3
")

where #code("arg1") and #code("arg2") may be replaced with any
other legal identifiers for function arguments.  For functions of more or
fewer arguments, interfaces can be written in a similar fashion.  For
instance, we have the following interfaces for various functions on
integers:

#atscode("\
fun succ_int (x: int): int // successor
fun pred_int (x: int): int // predecessor

fun add_int_int (x: int, y: int): int // +
fun sub_int_int (x: int, y: int): int // -
fun mul_int_int (x: int, y: int): int // *
fun div_int_int (x: int, y: int): int // /

fun mod_int_int (x: int, y: int): int // modulo
fun gcd_int_int (x: int, y: int): int // greatest common divisor

fun lt_int_int (x: int, y: int): bool // <
fun lte_int_int (x: int, y: int): bool // <=
fun gt_int_int (x: int, y: int): bool // >
fun gte_int_int (x: int, y: int): bool // >=
fun eq_int_int (x: int, y: int): bool // =
fun neq_int_int (x: int, y: int): bool // <>

fun max_int_int (x: int, y: int): int // maximum
fun min_int_int (x: int, y: int): int // minimum

fun print_int (x: int): void
fun tostring_int (x: int): string
")

For now, I mostly use function interfaces for the purpose of presenting
functions.  I will show later how a function definition can be separated
into two parts: a function interface and an implementation that implements
the function interface. Note that separation as such is pivotal for
constructing (large) programs in a modular style.
")#comment("para")

</sect1><!--id="function_interface"-->

<!-- ****** ****** -->

<sect1 id="evaluation_of_function_calls">
#title("Evaluation of Function Calls")

#para("\
Evaluating a function call is straightforward. Assume that we are to
evaluate the function call #code("abs(0.0 - 1.0)") under some
environment ENV0, where the function #code("abs") is defined as
follows:

#atscode("\
fn abs (x: double): double = if x >= 0 then x else ~x
")

We first evaluate the argument of the call to #code("~1.0") under ENV0;
we then extend ENV0 to ENV1 with a binding between #code("x") and
#code("~1.0") and start to evaluate the body of #code("abs") under
ENV1; we evaluate the test #code("x >= 0") to #code("~1.0 >= 0")
and then to #code("false"), which indicates that we take the
else-branch #code("~x") to continue; we evaluate #code("~x") to
#code("~(~1.0)") and then to #code("1.0"); so the evaluation of the
function call #code("abs(0.0 - 1.0)") returns #code("1.0").
")#comment("para")

</sect1><!--id="evaluation_of_function_calls"-->

<!-- ****** ****** -->

<sect1 id="recursive_functions">
#title("Recursive Functions")

#para("\
A recursive function is one that may make calls to itself in its
body. Therefore, a non-recursive function is just a special kind of of
recursive function: the kind that does not make any calls to itself in its
body. I consider recursion the most enabling feature a programming language
can provide. With recursion, we are enabled to do problem-solving based on
a strategy of reduction: In order to solve a problem to which a solution is
difficult to find immediately, we reduce the problem to problems that are
similar but simpler, and we repeat this reduction process if needed until
solutions become apparent. Let us now see some concrete examples of
problem-solving that make use of this reduction strategy.
")#comment("para")

#para("\
Suppose that we want to sum up all the integers ranging from 1 to n,
where n is a given integer. This can be readily done by implementing the
following recursive function #code("sum1"):

#atscode("\
fun sum1 (n: int): int = if n >= 1 then sum1 (n-1) + n else 0
")

Note that the keyword #code("fun") initiates the definition of a
recursive function. To find out the sum of all the integers ranging from
#code("1") to #code("n"), we call #code("sum1 (n)"). The
reduction strategy for #code("sum1 (n)") is straightforward: If
#code("n") is greater than #code("1"), then we can readily find the
value of #code("sum1 (n)") by solving a simpler problem, that is,
finding the value of #code("sum1 (n-1)").
")#comment("para")

#para("\
We can also solve the problem by implementing the following
recursive function #code("sum2") that sums up all the integers in a
given range:

#atscode("\
fun sum2 (m: int, n: int): int =
  if m <= n then m + sum2 (m+1, n) else 0
// end of [sum2]
")

This time, we call #code("sum2 (1, n)") in order to find out the sum of
all the integers ranging from #code("1") to #code("n").  The
reduction strategy for #code("sum2 (m, n)") is also straightforward: If
#code("m") is less than #code("n"), then we can readily find the
value of #code("sum2 (m, n)") by solving a simpler problem, that is,
finding the value of #code("sum2 (m+1, n)"). The reason for #code("sum2
(m+1, n)") being simpler than #code("sum2 (m, n)") is that
#code("m+1") is closer to #code("n") than #code("m") is.
")#comment("para")

#para("\
Given integers m and n, there is another strategy for summing up all
the integers from m to n: If m does not exceed n, we can find the sum of
all the integers from m to (m+n)/2-1 and then the sum of all the integers
from (m+n)/2+1 to n and then sum up these two sums and (m+n)/2. The
following recursive function #code("sum3") is implemented precisely
according to this strategy:

#atscode("\
fun sum3 (m: int, n: int): int =
  if m <= n then let
    val mn2 = (m+n)/2 in sum3 (m, mn2-1) + mn2 + sum3 (mn2+1, n)
  end else 0 // end of [if]
// end of [sum3]
")

It should be noted that the division involved in the expression
#code("(m+n)/2 ") is integer division for which rounding is done by
truncation.
")#comment("para")

</sect1><!--id="recursive functions"-->

<!-- ****** ****** -->

<sect1 id="evaluation_of_recursive_function_calls">
#title("\
Evaluation of Recursive Function Calls\
")

#para("\
Evaluating a call to a recursive function is not much different from
evaluating one to a non-recursive function.  Let #code("fib") be the
following defined function for computing the Fibonacci numbers:

#atscode("\
fun fib (n: int): int =
  if n >= 2 then fib(n-1) + fib(n-2) else n
// end of [fib]
")

Suppose that we are to evaluate #code("fib(2)") under some environment
ENV0. Given that #code("2") is already a value, we extend ENV0 to ENV1
with a binding between #code("n") and #code("2") and start to
evaluate the body of #code("fib") under ENV1; clearly, this evaluation
leads to the evaluation of #code("fib(n-1) + fib(n-2)"); it is easy to
see that evaluating #code("fib(n-1)") and #code("fib(n-2)") under
ENV1 leads to #code("1") and #code("0"), respectively, and the
evaluation of #code("fib(n-1) + fib(n-2)") eventually returns
#code("1") (as the result of #code("1+0")); thus the evaluation of
#code("fib(2)") under ENV0 yields the integer value #code("1").
")#comment("para")

#para("\
Let us now evaluate #code("fib(3)") under ENV0; we extend ENV0
to ENV2 with a binding between #code("n") and #code("3"), and start
to evaluate the body of #code("fib") under ENV2; we then reach the
evaluation of #code("fib(n-1) + fib(n-2)") under ENV2; evaluating
#code("fib(n-1)") under ENV2 leads to the evaluation of
#code("fib(2)") under ENV2, which eventually returns #code("1");
evaluating #code("fib(n-2)") under ENV2 leads to the evaluation of
#code("fib(1)") under ENV2, which eventually returns #code("1");
therefore, evaluating #code("fib(3)") under ENV0 returns #code("2")
(as the result of #code("1+1")).
")#comment("para")

</sect1><!--id="evaluation_of_recursive_function_calls"-->

<!-- ****** ****** -->

<sect1 id="example_coin_changes">
#title("Example: Coin Changes")

#para("\
Let S be a finite set of positive numbers.  The problem we want to
solve is to find out the number of distinct ways for a given integer x to
be expressed as the sum of multiples of the positive numbers chosen from
S. If we interpret each number in S as the denomination of a coin, then the
problem asks how many distinct ways there exist for a given value x to be
expressed as the sum of a set of coins. If we use cc(S, x) for this number,
then we have the following properties on the function cc:

<itemizedlist>

<listitem>
#para("\
cc(S, 0) = 1 for any S.
")
</listitem>

<listitem>
#para("\
If x < 0, then cc(S, x) = 0 for any S.
")
</listitem>

<listitem>
#para("\
If S is empty and x > 0, then cc(S, x) = 0.
")
</listitem>

<listitem>
#para("\
If S contains a number c, then
cc(S, x) = cc(S<subscript>1</subscript>, x) + cc(S, x-c),
where S<subscript>1</subscript> is the set formed by removing c from S.
")
</listitem>

</itemizedlist>

In the following implementation, we fix S to be the set consisting of
1, 5, 10 and 25.

#atscode("\
typedef int4 = (int, int, int, int)

val theCoins = (1, 5, 10, 25): int4

fun coin_get
  (n: int): int =
  if n = 0 then theCoins.0
  else if n = 1 then theCoins.1
  else if n = 2 then theCoins.2
  else if n = 3 then theCoins.3
  else ~1 (* erroneous value *)
// end of [coin_get]

fun coin_change (sum: int) = let
  fun aux (sum: int, n: int): int =
    if sum > 0 then
     (if n >= 0 then aux (sum, n-1) + aux (sum-coin_get(n), n) else 0)
    else (if sum < 0 then 0 else 1)
  // end of [aux]
in
  aux (sum, 3)
end // end of [coin_change]
")

The auxiliary function #code("aux") defined in the body of
the function #code("coin_change") corresponds to the cc function
mentioned above.

When applied to #code("1000"), the function #code("coin_change")
returns #code("142511").
")#comment("para")

#para("\
Note that the entire code in this section plus some additional
code for testing is available #mycodelink("CHAPTER_FUNCTIONS/coin.dats", "on-line").
")

</sect1><!--id="example_coin_changes"-->

<!-- ****** ****** -->

<sect1 id="tail-call_and_tail-recursion">
#title("Tail-Call and Tail-Recursion")

#para("\
Suppose that a function foo makes a call in its body to a function
bar, where foo and bar may be the same function. If the return value of the
call to bar is also the return value of foo, then this call to bar is a
tail-call. If foo and bar are the same, then this is a (recursive) self
tail-call. For instance, there are two recursive calls in the body of the
function #code("f91") defined as follows:

#atscode("\
fun f91 (n: int): int =
  if n >= 101 then n - 10 else f91 (f91 (n+11))
// end of [f91]
")

where the outer recursive call is a self tail-call while the inner one is
not.
")#comment("para")

#para("\
If each recursive call in the body of a function is a tail-call,
then this function is a tail-recursive function. For instance, the
following function #code("sum_iter") is tail-recursive:

#atscode("\
fun sum_iter (n: int, res: int): int =
  if n > 0 then sum_iter (n-1, n+res) else res
// end of [sum_iter]
")

A tail-recursive function is often referred to as an iterative function.
")#comment("para")

#para("\
In ATS, the single most important optimization is probably the one
that turns a self tail-call into a local jump. This optimization
effectively turns every tail-recursive function into the equivalent of a
loop. Although ATS provides direct syntactic support for constructing
for-loops and while-loops, the preferred approach to loop construction in
ATS is in general through the use of tail-recursive functions.
")

</sect1><!--id="tail-call_and_tail-recursion"-->

<!-- ****** ****** -->

<sect1 id="example_solving_the_eight_queens_puzzle">
#title("Example: Solving the Eight Queens Puzzle")

#para("\
The eight queens puzzle is the problem of positioning on a 8x8
chessboard 8 queen pieces so that none of them can capture any other pieces
using the standard chess moves defined for a queen piece. I will present as
follows a solution to this puzzle in ATS, reviewing some of the programming
features that have been covered so far. In particular, please note that
every recursive function implemented in this solution is tail-recursive.
")#comment("para")

#para("\
First, let us introduce a name for the integer constant 8 as follows:

#atscode("\
\#define N 8
")

After this declaration, each occurrence of the name #code("N") is to
be replaced with 8. For representing board configurations, we define
a type #code("int8") as follows:

#atscode("\
typedef int8 = (
  int, int, int, int, int, int, int, int
) // end of [int8]
")

A value of the type #code("int8") is a tuple of 8 integers where the
first integer states the column position of the queen piece on the first
row (row 0), and the second integer states the column position of the queen
piece on the second row (row 1), and so on.
")#comment("para")

#para("\
In order to print out a board configuration, we define the following
functions:

#atscode('\
fun print_dots (i: int): void =
  if i > 0 then (print ". "; print_dots (i-1)) else ()
// end of [print_dots]

fun print_row (i: int): void = begin
  print_dots (i); print "Q "; print_dots (N-i-1); print "\\\n";
end // end of [print_row]

fun print_board (bd: int8): void = begin
  print_row (bd.0); print_row (bd.1); print_row (bd.2); print_row (bd.3);
  print_row (bd.4); print_row (bd.5); print_row (bd.6); print_row (bd.7);
  print_newline ()
end // end of [print_board]
')

The function #code("print_newline") prints out a newline symbol and
then flushes the buffer associated with the standard output. If the reader
is unclear about what buffer flushing means, please feel free to ignore
this aspect of #code("print_newline").
")#comment("para")

#para("\
As an example, if #code("print_board") is called on the board
configuration represented by @(0, 1, 2, 3, 4, 5, 6, 7), then the following
8 lines are printed out:

#atscode("\
Q . . . . . . . 
. Q . . . . . . 
. . Q . . . . . 
. . . Q . . . . 
. . . . Q . . . 
. . . . . Q . . 
. . . . . . Q . 
. . . . . . . Q 
")
")#comment("para")

#para("\
Given a board and the row number of a queen piece on the board, the
following function #code("board_get") returns the column number of the piece:

#atscode("\
fun board_get
  (bd: int8, i: int): int =
  if i = 0 then bd.0
  else if i = 1 then bd.1
  else if i = 2 then bd.2
  else if i = 3 then bd.3
  else if i = 4 then bd.4
  else if i = 5 then bd.5
  else if i = 6 then bd.6
  else if i = 7 then bd.7
  else ~1 // end of [if]
// end of [board_get]
")
")#comment("para")

#para("\
Given a board, a row number i and a column number j,
the following function #code("board_set") returns a new board
that are the same as the original board except for j being the
column number of the queen piece on row i:

#atscode("\
fun board_set
  (bd: int8, i: int, j:int): int8 = let
  val (x0, x1, x2, x3, x4, x5, x6, x7) = bd
in
  if i = 0 then let
    val x0 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 1 then let
    val x1 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 2 then let
    val x2 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 3 then let
    val x3 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 4 then let
    val x4 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 5 then let
    val x5 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 6 then let
    val x6 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else if i = 7 then let
    val x7 = j in (x0, x1, x2, x3, x4, x5, x6, x7)
  end else bd // end of [if]
end // end of [board_set]
")

Clearly, the functions #code("board_get") and #code("board_set")
are defined in a rather unwieldy fashion. This is entirely due to the use
of tuples for representing board configurations. If we could use an array
to represent a board configuration, then the implementation would be much
simpler and cleaner. However, we have not yet covered arrays at this point.
")#comment("para")

#para("\
We now implement two testing functions #code("safety_test1") and
#code("safety_test2") as follows:

#atscode("\
fun safety_test1 (
  i0: int, j0: int, i1: int, j1: int
) : bool =
(*
** [abs]: the absolute value function
*)
  j0 <> j1 andalso abs (i0 - i1) <> abs (j0 - j1)
// end of [safety_test1]

fun safety_test2 (
  i0: int, j0: int, bd: int8, i: int
) : bool =
  if i >= 0 then
    if safety_test1 (i0, j0, i, board_get (bd, i))
      then safety_test2 (i0, j0, bd, i-1) else false
    // end of [if]
  else true // end of [if]
// end of [safety_test2]
")

The functionalities of these two functions can be described as such:

<itemizedlist>
<listitem>
#para("\
The function #code("safety_test1") tests whether a queen piece on row
#code("i0") and column #code("j0") can capture another one on row
#code("i") and column #code("j").
")
</listitem>

<listitem>
#para("\
The function #code("safety_test2") tests whether a queen piece on row
#code("i0") and column #code("j0") can capture any pieces on a
given board with a row number less than or equal to #code("i").
")
</listitem>
</itemizedlist>
")#comment("para")

#para("\
We are now ready to implement the following function
#code("search") based on a standard depth-first search (DFS) algorithm:

#atscode('\
fun search (
  bd: int8, i: int, j: int, nsol: int
) : int =
  if j < N then
    if safety_test2 (i, j, bd, i-1) then let
      val bd1 = board_set (bd, i, j)
    in
      if i+1 = N then let
        val () = print!
          ("This is solution no. ", nsol+1, ":\\\n\\\n")
        val () = print_board (bd1) in search (bd, i, j+1, nsol+1)
      end else search (bd1, i+1, 0, nsol)
    end else search (bd, i, j+1, nsol)
  else if i > 0 then
    search (bd, i-1, board_get (bd, i-1) + 1, nsol)
  else nsol // end of [if]
// end of [search]
')

The return value of #code("search") is the number of distinct solutions
to the eight queens puzzle. The symbol #code("print!") in the body of
#code("search") is a special identifier in ATS: It takes an
indefinite number of arguments and then applies #code("print") to each of
them. Here is the first solution printed out by a call to the function
#code("search"):

#atscode("\
Q . . . . . . . 
. . . . Q . . . 
. . . . . . . Q 
. . . . . Q . . 
. . Q . . . . . 
. . . . . . Q . 
. Q . . . . . . 
. . . Q . . . . 
")

There are 92 distinct solutions in total.
")#comment("para")

#para("\
Note that the entire code in this section plus some additional
code for testing is available #mycodelink("CHAPTER_FUNCTIONS/queens.dats", "on-line").
")

</sect1><!--id="example_solving_the_eight_queens_puzzle"-->

<!-- ****** ****** -->

<sect1 id="mutually_recursive_functions">
#title("Mutually Recursive Functions")

#para("\
A collection of functions are defined mutually recursively if each
function can make calls in its body to any functions in this collection.
Mutually recursive functions are commonly encountered in practice.
")

#para("\
As an example, let P be a function on natural numbers defined as follows:
<itemizedlist>
<listitem>
#para("\
P(0) = 1
")
</listitem>

<listitem>
#para("\
P(n+1) = 1 + the sum of the products of i and P(i) for i ranging from 1 to n
")
</listitem>
</itemizedlist>

Let us introduce a function Q such that Q(n) is the sum of the products of
i and P(i) for i ranging from 1 to n. Then the functions P and Q can be
defined mutually recursively as follows:

<itemizedlist>
<listitem>
#para("\
P(0) = 1
")
</listitem>

<listitem>
#para("\
P(n+1) = 1 + Q(n)
")
</listitem>

<listitem>
#para("\
Q(0) = 0
")
</listitem>

<listitem>
#para("\
Q(n+1) = Q(n) + (n+1) * P(n+1)
")
</listitem>
</itemizedlist>

The following implementation of P and Q is a direct translation of their
definitions into ATS:

#atscode("\
fun P (n:int): int = if n > 0 then 1 + Q(n-1) else 1
and Q (n:int): int = if n > 0 then Q(n-1) + n * P(n) else 0
")

Note that the keyword #code("and") is used to combine function
definitions.
")#comment("para")

</sect1><!--id="mutually-recursive_functions"-->

<!-- ****** ****** -->

<sect1 id="mutual_tail-recursion">
#title("Mutual Tail-Recursion")

#para("\
Suppose that foo and bar are two mutually defined recursive
functions.  In the body of foo or bar, a tail-call to foo or bar is a
mutually recursive tail-call. For instance, the following two functions
#code("isevn") and #code("isodd") are mutually recursive:

#atscode("\
fun isevn (n: int): bool = if n > 0 then isodd (n-1) else true
and isodd (n: int): bool = if n > 0 then isevn (n-1) else false
")

The mutually recursive call to #code("isodd") in the body of
#code("isevn") is a tail-call, and the mutually recursive call to
#code("isevn") in the body of #code("isodd") is also a tail-call.
If we want that these two tail-calls be compiled into local jumps, we
should replace the keyword #code("fun") with the keyword
#code("fn*") as follows:

#atscode("\
fn* isevn (n: int): bool = if n > 0 then isodd (n-1) else true
and isodd (n: int): bool = if n > 0 then isevn (n-1) else false
")

What the ATS compiler does in this case is to combine these two functions
into a single one so that each mutually recursive tail-call in their bodies
can be turned into a self tail-call, which is then ready to be compiled
into a local jump.
")#comment("para")

#para("\
When writing code corresponding to embedded loops in an imperative
programming language such as C or Java, we often need to make sure that
mutually recursive tail-calls are compiled into local jumps. The following
function #code("print_multable") is implemented to print out a standard
multiplication table for nonzero digits:

#atscode('\
fun print_multable () = let
//
  \#define N 9
//
  fn* loop1 (i: int): void =
    if i <= N then loop2 (i, 1) else ()
  and loop2 (i: int, j: int): void =
    if j <= i then let
      val () = if j >= 2 then print " "
      val () = printf ("%dx%d=%2.2d", @(j, i, j*i))
    in
      loop2 (i, j+1) 
    end else let
      val () = print_newline () in loop1 (i+1)
    end // end of [if]
//
in
  loop1 (1)
end // end of [print_multable]
')

The functions #code("loop1") and #code("loop2") are defined
mutually recursively, and the mutually recursive calls in their bodies are
all tail-calls. The keyword #code("fn*") indicates to the ATS compiler
that the functions #code("loop1") and #code("loop2") should be
combined so that these tail-calls can be compiled into local jumps. In a
case where #code("N") is a large number (e.g., 1,000,000), calling
#code("loop1") may run the risk of stack overflow if these tail-calls
are not compiled into local jumps.
")#comment("para")

#para("\
When called, the function #code("print_multable") prints out the
following multiplication table:

#atscode("\
1x1=01
1x2=02 2x2=04
1x3=03 2x3=06 3x3=09
1x4=04 2x4=08 3x4=12 4x4=16
1x5=05 2x5=10 3x5=15 4x5=20 5x5=25
1x6=06 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36
1x7=07 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49
1x8=08 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64
1x9=09 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81
")
")#comment("para")

#para("\
In summary, the very ability to turn mutually recursive tail-calls
into local jumps makes it possible to implement embedded loops as mutually
tail-recursive functions. This ability is indispensable for advocating the
practice of replacing loops with recursive functions in ATS.
")

</sect1><!--id="mutual_tail-recursion"-->

<!-- ****** ****** -->

<sect1 id="envless_functions_and_function_closures">
#title("Envless Functions and Closure Functions")

#para("\
I use <emphasis>envless</emphasis> as a shorthand for
environmentless, which is not a legal word but I guess you have no problem
figuring out what it means.
")

#para("\
An envless function is represented by a pointer pointing to some
place in a code segment where the object code for executing a call to this
function is located. Every function in the programming language C is
envless. A closure function is also represented by a pointer, but the
pointer points to some place in a heap where a tuple is allocated (at
run-time). Usually, the first component of this tuple is a pointer
representing an envless function and the rest of the components represent
some bindings. A tuple as such is often referred to as a closure, which can
be thought of as an envless function paired with an environment. It is
possible that the environment of a closure function is empty, but this does
not equate a closure function with an envless function. Every function in
functional languages such as ML and Haskell is a closure function.
")#comment("para")

#para("\
In the following example, the function #code("sum"), which is
assigned the type #code("(int) -> int"), sums up all the integers
between 1 and a given natural number:

#atscode("\
fun sum (n: int): int = let
  fun loop (
    i: int, res: int
  ) :<cloref1> int =
    if i <= n then loop (i+1, res+i) else res
  // end of [loop]
in
  loop (1(*i*), 0(*res*))
end // end of [sum]
")

The inner function #code("loop") is a closure function as is indicated
by the special syntax #code(":&lt;cloref1&gt;"), and the type assigned
to #code("loop") is denoted by #code("(int, int) -&lt;cloref1&gt;
int"). Hence, envless functions and closure functions can be
distinguished at the level of types.
")#comment("para")

#para("\
If the syntax #code(":&lt;cloref1&gt;") is replaced with the colon
symbol #code(":") alone, the code can still pass typechecking but its
compilation eventually leads to an error indicating that #code("loop")
cannot be compiled into a toplevel function in C. The reason for this error
is due to the body of #code("loop") containing a variable #code("n") that
is neither at toplevel nor a part of the arguments of #code("loop")
itself. It is straightforward to make #code("loop") an envless function by
including #code("n") as an argument in addition to the original ones:

#atscode("\
fun sum (n: int): int = let
  fun loop (
    n:int, i: int, res: int
  ) : int =
    if i <= n then loop (n, i+1, res+i) else res
  // end of [loop]
in
  loop (n, 1(*i*), 0(*res*))
end // end of [sum]
")

As a matter of fact, what happens during compilation is that the first
implementation of #code("sum") and #code("loop") gets translated,
more or less, into the second implementation, and there is no actual
creation of closures (for representing closure functions) at run-time.
")#comment("para")

#para("\
The need for creating closures often appears when the return value
of a function call is a function itself. For instance, the following
defined function #code("addx") returns another function when applied to
a given integer #code("x"), and the returned function is a closure
function, which always adds the integer #code("x") to its own argument:


#atscode("\
fun addx (x: int): int -<cloref1> int = lam y => x + y

val plus1 = addx (1) // [plus1] is of the type int -<cloref1> int
val plus2 = addx (2) // [plus2] is of the type int -<cloref1> int
")

It should be clear that #code("plus1(0)") and #code("plus2(0)")
return #code("1") and #code("2"), respectively.  The closure that
is assigned the name #code("plus1") consists of an envless function and
an environment binding #code("x") to #code("1"). The envless
function can essentially be described by the pseudo syntax #code("lam (env,
y) => env.x + y"), where #code("env") and #code("env.x") refer
to an environment and the value to which #code("x") is bound in that
environment. When evaluating #code("plus1(0)"), we can first bind
#code("env") and #code("y") to the environment in
#code("plus1") and the argument #code("0"), respectively, and then
start to evaluate the body of the envless function in #code("plus1"),
which is #code("env.x + y"). Clearly, this evaluation yields the value
#code("1") as is expected.
")#comment("para")

#para("\
Closures are often passed as arguments to functions that are referred to as
higher-order functions.  It is also fairly common for closures to be
embedded in data structures.\
")

</sect1><!--id="envless_functions_and_function_closures"-->

<!-- ****** ****** -->

<sect1 id="higher-order_functions">
#title("Higher-Order Functions")

#para("\
A higher-order function is a function that take another function as
its argument. For instance, the following defined function
#code("rtfind") is a higher-order one:

#atscode("\
fun rtfind
  (f: int -> int): int = let
  fun loop (
    f: int -> int, n: int
  ) : int =
    if f(n) = 0 then n else loop (f, n+1)
  // end of [loop]
in
  loop (f, 0)
end // end of [rtfind]
")

Given a function from integers to integers, #code("rtfind") searches
for the first natural number that is a root of the function. For instance,
calling #code("rtfind") on the polynomial function #code("lam x => x * x
- x + 110") returns #code("11").  Note that #code("rtfind")
loops forever if it is applied to a function that does not have a root.
")#comment("para")

#para("\
Higher-order functions can greatly facilitate code reuse, and I now
present a simple example to illustrate this point.  The following defined
functions #code("sum") and #code("prod") compute the sum and
product of the integers ranging from 1 to a given natural number,
respectively:

#atscode("\
fun sum (n: int): int = if n > 0 then sum (n-1) + n else 0
fun prod (n: int): int = if n > 0 then prod (n-1) * n else 1
")

The similarity between the functions #code("sum") and #code("prod")
is evident.  We can define a higher-function #code("ifold") and then
implement #code("sum") and #code("prod") based on
#code("ifold"):

#atscode("\
fun ifold
  (n: int, f: (int, int) -> int, ini: int): int =
  if n > 0 then f (ifold (n-1, f, ini), n) else ini
// end of [ifold]

fun sum (n: int): int = ifold (n, lam (res, x) => res + x, 0)
fun prod (n: int): int = ifold (n, lam (res, x) => res * x, 1)
")

If we ever want to compute the sum of the squares of the integers ranging
from 1 to a given natural number, we can readily define a function based on
#code("ifold") to do it:

#atscode("\
fun sqrsum (n: int): int = ifold (n, lam (res, x) => res + x * x, 0)
")

As more features of ATS are introduced, higher-order functions will become
even more effective in facilitating code reuse.
")#comment("para")

</sect1><!--id="higher-order_functions"-->

<!-- ****** ****** -->

<sect1 id="example_binary_search">
#title("Example: Binary Search")

#para("\
While binary search is often performed on an ordered array to check
whether a given element is stored in that array, it can also be employed to
compute the inverse of an increasing or decreasing function on integers. In
the following code, the defined function #code("bsearch_fun") returns
an integer i0 such that f(i) <= x0 holds for i ranging from lb to i,
inclusively, and x0 < f(i) holds for i ranging from i+1 to ub, inclusively:

#atscode("\
//
// The type [uint] is for unsigned integers
//
fun bsearch_fun (
  f: int -<cloref1> uint
, x0: uint, lb: int, ub: int
) : int =
  if lb <= ub then let
    val mid = lb + (ub - lb) / 2
  in
    if x0 < f (mid) then
      bsearch_fun (f, x0, lb, mid-1)
    else
      bsearch_fun (f, x0, mid+1, ub)
    // end of [if]
  end else ub // end of [if]
// end of [bsearch_fun]
")

As an example, the following function #code("isqrt") is defined based
on #code("bsearch_fun") to compute the integer square root of a given
natural number, that is, the largest integer whose square is less than or
equal to the given natural number:

#atscode("\
//
// Assuming that [uint] is of 32 bits
//
val ISQRT_MAX = (1 << 16) - 1 // = 65535
fun isqrt (x: uint): int =
  bsearch_fun (lam i => square ((uint_of_int)i), x, 0, ISQRT_MAX)
// end of [isqrt]
")

Note that the function #code("uint_of_int") is for casting a signed
integer into an unsigned integer and the function #code("square")
returns the square of its argument.
")#comment("para")

#para("\
Please find #mycodelink("CHAPTER_FUNCTIONS/bsearch.dats", "on-line")
the entire code in this section plus some additional code for testing.
")

</sect1><!--id="example_binary_search"-->

<!-- ****** ****** -->

<sect1 id="currying_and_uncurrying">

#title("Currying and Uncurrying")

#para("\
Currying, which is named after the logician Haskell Curry, means to
turn a function taking multiple arguments simultaneously into a function of
the same body (modulo corresponding recursive function calls being changed
accordingly) that takes these arguments sequentially. Uncurrying means
precisely the opposite of currying. In the following code, both of the
defined functions #code("acker1") and #code("acker2") implement the
Ackermann's function (which is famous for being recursive but not primitive
recursive):

#atscode('\
fun acker1 (m: int, n: int): int =
  if m > 0 then
    if n > 0 then acker1 (m-1, acker1 (m, n-1)) else acker1 (m-1, 1)
  else n+1

fun acker2 (m: int) (n: int): int =
  if m > 0 then
    if n > 0 then acker2 (m-1) (acker2 m (n-1)) else acker2 (m-1) 1
  else n+1
')

The function #code("acker2") is a curried version of
#code("acker1") while the function #code("acker1") in an uncurried
version of #code("acker2"). Applying #code("acker2") to an integer
value generates a linear function closure, which I will explain elsewhere.
")#comment("para")

#para("\
In functional languages such as ML and Haskell, a function of multiple
arguments needs to be either curried or translated into a corresponding
unary function of a single argument that itself is a tuple. In such
languages, currying often leads to better performance at run-time and thus
is preferred. In ATS, functions of multiple arguments are supported
directly. Also, given a function of multiple arguments, a curried version
of the function is likely to perform less efficiently at run-time than the
function itself (due to the treatment of curried functions by the ATS
compiler <command>atsopt</command>).  Therefore, the need for currying in
ATS is greatly diminished. Unless convincing reasons can be given, currying
is in general not a recommended programming style in ATS.
")#comment("para")

</sect1><!--id=""currying_and_uncurrying"-->

</chapter><!--id="functions"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
