%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="introduction_to_views_and_viewtypes">
#title("Introduction to Views and Viewtypes")

#para('\

Probably the single most forceful motivation shaping the development of ATS
is to make ATS a programming language that can be employed effectively to
construct safe and reliable programs running in the kernels of operating
systems. Instead of following seemingly natural approaches that often carve
out a "safe" subset of C and/or put wrappers around "unsafe" programming
features in C, ATS relies on the paradigm of programming with
theorem-proving to prevent resources such as memory from being misused or
mismanaged, advocating an approach to safety that is both general and
flexible. For example, a well-typed program constructed in ATS cannot cause
buffer overrun at run-time even though pointer arithmetic is fully
supported in ATS. More specifically, if a pointer is to be dereferenced,
ATS requires that a proof be given that attests to the safety of the
dereferencing operation. Proofs of this kind are constructed to demonstrate
the validity of linear propositions, which are referred to as views in ATS,
for classifying resources as well as capabilities.

')

#para('\

Please find #mycodelink("CHAPTER_VVTINTRO/", "on-line") the code presented
for illustration in this chapter.

')

<sect1 id="views_for_pointers">
#title("Views for Memory Access through Pointers")

#para('\

A view is a linear version of prop, where the word #emph("linear") comes
from #emph("linear logic"), a resource-aware logic invented by Jean-Yves
Girard. There is a built-in sort #code("view") for static terms
representing views.  Given a type T and a memory location L, a view of the
form T@L can be formed to indicate a value of the type T being stored in
the memory at the location L, where #code("@") is a special infix operator.
Views of this form are extremely common in practice, and they are often
referred to as @-views (or at-views).  As an example, the following
function templates #code("ptr_get0") and #code("ptr_set0"), which reads and
writes through a given pointer, are assigned types containing @-views:

')

#atscode('\
fun{a:t@ype}
ptr_get0 {l:addr} (pf: a @ l | p: ptr l): (a @ l | a)

fun{a:t@ype}
ptr_set0 {l:addr} (pf: a? @ l | p: ptr l, x: a): (a @ l | void)
')

#para('\

Note that #code("ptr") is a type constructor that forms a type
#code("ptr")(L) when applied to a static term L of the sort #code("addr"),
and the only value of the type #code("ptr")(L) is the pointer that points
to the location denoted by L.

')

#para('\

Given a type T, the function #code("ptr_get0")&lt;T&gt; is assigned the
following type:

#atscode('\
{l:addr} (T @ l | ptr (l)) -> (T @ l | T)
')

This type indicates that the function #code("ptr_get0")&lt;T&gt; returns a
proof of the view T@L and a value of the type T when applied to a proof of
the view T@L and a pointer of the type #code("ptr")(L) for some
L. Intuitively speaking, a proof of the view T@L, which is a form of
resource as T@L is linear, is #emph("consumed") when it is passed to
#code("ptr_get0")&lt;T&gt;, and another proof of the view T@L is generated
when #code("ptr_get0")&lt;T&gt; returns. Notice that a proof of the view
T@L must be returned for otherwise subsequent accesses to the content
stored at the memory location L would have been precluded.

')

#para('\

Similarly, the function #code("ptr_set0")&lt;T&gt; is
assigned the following type:

')

#atscode('\
{l:addr} (T? @ l | ptr (l)) -> (T @ l | void)
')

#para('\

Note that T? is a type for values of size #code("sizeof")(T) that are
assumed to be uninitialized.  The function #code("ptr_set0")&lt;T&gt;
returns a proof of the view T@L when applied to a proof of the view
T?@L, a pointer of the type #code("ptr")(L) and a value of the type T. The
use of the view T?@L indicates that the memory location at L is assumed
to be uninitialized when #code("ptr_set0")&lt;T&gt; is called.

')

#para('\

As an example, a function template #code("swap0") is implemented below
for swapping memory contents at two given locations:

')

#atscode('\
fn{a:t@ype}
swap0 {l1,l2:addr} (
  pf1: a @ l1, pf2: a @ l2 | p1: ptr l1, p2: ptr l2
) : (a @ l1, a @ l2 | void) = let
  val (pf1 | tmp1) = ptr_get0<a> (pf1 | p1)
  val (pf2 | tmp2) = ptr_get0<a> (pf2 | p2)
  val (pf1 | ()) = ptr_set0<a> (pf1 | p1, tmp2)
  val (pf2 | ()) = ptr_set0<a> (pf2 | p2, tmp1)
in
  (pf1, pf2 | ())
end // end of [swap0]
')

#para('\

Compared to a corresponding implementation in C, the verbosity of this one
in ATS is evident. In particular, the need for #emph("threading") linear
proofs through calls to functions that make use of resources can often
result in a lot of #emph("administrative") code to be written. I now
present some special syntax to significantly alleviate the need for such
administrative code.

')

#para('\

The function templates #code("ptr_get1") and #code("ptr_set1") are given
the following interfaces:

')

#atscode('\
fun{a:t@ype}
ptr_get1 {l:addr} (pf: !a @ l >> a @ l | p: ptr l): a

fun{a:t@ype}
ptr_set1 {l:addr} (pf: !a? @ l >> a @ l | p: ptr l, x: a): void
')


#para('\

Clearly, for each type T, the function
#code("ptr_get1")&lt;T&gt; is assigned the following type:

')

#atscode('\
{l:addr} (!T @ l >> T @ l | ptr(l)) -> T
')

#para('\

Given a linear proof pf of the view T@L for some L and a pointer p of the
type #code("ptr")(L), the function call #code("ptr_get1")&lt;T&gt;(pf, p)
is expected to return a value of the type T. However, the proof pf is not
consumed. Instead, it is still a proof of the view T@L after the function
call returns. Similarly, the function #code("ptr_set1")&lt;T&gt; is
assigned the following type:

')

#atscode('\
{l:addr} (!T? @ l >> T @ l | ptr(l), T) -> void
')

#para('\

Given a linear proof pf of the view T?@L for some L, a pointer p of the
type #code("ptr")(L) and a value v of the type T, the function call
#code("ptr_set1")&lt;T&gt;(pf, p, v) is expected to return the void value
while changing the view of pf from T?@L to T@L.  In general, assume that f
is given a type of the following form for some views V1 and V2:

')

#atscode('\
(...,!V1 >> V2, ...) -> ...
')

#para('\

Then a function call f(..., pf, ...) on some proof variable pf of the view
V1 is to change the view of pf into V2 upon its return.  In the case where
V1 and V2 are the same, !V1 >> V2 can simply be written as !V1.  As an
example, a function template #code("swap1") for swapping the contents at
two given memory locations is implemented as follows:

')

#atscode('\
fn{a:t@ype}
swap1 {l1,l2:addr} (
  pf1: !a @ l1, pf2: !a @ l2 | p1: ptr l1, p2: ptr l2
) : void = let
  val tmp = ptr_get1<a> (pf1 | p1)
  val () = ptr_set1<a> (pf1 | p1, ptr_get1<a> (pf2 | p2))
  val () = ptr_set1<a> (pf2 | p2, tmp)
in
  // nothing
end // end of [swap1]
')

#para('\

Clearly, this implementation is considerably cleaner when compared to the
above implementation of #code("swap0").

')

#para('\

A further simplied implementation of #code("swap1") is given as follows:

')

#atscode('\
fn{a:t@ype}
swap1 {l1,l2:addr} (
  pf1: !a @ l1, pf2: !a @ l2 | p1: ptr l1, p2: ptr l2
) : void = let
  val tmp = !p1 in !p1 := !p2; !p2 := tmp
end // end of [swap1]
')

#para('\

Given a pointer p of the type #code("ptr")(L) for some L, !p yields the
value stored at the memory location L.  The typechecker first searches for
a proof of the view T@L for some T among all the currently available proofs
when typechecking !p; if such a proof pf is found, then !p is essentially
elaborated into #code("ptr_get1")(pf | p) and then typechecked. As !p is a
left-value (which is to be explained later in detail), it can also be used
to form an assignment like !p := v for some value v. The typechecker
elaborates !p := v into #code("ptr_set1")(pf | p, v) for the sake of
typechecking if a proof of the at-view T@L can be found for some type T
among all the currently available proofs. Note that this implementation of
#code("swap1") makes no use of administrative code for handling linear
proofs explicitly.

')

</sect1>#comment("sect1/id=views_for_pointers")

<sect1 id="viewtypes_as_combination">
#title("Viewtypes as a Combination of Views and Types")

#para("\

A linear type in ATS is given the name #emph("viewtype"), which is chosen
to indicate that a linear type consists of two parts: one part for views
and the other for types. For instance, given a view V and a type T, then
the tuple (V | T) is a viewtype, where the bar symbol (|) is a separator
(just like a comma) to separate views from types. What seems a bit surprising
is the opposite: For each viewtype VT, we may assume the existence of a
view V and a type T such that VT is equivalent to (V | T). Formally, this T
can be referred as VT?! in ATS.  This somewhat unexpected interpretation of
linear types is a striking novelty of ATS, which stresses that the
linearity of a viewtype comes #emph("entirely") from the view part residing
within it.

")

#ignoretxt(
#atscode('\
praxi viewtype_split {vt:viewt@ype}
  (x: &vt >> t): #[t:t@ype] [v:view] (v, (v | &t >> vt) -<prf> void)
// end of [viewtype_split]
'))

#para("\

The built-in sorts #code("viewtype") and #code("viewt@ype") are for static
terms representing viewtypes whose type parts are of the sorts
#code("type") and #code("t@ype"), respectively. In other words, the former
is assigned to viewtypes for linear values of the size equal to that of a
pointer and the latter to viewtypes for linear values of unspecified size.
For example, #code("tptr") is defined as follows that takes a type and an
address to form a viewtype (of the sort #code("viewtype")):

")

#atscode('\
viewtypedef tptr (a:t@ype, l:addr) = (a @ l | ptr l)
')

#para('\

Given a type T and an address L, the viewtype #code("tptr")(T, L) is for a
pointer to L paired with a linear proof stating that a value of the type T
is stored at L. If we think of a counter as a pointer paired with a proof
stating that the pointer points to an integer (representing the count),
then the following defined function #code("getinc") returns the current
count of a given counter after increasing it by 1:\

')

#atscode('\

fn getinc
  {l:addr} {n:nat} (
  cnt: !tptr (int(n), l) >> tptr (int(n+1), l)
) : int(n) = n where {
  val n = ptr_get1<int(n)> (cnt.0 | cnt.1)
  val () = ptr_set1<int(n+1)> (cnt.0 | cnt.1, n+1)
} // end of [getinc]
')

#para("
A particularly interesting example of a viewtype is the following one:
")

#atscode('\
viewtypedef cloptr
  (a:t@ype, b:t@ype, l:addr) =
  [env:t@ype] (((&env, a) -> b, env) @ l | ptr l)
// end of [cloptr]
')

#para('\

Given two types A and B, a pointer to some address L where a closure
function is stored that takes a value of the type A to return a value of
the type B can be given the viewtype #code("cloptr")(A, B, L). Note that a
closure function is just an envless function paired with an environment
containing bindings for variables in the body of the closure function that
are introduced from outside. In the function type #code("(&amp;env, a) ->
b"), the symbol #code("&amp;") indicates that the corresponding function
argument is passed by reference, that is, the argument is required to be a
left-value and what is actually passed at run-time is the address of the
left-value.  I will cover the issue of call-by-reference elsewhere in more
details.  The following piece of code demonstrates a pointer to a closure
function being called on a given argument:\

')

#atscode('\
fun{a:t@ype}{b:t@ype}
cloptr_app {l:addr} (
  pclo: !cloptr (a, b, l), x: a
) : b = let
  val p = pclo.1
  prval pf = pclo.0 // take out pf: ((&env, a) -> b, env) @ l
  val res = !p.0 (!p.1, x)
  prval () = pclo.0 := pf // put the proof pf back
in
  res
end // end of [cloptr]
')

#para('\

Note that the linear proof in #code("pclo") is first taken out so that the
code for dereferencing p (denoted by the syntax #code("!p")) can pass
typechecking, and it is then returned so that the type of #code("pclo") is
restored to its original one. The very ability to explain within ATS
programming features such as closure function is a convincing indication of
the expressiveness of the type system of ATS.

')

</sect1>#comment("sect1/id=viewtypes_as_combination")


<sect1 id="lval_and_cbr">
#title("Left-Values and Call-by-Reference")

#para('\

In its simplest form, a left-value is just a pointer paired with a linear
proof attesting to a value (of some type) being stored at the location to
which the pointer points. The name #emph("left-value") stems from such a
value being allowed to appear on the left-hand side of an assignment
statement (in languages like C). Often, a left-value is intuitively
explained as a value with an address attached to it. Note that whatever
representation chosen for a left-value must make it possible to identify
both the pointer and the linear proof (of some at-view) that are associated
with the left-value.

')

#para('\

In ATS, the simplest expression representing a left-value is #code("!")p,
where #code("!")  is a special symbol and p a value of the type
#code("ptr")(L) for some address L. When this expression is typechecked, a
proof of T@L for some type T is required to be found among the currently
available proofs. I will introduce additional forms of left values
gradually.

')

#para('\

The default strategy for passing a function argument in ATS is
call-by-value. However, it is also allowed in ATS to specify that
call-by-reference is chosen for passing a particular function argument. By
call-by-reference, it is meant that the argument to be passed must be a
left-value and what is actually passed is the address of the left-value
(instead of the value stored at the address). For example, the following
defined function #code("swap2") makes essential use of call-by-reference:

')

#atscode('\
fn{a:t@ype}
swap2 (
  x1: &a, x2: &a
) : void = let
  val tmp = x1 in x1 := x2; x2 := tmp
end // end of [swap2]
')

#para('\

Note that the special symbol #code("&amp;") in front of the type of a
function argument indicates that the argument needs to be passed according
to the call-by-reference strategy. The following code implements
#code("swap1") based on #code("swap2"):

')

#atscode('\
fn{a:t@ype}
swap1 {l1,l2:addr} (
  pf1: !a @ l1, pf2: !a @ l2 | p1: ptr l1, p2: ptr l2
) : void = swap2 (!p1, !p2)
')

#para('\

When the call #code("swap2 (!p1, !p2)") is evaluated at run-time, the
parameters actually being passed are the two pointers #code("p1") and
#code("p2") (rather than the values stored at the locations to which these
two pointers point).\

')

</sect1>#comment("sect1/id=lval_and_cbr")

<sect1 id="stack-allocated_variables">
#title("Stack-Allocated Variables")

#para('\

Given a type T and an address L, how can a proof of the view T@L be
obtained in the first place? There are actually a variety of methods for
obtaining such proofs in practice, and I present one as follows that is
based on stack-allocation of local variables.

')

#para('\

In the body of the following function #code("foo"), some stack-allocated
local variables are declared:

')

#atscode('\
fn foo (): void = let
  var x0: int // view@ (x0): int? @ x0
  val () = x0 := 0 // view@ (x0): int(0) @ x0
  var x1: int = 1 // view@ (x1): int(1) @ x1
//
// [with] is a keyword in ATS
//
  var y: int with pfy // pfy is an alias of view@ (y): int? @ y
  val () = y := 2 // pfy = view@ (y): int(2) @ y
  var z: int with pfz = 3 // pfz is an alias of view@ (z): int(3) @ z
in
  // nothing
end // end of [f]
')

#para('\

The keyword #code("var") is for declaring a local variable. When a variable
is declared, either its type or its initial value needs to be given. If a
variable is declared without a type, then the type of its initial value is
assumed to be its type. Assume that a variable x is declared of type
T. Then the pointer to the location of the variable is denoted by
#code("&amp;")x, and its associated linear proof (of some at-view) can be
referred to as #code("view@")(x), where #code("view@") is a keyword. A
variable is another form of left-value in ATS. In the body of #code("foo"),
#code("x0") is declared to be a variable of the type #code("int") and then
it is initialized with the integer 0; #code("x1") is declared to be a
variable of the type #code("int") that is given the initial value 1;
#code("y") is declared to be a variable of the type #code("int") while
#code("pfy") is introduced as an alias of #code("view@(y)"), and then
#code("y") is initialized with the integer 2; #code("z") is declared to be
a variable of the type #code("int") that is given the initial value 3 while
#code("pfz") is introduced as an alias of #code("view@(z)").

')

#para('\

The following code gives an implementation of the factorial function:

')

#atscode('\
fn fact {n:nat}
  (n: int n): int = let
  fun loop {n:nat} {l:addr} .<n>.
    (pf: !int @ l | n: int n, res: ptr l): void =
    if n > 0 then let
      val () = !res := n * !res in loop (pf | n-1, res)
    end // end of [if]
  // end of [loop]
  var res: int with pf = 1
  val () = loop (pf | n, &res) // &res: the pointer to res
in
  res
end // end of [fact]
')

#para('\

Note that the variable #code("res") holds the intermediate result during
the execution of the loop. As #code("res") is stack-allocated, there is no
generated garbage after a call to #code("fact") is evaluated. When this
style of programming is done in C, there is often a concern about the
pointer to #code("res") being derefenced after a call to #code("fact")
returns, which is commonly referred to as derefencing a dangling pointer.
This concern is completely eliminated in ATS as it is required by the type
system of ATS that a linear proof of the at-view associated with the
variable #code("res") be present at the end of legal scope for
#code("res"). More specifically, if x is a declared variable of the type T,
then a linear proof of the view T?@L, where L is the address of x, must be
available when typechecking reaches the end of the scope for x.  This
requirement ensures that a variable can no longer be accessed after the
portion of the stack in which it is allocated is reclaimed as no linear
proof of the at-view associated with the variable is ever available from
that point on.

')

</sect1>#comment("sect1/id=stack_allocated_variables")

</chapter><!--id="introduction_to_views_and_viewtypes"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
