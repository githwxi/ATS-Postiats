%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="datatypes">
#title("Datatypes")

#para("\
The feature of datatypes in ATS in largely taken from ML.
")

#para("\
A datatype is
like a tagged union type. For each datatype, there are some constructors
associated with it, and these constructors are needed for constructing
values of the datatype.  As an example, the following syntax declares a
datatype named #stacode("intopt"):

#atscode("\
datatype intopt =
  | intopt_none of () | intopt_some of (int)
// end of [intopt]
")

There are two constructors associated with #stacode("intopt"):
#dyncode("intopt_none"), which is nullary, and #dyncode("intopt_some"),
which is unary. For instance, #dyncode("intopt_none()") and
#dyncode("intopt_some(1)") are two values of the type #stacode("intopt").
In order for accessing components in such values, a mechanism often
referred to as pattern-matching is provided in ATS. I will demonstrate
through examples that datatypes plus pattern matching can offer not only
great convenience in programming but also clarity in code.\

")#comment("para")

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_DATATYPE/", "on-line").\

")

<sect1 id="patterns">
<title>Patterns</title>

#para("\
Patterns in ATS can be defined inductively as follows:

<itemizedlist>

<listitem>
#para("\

Certain constant values such as integers, booleans, chars, floating point
numbers, and strings are patterns.\

")
</listitem>

<listitem>
#para("The void-value () is a pattern.")
</listitem>

<listitem>
#para("\
The underscore symbol #dyncode("_") represents a special wildcard pattern.
")
</listitem>

<listitem>
#para("\
Variables are patterns.
")
</listitem>

<listitem>
#para("
A tuple of patterns, either boxed or unboxed, is a pattern.
")
</listitem>

<listitem>
#para("
A record of patterns, either boxed or unboxed, is a pattern.
")
</listitem>

<listitem>
#para("\

Given a constructor C, a pattern can be formed by applying C to a given
list of patterns.\

")
</listitem>

<listitem>
#para("\

Given a variable x and a pattern pat, (x #dyncode("as") pat) is a
reference-pattern, where #dyncode("as") is a keyword.\

")
</listitem>

<listitem>
#para("
Some other forms of patterns will be introduced elsewhere.
")
</listitem>

</itemizedlist>

Each variable can occur at most once in a given pattern, and this is
referred as the linearity restriction on variables in patterns. For
instance, (x, x) is not a legal pattern as the variable x appears twice in
it. However, this restriction does not apply to the variable #dyncode("_"),
which represents the wildcard pattern.\

")#comment("para")

</sect1><!--id="patterns"-->

#comment(" ****** ****** ")

<sect1
id="pattern-matching">
<title>Pattern-Matching</title>

#para("\

Pattern matching means matching values against patterns. In the case where
a value matches a pattern, a collection of bindings are generated between
the variables in the pattern and certain components in the
value. Pattern-matching is performed according to the following set of
rules:

<itemizedlist>

<listitem>
#para("\

A value that matches a constant pattern must be the same constant, and this
matching generates no bindings.\

")
</listitem>

<listitem>
#para("\

The void-value () only matches the void-pattern (), and this matching
generates no bindings.\

")
</listitem>

<listitem>
#para("\
Any value can match the wildcard pattern, and this matching generates no bindings.
")
</listitem>

<listitem>
#para("\

Any value can match a variable pattern, and this matching generates a
binding between the variable and the value.\

")
</listitem>

<listitem>
#para("\

A tuple-value matches a tuple-pattern if they are of the same length and
each value component in the former matches the corresponding pattern
component in the latter, and this matching generates a collection of
bindings that is the union of the bindings generated from matching the
value components in the tuple-value against the pattern components in the
tuple-pattern.\

")
</listitem>

<listitem>
#para("\

A record-value matches a record-pattern if they have the same field names
and each value component in the former matches the corresponding pattern
component in the latter, and this matching generates a collection of
bindings that is the union of the bindings generated from matching the
value components in the record-value against the pattern components in the
record-pattern.\

")
</listitem>

<listitem>
#para("\

Given a pattern formed by applying a constructor C to some pattern
arguments, a value matches this pattern if the value is formed by applying
C to some value arguments matching the pattern arguments, and this matching
generates a collection of bindings that is the union of the bindings
generated from matching the value arguments against the pattern arguments.\

")
</listitem>

<listitem>
#para("\

Given a referenced pattern (x #dyncode("as") pat), a value matches the
pattern if it matches pat, and this matching generates a collection of
bindings that extends the bindings generated from matching the value
against pat with a binding from x to the value.\

")
</listitem>

</itemizedlist>

Suppose we have a tuple-value (0, 1, 2, 3) and a tuple-pattern (0, _, x,
y). Then the value matches the pattern and this matching yields bindings
from x and y to 2 and 3, respectively.\

")#comment("para")

</sect1><!--id="pattern-matching"-->

#comment(" ****** ****** ")

<sect1
id="matching_clauses_and_case-expressions">
<title>Matching Clauses and Case-Expressions</title>

#para("\
Given a pattern pat and an expression exp, (pat #dyncode("=>") exp) is a
matching clause. The pattern pat and the expression exp are referred to as
the guard and the body of the matching clause.
")

#para("\

Given an expression exp0 and a sequence of matching clauses clseq, a
case-expression can be formed as such: (#dyncode("case") exp0
#dyncode("of") clseq). To evaluate the case-expression under a given
environment ENV0, we first evaluate exp0 under ENV0 to a value. If this
value does not match the guard of any clause in clseq, then the evaluation
of the case-expression aborts. Otherwise, we choose the first clause in
clseq such that the value matches the guard of the clause. Let ENV1 be the
environment that extends ENV0 with the bindings generated from this
matching, and we evaluate the body of the chosen clause under ENV1. The
value obtained from this evaluation is the value of the case-expression
being evaluated.  ")

</sect1><!--id="matching_clauses_and_case-expressions"-->

#comment(" ****** ****** ")

<sect1
id="enumerative_datatypes">
<title>Enumerative Datatypes</title>
#para("\

The simplest form of datatypes is for enumerating a finite number of
constants. For instance, the following concrete syntax introduces a
datatype of the name #stacode("wday"):

#atscode("\
datatype wday =
  | Monday of ()
  | Tuesday of ()
  | Wednesday of ()
  | Thursday of ()
  | Friday of ()
  | Saturday of ()
  | Sunday of ()
// end of [wday]
")

where the first bar symbol (|) is optional.  There are 7 nullary
constructors introduced in the datatype declaration: #dyncode("Monday")
through #dyncode("Sunday"), which are for constructing values of the type
#stacode("wday"). For instance, #dyncode("Monday()") is a value of the type
#dyncode("wday"). Given a nullary constructor C, we can write C for C() as
a value. For instance, we can write #dyncode("Monday") for
#dyncode("Monday()"). However, one should <emphasis>not</emphasis> assume
that #dyncode("Tuesday") is something like #dyncode("Monday+1").\

")#comment("para")

#para("\

The following code implements a function that tests whether a given value
of the type #stacode("wday") is a weekday or not:

#atscode("\
fun isWeekday
  (x: wday): bool = case x of
  | Monday() => true // the first bar (|) is optional
  | Tuesday() => true
  | Wednesday() => true
  | Thursday() => true
  | Friday() => true
  | Saturday() => false
  | Sunday() => false
// end of [isWeekday]
")

Given a unary constructor C, C() is a pattern that can only match the value
C(). Note that C() <emphasis>cannot</emphasis> be written as C when it is
used as a pattern. If #dyncode("Monday()") is written as #dyncode("Monday") in
the body of the function #dyncode("isWeekday"), then an error message is to be
reported during typechecking, indicating that all the clauses after the
first one are redundant. This is simply due to #dyncode("Monday") being
treated as a variable pattern, which is matched by any value. A likely more
sensible implementation of #dyncode("isWeekday") is given as follows:

#atscode("\
fun isWeekday
  (x: wday): bool = case x of
  | Saturday() => false | Sunday() => false | _ => true
// end of [isWeekday]
")

This implementation works because pattern-matching is done sequentially at
run-time: If a value of the type #stacode("wday") does not match either of
#dyncode("Saturday()") and #dyncode("Sunday()"), then it must match one of
#dyncode("Monday()") , #dyncode("Tuesday()") , #dyncode("Wednesday()") ,
#dyncode("Thursday()"), and #dyncode("Friday()").\

")#comment("para")

</sect1><!--id="enumerative_datatypes"-->

#comment(" ****** ****** ")

<sect1
id="recursive_datatypes">
<title>Recursively Defined Datatypes</title>

#para("\

A recursively defined datatype (or recursive datatype for short) is one
such that its associated constructors may form values by applying to values
of the datatype itself. For instance, the following declared datatype
#stacode("charlst") is recursive:

#atscode("\
datatype charlst =
  | charlst_nil of () | charlst_cons of (char, charlst)
// end of [charlst]
")

When applied to a character and a value of the type #stacode("charlst"),
the constructor #dyncode("charlst_cons") forms a value of the type
#stacode("charlst"). As an example, the following value represents a
character list consisting of 'a', 'b' and 'c':

#atscode("\
charlst_cons('a', charlst_cons('b', charlst_cons('c', charlst_nil())))
")

We can define a function #dyncode("charlst_length") as follows to compute
the length of a given character list:

#atscode("\
fun charlst_length
  (cs: charlst): int = case cs of
  | charlst_cons (_, cs) => 1 + charlst_length (cs)
  | charlst_nil () => 0
// end of [charlst_length]
")

Note that this implementation is recursive but not tail-recursive. By
relying on the commutativity and associativity of integer addition, we can
give the following implementation of #dyncode("charlst_length") that is
tail-recursive:

#atscode("\
fun charlst_length
  (cs: charlst): int = let
//
fun loop
  (cs: charlst, n: int): int = case cs of
  | charlst_cons (_, cs) => loop (cs, n+1) | charlst_nil () => n
// end of [loop]
//
in
  loop (cs, 0)
end // end of [charlst_length]
")

Note that the naming convention I follow closely in this book (and
elsewhere) mandates that only a tail-recursive function be given a name
indicative of its being a loop. A non-tail-recursive function is not called
a loop because it cannot be translated directly to a loop in an imperative
programming language like C.

")#comment("para")

</sect1><!--id="recursive_datatypes"-->

#comment(" ****** ****** ")

<sect1
id="exhaustiveness_of_pattern-matching">
<title>Exhaustiveness of Pattern-Matching</title>

#para("\

Given a type T and a set of patterns, if for any given value of the type T
there is always at least one pattern in the set such that the value matches
the pattern, then pattern-matching values of the type T against the set of
patterns is exhaustive.  Given a case-expression of the form
(#dyncode("case") exp0 #dyncode("of") clseq), where exp0 is assumed to be of
some type T, if pattern-matching values of the type T against the guards of
the matching clauses in clseq is exhaustive, then the case-expression is
said to be pattern-matching-exhaustive.\

")#comment("para")

#para("\
The following code implements a function that finds the last character
in a non-empty character list:

#atscode("\
fun charlst_last
  (cs: charlst): char =
(
  case cs of
  | charlst_cons (c, charlst_nil ()) => c
  | charlst_cons (_, cs1) => charlst_last (cs1)
)
// end of [charlst_last]
")

The body of #dyncode("charlst_last") is a case-expression, which is not
pattern-matching-exhaustive: If #dyncode("cs") is bound to the value
#dyncode("charlst_nil()"), that is, the empty character list, than none of
the matching clauses in the case-expression can be chosen. When the code is
typechecked by atsopt, a warning message is issued to indicate the
case-expression being non-pattern-matching-exhaustive. If the programmer
wants an error message instead, the keyword #dyncode("case") should be
replaced with #dyncode("case+").  If the programmer wants to suppress the
warning message, the keyword #dyncode("case") should be replaced with
#dyncode("case-"). I myself mostly use #dyncode("case+") when coding in
ATS.\

")#comment("para")

#para("\

The function #dyncode("charlst_last") can also be implemented as follows:

#atscode("\
fun charlst_last
  (cs: charlst): char =
(
  case cs of
  | charlst_cons (c, cs1) =>
    (
      case+ cs1 of
      | charlst_nil () => c | charlst_cons _ => charlst_last (cs1)
    ) // end of [charlst_cons]
) // end of [charlst_last]
")

In this implementation, the outer case-expression is not
pattern-matching-exhaustive while the inner one is. Note that the pattern
#dyncode("charlst_cons _") is just a shorthand for
#dyncode("charlst_cons(_, _)"). In general, a pattern of the form
#dyncode("C _"), where C is a constructor (associated with some datatype),
can be matched by any value that is constructed by applying C to some
values. For instance, the pattern #dyncode("charlst_nil()") can also be
written as #dyncode("charlst_nil _").\

")#comment("para")

#para("\

Suppose we have a case-expression containing only one matching clause, that
is, the case-expression is of the form [#dyncode("case") exp0
#dyncode("of") pat #dyncode("=>") exp].  Then we can also write this
case-expression as a let-expression: (#dyncode("let") #dyncode("val") pat
#dyncode("=") exp0 #dyncode("in") exp #dyncode("end")). For instance, we
give another implementation of the function #dyncode("charlst_last") as
follows:

#atscode("\
fun charlst_last
  (cs: charlst): char = let
  val charlst_cons (c, cs1) = cs in case+ cs1 of
  | charlst_nil () => c | charlst_cons _ => charlst_last (cs1)
end // end of [charlst_last]
")

When this implementation is typechecked by atsopt, a warning message is
issued to indicate the val-declaration being
non-pattern-matching-exhaustive. If the programmer wants an error message
instead, the keyword #dyncode("val") should be replaced with
#dyncode("val+").  If the programmer wants to suppress the warning message,
the keyword #dyncode("val") should be replaced with #dyncode("val-").\

")#comment("para")

#para("\

As values formed by the constructors #dyncode("charlst_nil") and
#dyncode("charlst_cons") are assigned the same type #stacode("charlst"), it
is impossible to rely on typechecking to prevent the function
#dyncode("charlst_last") from being applied to an empty character list.
This is a serious limitation.  With dependent types, which allow data to be
described much more precisely, we can ensure at the level of types that a
function finding the last element of a list can only be applied to a
non-empty list.\

")

</sect1><!--id="exhaustiveness_of_pattern-matching"-->

#comment(" ****** ****** ")

<sect1
id="example_binary_search_tree">
<title>Example: Binary Search Tree</title>

#para("\

A binary search tree is a binary tree satisfying the following property:
for each node in the tree, the key stored in the node is greater than or
equal to every key stored in the left child of the node and less than or
equal to every key stored in the right child of the node. In other words, a
binary tree is a binary search tree if a pre-order traversal encounters a
sequence of keys ordered ascendingly (according to some ordering on keys). In
practice, binary search trees are commonly employed to represent sets and
maps.

")

#para("\

The following declaration introduces a datatype #stacode("bstree") for
binary search trees in which the stored keys are strings:

")

#atscode("\
datatype bstree =
  | E of () | B of (bstree, string, bstree)
// end of [bstree]
")

#para("\

It should be noted that not every value of the type #stacode("bstree")
represents a valid binary search tree as it is certainly possible to
construct a value representing a binary tree but not a binary search tree.

")

#para("\

The following function [bstree_inord] does a in-order traversal of a
given binary tree:

")

#atscode("\
fun bstree_inord
(
  t0: bstree, fwork: string -<cloref1> void
) : void =
(
case+ t0 of
| E () => ()
| B (t1, k, t2) =>
  {
    val () = bstree_inord (t1, fwork)
    val () = fwork (k)
    val () = bstree_inord (t2, fwork)
  }
) (* end of [bstree_inord] *)
")

#para("\

If [t0] is a binary search tree, then the sequence of
keys processed by [fwork] are ordered ascendingly.

")

#para("\

Given a binary search tree and a key, the following function
[bstree_search] checks whether the key is stored inside the tree:

")

#atscode("\
fun bstree_search
  (t0: bstree, k0: string): bool =
(
case+ t0 of
| E () => false
| B (t1, k, t2) => let
    val sgn = compare (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => bstree_search (t1, k0)
    | _ when sgn > 0 => bstree_search (t2, k0)
    | _ (*k0 = k*) => true
  end // end of [B]
) (* end of [bstree_search] *)
")

#para("\

Note that [bstree_search] returns true if the given key is
found. Otherwise, it returns false.

")

#para("\

Given a binary search tree and a key, the following function
[bstree_insert] inserts the key into the tree:

")

#atscode("\
fun bstree_insert
  (t0: bstree, k0: string): bstree =
(
case+ t0 of
| E () => B (E, k0, E)
| B (t1, k, t2) => let
    val sgn = compare (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => B (bstree_insert (t1, k0), k, t2)
    | _ when sgn > 0 => B (t1, k, bstree_insert (t2, k0))
    | _ (*k0 = k*) => t0 // [k0] found and no actual insertion
  end // end of [B]
) (* end of [bstree_insert] *)
")

#para("\

Note that [bstree_insert] inserts the key only if it is not already stored
inside the given tree. Also, if inserted, the key is always stored in a newly
created leaf node.

")

#para("\

Please find
#mycodelink("CHAP_DATATYPE/bstree.dats", "on-line")
the entirety of the code in this section plus some additional code for
testing.\

")

</sect1><!--id="example_binary_search_tree"-->

#comment(" ****** ****** ")

<sect1
id="example_evaluating_integer_expressions">
<title>Example: Evaluating Integer Expressions</title>

#para("\

For representing integer expressions, we declare a datatype
#stacode("IEXP") as follows:

#atscode("\
datatype IEXP =
  | IEXPcst of int // constants
  | IEXPneg of (IEXP) // negative
  | IEXPadd of (IEXP, IEXP) // addition
  | IEXPsub of (IEXP, IEXP) // subtraction
  | IEXPmul of (IEXP, IEXP) // multiplication
  | IEXPdiv of (IEXP, IEXP) // division
// end of [IEXP]
")

The meaning of the constructors associated with #stacode("IEXP") should be
obvious. A value of the type #stacode("IEXP") is often referred to as an
abstract syntax tree. For instance, the abstract syntax tree for the
expression (~1+(2-3)*4) is the following one:

#atscode("\
IEXPadd(IEXPneg(IEXPcst(1)), IEXPmul(IEXPsub(IEXPcst(2), IEXPcst(3)), IEXPcst(4)))
")

Translating an integer expression written in some string form into an
abstract syntax tree is called parsing, which we will not do here. The
following defined function #dyncode("eval_iexp") takes the abstract syntax
tree of an integer expression and returns an integer that is the value of
the expression:

#atscode("\
fun
eval_iexp
  (e0: IEXP): int =
(
case+ e0 of
| IEXPcst (n) => n
| IEXPneg (e) => ~eval_iexp (e)
| IEXPadd (e1, e2) => eval_iexp (e1) + eval_iexp (e2)
| IEXPsub (e1, e2) => eval_iexp (e1) - eval_iexp (e2)
| IEXPmul (e1, e2) => eval_iexp (e1) * eval_iexp (e2)
| IEXPdiv (e1, e2) => eval_iexp (e1) / eval_iexp (e1)
) (* end of [eval_iexp] *)
")
")#comment("para")

#para("\

Suppose we also allow the construct if-then-else to be use in forming
integer expressions. For instance, we may write an integer expression like
(if 1+2 <= 3*4 then 5+6 else 7-8). Note that the test (1+2 <= 3*4) is a
boolean expression rather than an integer expression. This indicates that
we also need to declare a datatype #stacode("BEXP") for representing
boolean expressions. Furthermore, #stacode("IEXP") and #stacode("BEXP")
should be defined mutually recursively as follows:

#atscode("\
datatype IEXP =
  | IEXPcst of int // integer constants
  | IEXPneg of (IEXP) // negative
  | IEXPadd of (IEXP, IEXP) // addition
  | IEXPsub of (IEXP, IEXP) // subtraction
  | IEXPmul of (IEXP, IEXP) // multiplication
  | IEXPdiv of (IEXP, IEXP) // division
  | IEXPif of (BEXP(*test*), IEXP(*then*), IEXP(*else*))
// end of [IEXP]

and BEXP = // [and] for combining datatype declarations
  | BEXPcst of bool // boolean constants
  | BEXPneg of BEXP // negation
  | BEXPconj of (BEXP, BEXP) // conjunction
  | BEXPdisj of (BEXP, BEXP) // disjunction
  | BEXPeq of (IEXP, IEXP) // equal-to
  | BEXPneq of (IEXP, IEXP) // not-equal-to
  | BEXPlt of (IEXP, IEXP) // less-than
  | BEXPlte of (IEXP, IEXP) // less-than-equal-to
  | BEXPgt of (IEXP, IEXP) // greater-than
  | BEXPgte of (IEXP, IEXP) // greater-than-equal-to
// end of [BEXP]
")

Evidently, we also need to evaluate boolean expressions when evaluating
integer expressions. The following two functions #dyncode("eval_iexp") and
#dyncode("eval_bexp") for evaluating integer and boolean expressions,
respectively, are defined mutually recursively as can be expected:

#atscode("\
fun
eval_iexp
  (e0: IEXP): int =
(
case+ e0 of
| IEXPcst n => n
| IEXPneg (e) => ~eval_iexp (e)
| IEXPadd (e1, e2) => eval_iexp (e1) + eval_iexp (e2)
| IEXPsub (e1, e2) => eval_iexp (e1) - eval_iexp (e2)
| IEXPmul (e1, e2) => eval_iexp (e1) * eval_iexp (e2)
| IEXPdiv (e1, e2) => eval_iexp (e1) / eval_iexp (e1)
| IEXPif
  (
    e_test, e_then, e_else
  ) =>
  (
    eval_iexp (if eval_bexp (e_test) then e_then else e_else)
  ) // end of [IEXPif]
) (* end of [eval_iexp] *)

and
eval_bexp
  (e0: BEXP): bool =
(
case+ e0 of
| BEXPcst b => b
| BEXPneg (e) => ~eval_bexp (e)
| BEXPconj (e1, e2) =>
    if eval_bexp (e1) then eval_bexp (e2) else false
| BEXPdisj (e1, e2) =>
    if eval_bexp (e1) then true else eval_bexp (e2)
| BEXPeq (e1, e2) => eval_iexp (e1) = eval_iexp (e2)
| BEXPneq (e1, e2) => eval_iexp (e1) != eval_iexp (e2)
| BEXPlt (e1, e2) => eval_iexp (e1) < eval_iexp (e2)
| BEXPlte (e1, e2) => eval_iexp (e1) <= eval_iexp (e2)
| BEXPgt (e1, e2) => eval_iexp (e1) > eval_iexp (e2)
| BEXPgte (e1, e2) => eval_iexp (e1) >= eval_iexp (e2)
) (* end of [eval_bexp] *)
")
")#comment("para")

#para("\

The integer and boolean expressions used in this example are all constant
expressions containing no variables. Therefore, there is no need for an
environment to evaluate them. I will present a more advanced example
elsewhere to demonstrate how an evaluator for a simple call-by-value
functional programming language like the core of ATS can be implemented.\

")

#para("\

Please find
#mycodelink("CHAP_DATATYPE/intexp.dats", "on-line")
the entirety of the code in this section plus some additional code for
testing.\

")

</sect1><!--id="example_evaluating_integer_expressions"-->

#comment(" ****** ****** ")

</chapter><!--id="datatypes"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
