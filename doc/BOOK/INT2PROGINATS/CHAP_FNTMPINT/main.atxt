%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../MYTEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="from-genericity-to-late-binding">
#title("From Genericity to Late-Binding")

<!-- ****** ****** -->

#para('\

The support for function templates in ATS is deeply ingrained in the design
and implementation of ATS. Primarily, function templates are meant to
provide a general approach to code reuse in ATS that is highly flexible (in
terms of applicability) while incurring minimal run-time overhead if
any. Both ATSPRE (that is, ATSLIB/prelude) and ATSLIB/libats are nearly
entirely template-based, and the templates in these libraries are for use
by #command("atsopt") to generate C code that implements template
instances in the ATS source being compiled. The library files of ATS for
linking (#filename("libatslib.a") and #filename("libatslib.so")) are minimal, and
they are not even necessary for compiling ATS source into executable binaries.

')#comment("para")

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_FNTMPINT/", "on-line").\

")

<!-- ****** ****** -->

<sect1
 id="genericity-of-template-implementations">
#title("Genericity of Template Implementations")

#para('\

As is briefly explained in Part I of the book, function templates can be
seen as a natural solution to the problem of supporting parametric
polymorphism in the presence of native unboxed data. However, function
templates can do much more than just supporting parametric polymorphism.
Let #dyncode("myprint") be a function template of the following interface:

#sats2xhtml('\
fun{a:t@ype} myprint (x: a): void
')

Given a value, #dyncode("myprint") is supposed to print out some kind of
representation for this value. For example, we can implement
#dyncode("myprint") as follows:

#dats2xhtml('\
implement{a} myprint (x) = print_string "?"
')

This implementation of #dyncode("myprint") is often referred to as a
(fully) generic template implementation due to no restriction being imposed
on the template parameter. Following is another way to code the same
implementation:

#dats2xhtml('\
implement(a) myprint<a> (x) = print_string "?"
')

Clearly, the above generic implementation of #dyncode("myprint") is
unsatisfactory as it outputs no specific information on a given value.  We
may want to implement #dyncode("myprint") as follows for only values of the
type #stacode("int"):

#dats2xhtml('\
implement myprint<int> (x) = print_int (x)
')

where #dyncode("print_int") is called to print out a given integer. This
implementation of #dyncode("myprint") is often referred to as a specific
template implementation due to the template parameter being bound to a
specific type (that is, #stacode("int") in this case). The following code
implements #dyncode("myprint") for list-values (that is, values of type
#stacode("List(T)") for some type T):

#dats2xhtml('\
implement(a)
myprint<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); myprint<List(a)> (xs))
')

This implementation of #dyncode("myprint") is often referred to as a
partially generic template implementation. In order for an instance of
#dyncode("myprint") to use this implementation, the template parameter for
the instance must be of the form #stacode("List(T)") for some type T.
As an example, the following code calls an instance of #dyncode("myprint")
to print out a list of two integer lists:

#dats2xhtml('\
(*
** The output is "0123401234"
*)
val ys = $list{int}(0,1,2,3,4)
val yss = $list{List(int)}(ys, ys)
val ((*void*)) = myprint<List(List(int))> (yss)
val ((*void*)) = print_newline((*void*))
')

')#comment("para")

#para('\

Implementations of a function template can be ordered according to an
obvious partial ordering referred to as genericity ordering: The genericity
of one implementation is less than or equal to that of another one if the
former implementation is an instance of the latter one. Please note that
the first-fit (instead of best-fit) strategy is employed to locate the
template implementation needed for compiling a given template instance.
More specifically, locating the template implementation for a particular
template instance follows the standard principle of lexical scoping to
search for the first one that is available for use.

')#comment("para")

#para('\

In practice, there is quite a bit of subtlety in locating a template
implementation for a template instance. Let #dyncode("myprint2") be a
function template of the following interface:

#sats2xhtml('\
fun{a:t@ype} myprint2 (x: a): int
')

Following is a partially generic implementation of #dyncode("myprint2"):

#dats2xhtml('\
//
implement(a)
myprint2<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); 1 + myprint2 (xs))
//
')

This template implementation actually behaves very differently from what
one might have expected. Note that the template parameter of the called
instance of #dyncode("myprint2") in the body of the implementation is
synthesized to be a type of the form #stacode("list(a, N)") for some static
term N (of the sort #stacode("int")). As this form can never match
#stacode("List(T)") for any type T, the called instance of the template
#dyncode("myprint2") cannot be compiled according to the given template
implementation of #dyncode("myprint2"). This issue can be readily fixed by
passing explicity the type #stacode("List(a)") (as a template parameter) to
the called instance of #dyncode("myprint2"):

#dats2xhtml('\
//
implement(a)
myprint2<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); 1 + myprint2<List(a)> (xs))
//
')

The instance #dyncode("myprint2&lt;List(a)&gt;") in this example is often
referred to as a recursive instance. In general, it is a good programming
practice to #emphasis("avoid") using recursive instances. For example, the
following equivalent implementation of #dyncode("myprint2") makes no use of
recursive instances:

#dats2xhtml('\
//
implement(a)
myprint2<List(a)>
  (xs) = let
//
fun
aux
(xs: List(a)): int =
//
case+ xs of
| list_nil () => 0
| list_cons (x, xs) => (myprint<a>(x); 1 + aux(xs))
//
in
  aux (xs)
end // end of [myprint2<List(a)>]
//
')

')#comment("para")


#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/myprint.dats", "myprint.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")

</sect1><!--id="genericity-of-template-implementations"-->

<!-- ****** ****** -->

<sect1
 id="generic-operations-on-numbers">
#title("Example: Generic Operations on Numbers")

#para("\

There are many types of numbers in ATS. With function templates, we can
greatly enhance code sharing in numerical computation. For example, we can
give a generic implementation of matrix multiplication of the following
interface:

#sats2xhtml("\
fun
{a:t@ype}
matrix_mul
  {p,q,r:int}
(
  p: int(p)
, q: int(q)
, r: int(r)
, A: &matrix(a, p, q)
, B: &matrix(a, q, r)
, C: &matrix(a?, p, r) >> matrix(a, p, r)
) : void // end of [matrix_mul]
")

and then use it to immediately obtain implementations of matrix
multiplication for matrices of integers, matrices of floating point
numbers, matrices of floating point complex numbers, etc. This approach is
clearly far superior to relying on error-prone macros in C.

")#comment("para")

#para("\

Let us take a look at a concrete example involving generic operations on
numbers. The following code gives a standard implementation of the
factorial function:

#dats2xhtml('\
//
extern
fun fact(n: int): int
//
implement
fact(n) =
  if n > 0 then n * fact(n-1) else 1
// end of [fact]
//
')

When applied to 100, #dyncode("fact") is likely to return 0. This can be
easily understood as the true value of the factorial of 100 is a multiple
of 2#sup("32") and the multiplication operation on integers of the type
#stacode("int") is probably modulo 2#sup("32"). Suppose that we want to
replace this multiplication operation with the one on floating point
numbers of double precision. This can be done by implementing a slight variant
of #dyncode("fact") as follows

#dats2xhtml('\
//
extern
fun factd(n: int): double
//
implement
factd(n) =
  if n > 0 then n * factd(n-1) else 1.0
// end of [factd]
//
')

When applied to 100, #dyncode("factd") should return a large floating point
number. Obviously, there is a great deal of code duplication between the
implementations of #dyncode("fact") and #dyncode("factd"). We can readily
eliminate this duplication by introducing a generic implementation of the
factorial function as follows:

#dats2xhtml('\
//
extern
fun{a:t@ype} gfact(n: int): a
//
implement
{a}(*tmp*)
gfact(n) = (
//
if n > 0
then gmul_int_val<a>(n, gfact<a>(n-1))
else gnumber_int<a>(1)
//
) (* end of [gfact] *)
//
')

With a bit of help from the support for
overloading in ATS, we can rewrite #dyncode("gfact") as follows:

#dats2xhtml('\
implement
{a}(*tmp*)
gfact(n) = let
//
overload * with gmul_int_val
//
in
//
if n > 0
then n * gfact<a>(n-1) else gnumber_int<a>(1)
//
end (* end of [gfact] *)
')

We can now implement #dyncode("fact") and #dyncode("factd")
as follows:

#dats2xhtml('\
//
implement fact(n) = gfact<int>(n)
implement factd(n) = gfact<double>(n)
//
')

There is support in ATS based on the GNU multiple precision arithmetic
library (GMPLIB) for integers of unlimited precision. The following code
presents a way to compute the true value of the factorial of 100:

#dats2xhtml('\
//
\#define
HX_INTINF_targetloc
"$PATSHOME\
/contrib/atscntrb-hx-intinf"
//
(* ****** ****** *)
//
staload _(*T*) =
"{$HX_INTINF}/DATS/intinf_t.dats"
staload _(*VT*) =
"{$HX_INTINF}/DATS/intinf_vt.dats"
//
staload
GINTINF =
"{$HX_INTINF}/DATS/gintinf_t.dats"
//
(* ****** ****** *)
//
typedef intinf = $GINTINF.intinf
overload print with $GINTINF.print_intinf
//
val () =
println! ("gfact<intinf>(100) = ", gfact<intinf>(100))
//
')

I only list some leading digits of the result:

#atscode('\
gfact<intinf>(100) = 933262154439441526816992388562667[...omitted...]
')
")

#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/gnumber.dats", "gnumber.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")

</sect1><!--id="generic-operations-on-numbers"-->

<!-- ****** ****** -->

<sect1
 id="templates-as-a-special-form-of-functors">
#title("Templates as a Special Form of Functors")

#para("\

Many uses of higher-order functions can be readily replaced with function
templates in ATS.  In particular, higher-order functions are often
implemented in ATS based on the corresponding function templates.
Let us start with a concrete example. Following is a standard
implementation of list mapping as a higher-order function (template):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_fun{n:nat}
  (xs: list(a, n), fopr: a -> b): list_vt(b, n)
//
implement
{a}{b}
list_map_fun (xs, fopr) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil() => list_vt_nil()
| list_cons(x, xs) => list_vt_cons(fopr(x), aux(xs))
)
//
in
  aux(xs)
end // end of [list_map_fun]
//
')

Given a list of cerntain length and a function (which is envless),
#dyncode("list_map_fun") returns a linear list of the same
length. Unfortunately, #dyncode("list_map_fun") cannot be called on a list and
a closure-function. We certainly can implement a variant of
#dyncode("list_map_fun") of the following interface by essentially duplicating
the implementation of #dyncode("list_map_fun"):

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_cloref{n:nat}
  (xs: list(a, n), fopr: a -<cloref1> b): list_vt(b, n)
//
')

While #dyncode("list_map_cloref") can be called on a list and a
closure-function, the closure-function that is formed at run-time to be
passed to a call to #dyncode("list_map_cloref") most likely becomes garbage
immediately after the call returns. Without garbage collection (GC), the
memory for storing the closure is leaked. We surely have many good reasons
for avoiding using a higher-order function like #dyncode("list_map_cloref")
when doing embedded programming in ATS.

")

#para('\

A proper way to implement list mapping (as I see it) is given as follows:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map{n:nat}
  (xs: list(a, n)): list_vt(b, n)
//
extern
fun
{a:t@ype}{b:t@ype} list_map$fopr(x: a): b
//
implement
{a}{b}
list_map (xs) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil() => list_vt_nil()
| list_cons(x, xs) => list_vt_cons(list_map$fopr<a><b>(x), aux(xs))
) (* end of [aux] *)
//
in
  aux(xs)
end // end of [list_map]
//
')

The function template #dyncode("list_map") is given in a style that is
often referred to as being functorial: #dyncode("list_map") can be thought
of as a functor in Standard ML that applies to a module consisting of a
single function #dyncode("list_map$fopr"). In SML, each argument of a
functor, which itself is a module, needs to be constructed and then passed
to the functor explcitly. In ATS, the template implementation needed for
compiling a particular template instance is located through a search
procedure (that follows the standard principle of lexical scoping).

')#comment("para")

#para('\

With #dyncode("list_map"), we can implement #dyncode("list_map_fun")
as follows in a straightforward manner:

#dats2xhtml('\
implement
{a}{b}
list_map_fun(xs, fopr) = let
//
implement list_map$fopr<a><b> (x) = fopr(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_fun]
')

Please note that #dyncode("list_map$fopr") being implemented inside
the body of #dyncode("list_map_fun") allows the implementation to gain
direct access to the argument #dyncode("fopr") of
#dyncode("list_map_fun"). It is in this sense that templates in ATS
are often referred to as #emphasis("embeddable") templates as they can
be directly implemented in the bodies of functions.

We can implement #dyncode("list_map_cloref") similarly as follows:

#dats2xhtml('\
implement
{a}{b}
list_map_cloref(xs, fopr) = let
//
implement list_map$fopr<a><b> (x) = fopr(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_cloref]
')

For those who are familiar with functors in SML, the implementation of
#dyncode("list_map_fun") and #dyncode("list_map_cloref") should clearly
remind them of functor application.\

')#comment("para")

#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/list_map.dats", "list_map.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")

</sect1><!--id="templates-as-a-special-form-of-functors"-->

<!-- ****** ****** -->

<sect1
 id="template-for-loop-construction">
#title("Example: Templates for Loop Construction")

#para('\

Beginners in functional programming (FP) who have already acquired some
knowledge of imperative programming often ask about ways to construct
for-loops and while-loops in FP. A commonly given answer is that loop
constructs are unnecessary in FP as they can be readily replaced with
higher-order functions. Let us first see some thorny issues with this
answer.\

')#comment("para")

#para('\

The following code in C implements a function that returns the sum
of the first n natural numbers when applied to a natural number n:

#atscode('\
int
tally (int n) {
  int i, res;
  for (i = 0, res = 0; i < n; i += 1) res += i;
  return res;
}
')

This function #dyncode("tally") can be given the following
equivalent implementation in ATS:

#dats2xhtml('\
fun
tally
(
  n: int
) : int = loop (0, 0) where
{
  fun loop (i: int, res: int): int =
    if i < n then loop (i + 1, res + i) else res
}
')

where the tail-recursive function #dyncode("loop") is just a translation
of the for-loop in C.

')#comment("para")

#para('\

When someone claims that loop constructs can be replaced with higher-order
functions, he or she probably means to construct loops with a function like
the following one:

#dats2xhtml('\
fun
for_loop
(
  count: int, limit: int, fwork: (int) -<cloref1> void
) : void = (
//
if count < limit
  then (fwork(count); for_loop(count+1, limit, fwork)) else ()
// end of [if]
) (* end of [for_loop] *)
')

For example, the following function #dyncode("tally2") is directly based
on #dyncode("for_loop"):

#dats2xhtml('\
fun
tally2
(
  n: int
) : int = let
  val res = ref<int> (0)
in
  for_loop (0, n, lam (i) => !res := !res + i); !res
end // end of [tally2]
')

While both #dyncode("tally") and #dyncode("tally2") return the same result
when applied to a given natural number, they behave very differently at
run-time. In particular, each call to #dyncode("tally2") creates a
(persistent) reference on heap for temporary use; the reference becomes
garbage immediately after the call returns. Compared to #dyncode("tally"),
#dyncode("tally2") is inefficient both time-wise and memory-wise.\

')#comment("para")

#para('\

To eliminate the need for reference creation in #dyncode("tally2"), we
turn #dyncode("for_loop") into the following function template
#dyncode("for_loop2"):

#dats2xhtml('\
//
fun{
env:t@ype
} for_loop2
(
  count: int, limit: int
, env: &env >> _, fwork: (int, &env >> _) -<cloref1> void
) : void = (
//
if
count < limit
then (
  fwork(count, env); for_loop2<env> (count+1, limit, env, fwork)
) else ()
// end of [if]
//
) (* end of [for_loop2] *)
')

We can further turn #dyncode("tally2") into the following #dyncode("tally3")
based on #dyncode("for_loop2"):

#dats2xhtml('\
fun
tally3
(
  n: int
) : int = let
  var res: int = 0
in
  for_loop2<int> (0, n, res, lam (i, res) => res := res + i); res
end // end of [tally3]
')

While #dyncode("tally3") improves upon #dyncode("tally2"), it is still
a bit unsatisfactory. Clearly, the closure function formed before
#dyncode("tally3") calls #dyncode("for_loop2") becomes garbage
immediately after the call returns. It is plausible to expect that an
optimizing C compiler (e.g., gcc and clang) can eliminate the need for
actual closure formation when it compiles the C code generated from
ATS source, but there is no guarantee. In order to have such a
guarantee, we can evolve #dyncode("for_loop2") into the following
function template #dyncode("for_loop3:")

#dats2xhtml('\
fun{
env:t@ype
} for_loop3
(
  count: int, limit: int, env: &env >> _
) : void = (
//
if
count < limit
then (
  for_loop3$fwork<env>(count, env); for_loop3<env>(count+1, limit, env)
) else ()
// end of [if]
//
) (* end of [for_loop3] *)
')

where #dyncode("for_loop3$fwork") is given the interface below:

#sats2xhtml('\
fun{
env:t@ype
} for_loop3$fwork(count: int, env: &env >> _): void
')

Finally, we can turn #dyncode("tally3") into #dyncode("tally4")
as follows:

#dats2xhtml('\
fun
tally4
(
  n: int
) : int = let
//
var res: int = 0
//
implement
for_loop3$fwork<int> (i, res) = res := res + i
//
in
  for_loop3<int> (0, n, res); res
end // end of [tally4]
')

By inspecting the C code generated by #command("atsopt") from compiling
#dyncode("tally4"), we can see that the C code is essentially equivalent to
the implementation of #dyncode("tally") in C (given at the beginning of
this section).

')#comment("para")

#para('\

By now, the reader probably agrees with me if I say the statement should at
least be considered grossly inaccurate that claims loop constructs in FP
can be readily replaced with higher-order functions.  Please find on-line
the file #mycodelink("CHAP_FNTMPINT/loopcons.dats", "loopcons.dats")
containing the entirety of the code presented in this section plus some
testing code.\

')#comment("para")

</sect1><!--id="template-for-loop-construction"-->

<!-- ****** ****** -->

<sect1
 id="template-based-support-for-late-binding">
#title("Template-Based Support for Late-Binding")

#para('\

When asked about the meaning of object-oriented programming (OOP),
Alan Kay once said that OOP to him meant only messaging, local retention
and protection and hiding of state-process, and extreme late-binding of all
things.\

')#comment("para")

#para('\

In ATS, function templates can provide a highly flexible approach to
supporting late-binding (of function calls). Let us first take a look at a
simple example to see why late-binding can be so desirable. The following
code declares a datatype #stacode("intfloat") such that each value of this
declared type represents either an integer or a floating point number (of
double precision):

#sats2xhtml('\
//
datatype
intfloat = INT of int | FLOAT of double
//
')

In order to print values of the type #stacode("intfloat"), we can implement
#dyncode("print_intfloat") as follows:

#dats2xhtml('\
//
fun
print_intfloat
  (x: intfloat): void =
(
case+ x of
| INT(int) => print_int(int)
| FLOAT(float) => print_double(float)
)
//
')

where #dyncode("print_int") and #dyncode("print_double") are monomorphic
functions for printing an integer and a floating point number (of double
precision), respectively. There are certainly many different ways to print
integers and floating point numbers, but #dyncode("print_intfloat") only
uses a particular one for integers (via #dyncode("print_int")) and a
particular one for floating point numbers (via #dyncode("print_double")).
One possibility of avoiding this form of extreme inflexibility is to define
a higher-order function #dyncode("fprint_intfloat") as follows:

#dats2xhtml('\
//
fun
fprint_intfloat
(
  x: intfloat
, print_int: int -> void
, print_double: double -> void
) : void =
(
case+ x of
| INT(int) => print_int(int)
| FLOAT(float) => print_double(float)
)
//
')

With #dyncode("fprint_intfloat"), one can decide to choose implementations
for #dyncode("print_int") and #dyncode("print_double") at a later stage. In
this regard, I say that higher-order functions can support a form of
late-binding. However, using higher-order functions in such a manner is not
without serious problems. Basically, any function that calls
#dyncode("print_int") either directly or indirectly needs to be turned into
a higher-order function, and the same applies to functions calling
#dyncode("print_double") as well. This style of programming with extensive
use of higher-order functions can soon become extremely unwieldy when the
number of functions grows large that need to be treated like
#dyncode("print_int") and #dyncode("print_double").

')#comment("para")

#para('\

Instead of using higher-order functions, we can rely on template functions
to support late-binding (of function calls). For example, the following
code implements a template function #dyncode("tprint_intfloat") for
printing values of the type #stacode("intfloat"):

#dats2xhtml('\
//
extern
fun{}
tprint_int(int): void
extern
fun{}
tprint_double(double): void
extern
fun{}
tprint_intfloat(intfloat): void
//
(* ****** ****** *)
//
implement
tprint_int<> (x) = print_int(x)
implement
tprint_double<> (x) = print_double(x)
//
(* ****** ****** *)
//
implement
tprint_intfloat<> (x) =
(
case+ x of
| INT(int) => tprint_int<> (int)
| FLOAT(float) => tprint_double<> (float)
)
//
')

Please note that the default implementations for #dyncode("tprint_int") and
#dyncode("tprint_double") are based on #dyncode("print_int") and #dyncode("print_double"),
respectively. As can be expected, the following code outputs two lines:

#dats2xhtml('\
//
val () = (
  tprint_intfloat<> (INT(0)); print_newline()
) (* end of [val] *)
//
val () = (
  tprint_intfloat<> (FLOAT(1.0)); print_newline()
) (* end of [val] *)
//
')

where the first line consists of the string "0" and the second one
the string "1.000000". The following code also outputs two lines:

#dats2xhtml('\
local
//
implement
tprint_int<> (x) = print! ("INT(", x, ")")
implement
tprint_double<> (x) = print! ("FLOAT(", x, ")")
//
in (* in-of-local *)
//
val () = (
  tprint_intfloat<> (INT(0)); print_newline()
) (* end of [val] *)
//
val () = (
  tprint_intfloat<> (FLOAT(1.0)); print_newline()
) (* end of [val] *)
//
end // end of [local]
')

where the first line consists of the string "INT(0)" and the second one the
string "FLOAT(1.000000)"). In the latter case, the calls to template instances
#dyncode("tprint_int&lt;&gt;") and #dyncode("tprint_double&lt;&gt;") are compiled
according to the implementations for #dyncode("tprint_int") and #dyncode("tprint_double")
given between the keywords #keycode("local") and #keycode("in").\

')#comment("para")

#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/intfloat.dats", "intfloat.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")

</sect1><!--id="template-based-support-for-late-binding"-->

<!-- ****** ****** -->

</chapter>
<!--id="from-genericity-to-late-binding"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
