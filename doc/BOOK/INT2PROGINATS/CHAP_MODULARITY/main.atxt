%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="modularity">
#title("Modularity")

#para("\

Generally speaking, modularity in programming means to organize programs in
a modular fashion so that they each can be constructed in a relatively
isolated manner and then be combined to function coherently.  I will
introduce in this section some features in ATS that are largely designed to
facilitate program organization.\

")

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_MODULARITY/", "on-line").\

")

<!-- ****** ****** -->

<sect1
id="types_as_a_form_of_specification">
<title>
Types as a Form of Specification
</title>

#para("\

The interface for a function or value specifies a type that any
implementation of the function or value should possess. For instance, the
following code defines a function #dyncode("fact") for computing the
factorial of a given integer:

#atscode('\
fun fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

It is also possible to first declare an interface for #dyncode("fact") as
follows:

#atscode('\
extern fun fact (x: int): int
')

where #keycode("extern") is a keyword in ATS that initiates the declaration
of an interface. Alternative ways to declare an interface for #dyncode("fact")
are given as follows:

#atscode('\
extern fun fact : (int) -> int
extern val fact : (int) -> int
')

If #dyncode("fact") is declared to be a function, then it is required to be
applied when occurring in code. If it is declared to be a value, there is
no such a restriction.\

")#comment("para")

#para("\

A function interface can be considered as a form of specification. For
instance, the above interface for #dyncode("fact") specifies that
#dyncode("fact") is a function that takes one argument required to be an
integer and returns a value guaranteed to be an integer. What is so special
about this form of specification is that it is formally enforced in ATS
through typechecking: Any well-typed implementation of #dyncode("fact") in
ATS must possess the interface declared for it.  Of course, this interface
for #dyncode("fact") is not a precise specification as there are
(infinitely) many functions that can be given the same interface. This kind
of imprecision can, however, be reduced or even eliminated,
sometimes. After dependent types are introduced, I will present an
interface for #dyncode("fact") such that any implementation of the
interface is guaranteed to implement precisely the factorial function as is
defined by the following two equations:

<itemizedlist>

<listitem>
#para("
fact(0) = 1
")
</listitem>

<listitem>
#para("
fact(n) = n * fact (n-1) for each natural number n > 0
")
</listitem>

</itemizedlist>

")#comment("para")

#para("\

An implementation for #dyncode("fact") as the following one can be given at
any point where the declared interface for #dyncode("fact") is accessible:

#atscode('\
implement fact (x) = if x > 0 then x * fact (x-1) else 1
')

The keyword #keycode("implement") is for initiating an implementation of a
function or value whose interface is already declared. It is fairly common
to see the following style of coding, usually, by a beginning ATS programmer:

#atscode('\
implement fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

While this implementation can pass typechecking, it is nonetheless of a
poor style: The types provided by the programmer for the argument and the
result of #dyncode("fact") are redundant as they can be automatically
synthesized by the typechecker.\

")#comment("para")

#para("\

As an example of an interface for a value, #dyncode("fact10") is declared
as follows to be a value of the type #stacode("int"):

#atscode('\
extern val fact10 : int
')

The following implementation for #dyncode("fact10") can be given at any
point where the declared interface for #dyncode("fact10") is accessible:

#atscode('\
implement fact10 = fact (10)
')

")#comment("para")

#para("\

As another example, the following code declares an interface for a
polymorphic function named #dyncode("swap_boxed"):

#atscode('\
extern
fun swap_boxed{a,b:type} (xy: (a, b)): (b, a)
')

Note that both type variables #stacode("a") and #stacode("b") are boxed.
An implementation for #dyncode("swap_boxed") is given as follows:

#atscode('\
implement swap_boxed{a,b} (xy) = (xy.1, xy.0)
')

The syntax #stacode("{a,b}") is for passing static arguments #stacode("a")
and #stacode("b") to #dyncode("swap_boxed") simultaneously. As neither
#stacode("a") nor #stacode("b") is actually used in the body of
#dyncode("swap_boxed"), it is allowed to drop #stacode("{a,b}") in this
case.\

")#comment("para")

#para("\

As yet another example, the following code declares an interface for a
function template named #dyncode("swap_tmplt"):

#atscode('\
extern
fun{a,b:t@ype} swap_tmplt (xy: (a, b)): (b, a)
')

Note that both type variables #stacode("a") and #stacode("b") are of the
sort #stacode("t@ype"), indicating that they can be of any size.

An implementation for #dyncode("swap_tmplt") is given as follows:

#atscode('\
implement{a,b} swap_tmplt (xy) = (xy.1, xy.0)
')

")#comment("para")

#para("\

It is a standard practice for a programmer to first design interfaces for
the functions to be supported in a package before actually implementing any
of these functions. When such interfaces are available, application
programs can be constructed to test whether the interface design makes
sense or is convenient for practical use. Please remember that a superb
implementation of a poor design cannot make the design any
better. Therefore, testing a design before actually implementing it is
often of vital importance. This is especially true if the involved design
is complex.\

")

</sect1><!--id="types_as_a_form_of_specification"-->

<sect1
id="static_and_dynamic_ats_files">
<title>
Static and Dynamic ATS Files
</title>

#para("\

The first letters in the ATS filename extensions #emphasis("sats") and
#emphasis("dats") refer to the words #emphasis("static") and
#emphasis("dynamic"), respectively.  For instance, #filename("foo.sats") is
a name for a static file while #filename("bar.dats") is for a dynamic
one. A static file is often referred to as a SATS-file, and it usually
contains interface declarations for functions and values, datatype
declarations, type definitions, etc. The primary purpose of a SATS-file is
for allowing its content to be shared among various other ATS files, either
static or dynamic.\

")

#para("\

Let us now go through a simple example to see a typical use of static
files. Suppose that we want to implement the Ackermann's function, which is
famous for being recursive but not primitive recursive.  In a static file
named #filename("acker.sats") (or any other legal filename), we can declare
the following function interface:

#atscode('\
fun acker (m: int, n: int): int
')

Please note that one should not use the keyword #keycode("extern") when
declaring an interface for either a function or a value in a static file.
Then in a dynamic file named #filename("acker.dats") (or any other legal
filename), we can give the following implementation:

#atscode('\
staload "acker.sats"

implement
acker (m, n) =
  if m > 0 then
    if n > 0 then acker (m-1, acker (m, n-1))
    else acker (m-1, 1)
  else n+1
// end of [acker]
')

The keyword #stacode("staload") indicates to the ATS typechecker that the
file following it is to be statically loaded during
typechecking. Essentially, statically loading a file means to put the
content of the file in a namespace that can be accessed by the following
code.  It is important to note that static loading is different from plain
file inclusion. The latter is also supported in ATS, and it is a feature I
will cover elsewhere.\

")#comment("para")

#para("\

It is also possible to give the following implementation for the declared
function #dyncode("acker"):

#atscode('\
staload ACKER = "acker.sats"

implement $ACKER.acker
  (m, n) = acker (m, n) where {
  fun acker (m: int, n:int): int = 
    if m > 0 then
      if n > 0 then acker (m-1, acker (m, n-1))
      else acker (m-1, 1)
    else n+1
} // end of [$ACKER.acker]
')

In this case, the namespace for storing the content of the file
#filename("acker.sats") is given the name ACKER, and the prefix
#dyncode("$ACKER.") (the dollar sign followed by ACKER followed by the dot
symbol) must be attached to any name that refers an entity (a function, a
value, a datatype, the constructors associated with a datatype, a type
definition, etc.) declared in #filename("acker.sats"). When there are many
static files to be loaded, it is often a good practice to assign names to
the namespaces holding these files so that the original source of each
declared entity can be readily tracked down.\

")#comment("para")

#para("\

In another file named #filename("test_acker.dats"), let us
write the following code:

#atscode('\
//
\#include
"share/atspre_staload.hats"
//
staload "acker.sats"
dynload "acker.dats"

implement
main0 () = () where {
//
// acker (3, 3) should return 61
//
  val () = assertloc (acker (3, 3) = 61)
} // end of [main0]
')

The keyword #dyncode("dynload") indicates to the ATS compiler to generate a
call to the initializing function associated with the file
#filename("acker.dats"). This is mandatory as an error would otherwise be
reported at link-time. Usually, calling the initializing function
associated with a dynamic file is necessary only if there is a value
implemented in the file. In this case, there is only a function implemented
in #filename("acker.dats"). If we include the following line somewhere
inside #filename("acker.dats"):

#atscode('\
\#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
')

then the line starting with the keyword #dyncode("dynload") in
#filename("test_acker.dats") is no longer needed. The function
#dyncode("assertloc") verifies at run-time that its argument evaluates to
the boolean value #dyncode("true"). In the case where the argument
evaluates to #dyncode("false"), the function call aborts and a message is
reported that contains the name of the file, which is
#filename("test_acker.dats") in this example, and the location at
which the source code of the call is found in the file. If this sounds a
bit confusing, please try to execute a program that contains a call to
#dyncode("assertloc") on #dyncode("false") and you will see clearly what
happens.\

")#comment("para")

#para("\

The simplest way to compile the two files #filename("acker.dats") and
#filename("test_acker.dats") is to issue the following command-line:

<informalexample><programlisting>
<command>atscc</command> -o test_acker acker.dats test_acker.dats
</programlisting></informalexample>

The generated excutable #filename("test_acker") is in the current
working directory.  The compilation can also be performed separately as is
demonstrated below:

<informalexample><programlisting>
<command>atscc</command> -c acker.dats
<command>atscc</command> -c test_acker.dats
<command>atscc</command> -o test_acker acker_dats.o test_acker_dats.o
</programlisting></informalexample>

This style of separate compilation works particularly well when it is
employed by the <command>make</command> utility.\

")#comment("para")

</sect1><!--id="static_and_dynamic_ats_files"-->

<!-- ****** ****** -->

<sect1 id="generic_template_implementation">
<title>
Generic Template Implementation
</title>

#para("\

Interfaces for function templates are mostly similar to those for
functions.  For example, the following syntax declares an interface in a
dynamic file for a function template of the name #dyncode("list0_fold_left"):

#atscode('\
extern
fun{
a:t0p}{b:t0p
} list0_fold_left
  (xs: list0 b, f: (a, b) -<cloref1> a, init: a): a
')

where #stacode("t0p") is a shorthand for #stacode("t@ype").\
")

#para("\

If the same interface is declared in a static file, the keyword
#keycode("extern") should be dropped. Implementing an interface for a
function template is also mostly similar to implementing one for a
function. The above interface for #dyncode("list0_fold_left") is given an
implementation in the following code:

#atscode('\
implement{a}{b}
list0_fold_left
  (xs, f, init) = let
//
fun loop
(
  xs: list0 b, res: a
) : a =
(
  case+ xs of
  | list0_nil () => res
  | list0_cons (x, xs) => loop (xs, f (res, x))
) (* end of [loop] *)
//
in
  loop (xs, init)
end // end of [list0_fold_left]
')

Note that template parameters are required to appear immediately after the
keyword #dyncode("implement"), and they cannot be omitted.  Template
parameters can also be passed sequentially as is shown in the following
short example:

#atscode("\
extern
fun
{a,b:t0p}{c:t0p}
app2 (f: (a, b) -<cloref1> c, x: a, y: b): c

implement{a,b}{c} app2 (f, x, y) = f (x, y)
")

")#comment("para")

#para("\

The style of template implementation presented in this section is
referred to as generic template implementation. I will later present a
different style of template implementation, which is often referred to as
specific template implementation.\

")

</sect1><!--id="generic_template_implementation"-->

<!-- ****** ****** -->

<sect1 id="specific_template_implementation">
<title>
Specific Template Implementation
</title>

#para("\

Implementing an interface for a function template specifically means to
give an implementation for a fixed instance of the template. For instance,
the following interface is for a function template of the name
#dyncode("eq_elt_elt"):

#atscode("\
fun{a:t0p}
eq_elt_elt (x: a, y: a): bool // a generic equality
")

There is no meaningful generic implementation for #dyncode("eq_elt_elt") as
equality test for values of a type T depends on T.  Two specific template
implementations are given as follows for the instances
#dyncode("eq_elt_elt&lt;int&gt;") and #dyncode("eq_elt_elt&lt;double&gt;"):

#atscode("\
implement eq_elt_elt<int> (x, y) = g0int_eq (x, y)
implement eq_elt_elt<double> (x, y) = g0float_eq (x, y)
")

where #dyncode("eq_int_int") and #dyncode("eq_double_double") are equality
functions for values of the type #stacode("int") and #stacode("double"),
respectively. It is also possible to give the implementations as follows:

#atscode("\
implement eq_elt_elt<int> (x, y) = (x = y)
implement eq_elt_elt<double> (x, y) = (x = y)
")

This is allowed as the symbol #dyncode("=") is already overloaded with
#dyncode("g0int_eq") and #dyncode("g0float_eq") (in addition to many other
functions).\

")#comment("para")

#para("\

Let us now see a typical use of specific template implementation.  The
following defined function template #dyncode("listeq") implements an
equality function on lists:

#atscode("\
fun{
a:t0p
} listeq
(
  xs: list0 a
, ys: list0 a
) : bool = (
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq_elt_elt<a> (x, y) then listeq (xs, ys) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
) (* end of [listeq] *)
")

Given two lists xs and ys, #dyncode("listeq") returns #dyncode("true") if
and only if xs and ys are of the same length and each element in xs equals
the corresponding one in ys (according to #dyncode("eq_elt_elt")).
Given a type T, it is clear that the instance
#dyncode("eq_elt_elt&lt;T&gt;") is needed if #dyncode("listeq") is called
on two lists of the type #stacode("list0(T)"). In other words, a specific
implementation for #dyncode("eq_elt_elt&lt;T&gt;") should be given if a
call to #dyncode("listeq") is to be made on two lists of the type
#stacode("list0(T)"). Note that the implementation for an instance of a
function template is required to be accessible from the file where the
instance is called.\

")

#comment("para")

#para("\
As a comparison, the following defined function template
#dyncode("listeqf") also implements equality test on two given lists:

#atscode("\
fun{
a:t0p
} listeqf
(
  xs: list0 a
, ys: list0 a
, eq: (a, a) -> bool
) : bool = (
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq (x, y) then listeqf (xs, ys, eq) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
) (* end of [listeqf] *)
")

In this case, #dyncode("listeqf") takes an additional argument
#dyncode("eq") that tests whether two list elements are equal.  As
#dyncode("listeq") is a first-order function while #dyncode("listeqf") is a
higher-order one, it is likely for the former to be compiled into more
efficient object code. I would like to point out that the library of ATS
makes pervasive use of specifically implemented templates.

")#comment("para")

#para("\
Please find the code presented in this section plus some additional
testing code available #mycodelink("CHAP_MODULARITY/listeq.dats", "on-line").
")

</sect1><!--id="specific_template_implementation"-->

<!-- ****** ****** -->

<sect1 id="abstract_types">
<title>
Abstract Types
</title>

#para("\

The name <emphasis>abstract type</emphasis> refers to a type such
that values of the type are represented in a way that is completely hidden
from users of the type. This form of information-hiding attempts to ensure
that changes to the implementation of an abstract type cannot introduce
type-errors into well-typed code that makes use of the abstract type. In
ATS as well as in many other programming languages, abstract types play a
pivotal role in support of modular programming. I will present as follows a
concrete example to illustrate a typical use of abstract types in
practice.\

")

#para("\

Suppose that we are to implement a package to provide various
funtionalities on finite sets of integers. We first declare an abstract
type #stacode("intset") as follows for values representing finite sets of
integers:

#atscode("\
abstype intset // a boxed abstract type
")

The keyword #stacode("abstype") indicates that the declared abstract type
#stacode("intset") is boxed, that is, the size of #stacode("intset") is the
same as that of a pointer.  There is a related keyword #stacode("abst@ype")
for introducing unboxed abstract types, which will be explained elsewhere.
We next present an interface for each function or value that we want to
implement in the package:

#atscode("\
// empty set
val intset_empty : intset

// singleton set of [x]
fun intset_make_sing (x: int): intset

// turning a list into a set
fun intset_make_list (xs: list0 int): intset

// turning a set into a list
fun intset_listize (xs: intset): list0 (int)

// membership test
fun intset_ismem (xs: intset, x: int): bool

// computing the size of [xs]
fun intset_size (xs: intset): size_t

// adding [x] into [xs]
fun intset_add (xs: intset, x: int): intset

// deleting [x] from [xs]
fun intset_del (xs: intset, x: int): intset

// union of [xs1] and [xs2]
fun intset_union (xs1: intset, xs2: intset): intset

// intersection of [xs1] and [xs2]
fun intset_inter (xs1: intset, xs2: intset): intset

// difference between [xs1] and [xs2]
fun intset_differ (xs1: intset, xs2: intset): intset
")

Let us now suppose that the declaration for #stacode("intset") and the
above interfaces are all stored in a file named #filename("intset.sats")
(or any other legal name for a static file).\

")#comment("para")

#para("\

Usually, a realistic implementation for finite sets is based on some kind
of balanced trees (e.g., AVL trees, red-black trees). For the purpose of
illustration, I hereby give an implementation in which finite sets of
integers are represented as ordered lists of integers. This implementation
is contained in a file named #filename("intset.dats"), which is available
#mycodelink("CHAP_MODULARITY/intset.dats", "on-line").  In order to
construct values of an abstract type, we need to concretize it temporarily
by using the following form of declaration:

#atscode("\
assume intset = list0 (int)
")

where #stacode("assume") is a keyword. This assume-declaration equates
#stacode("intset") with the type #stacode("list0 (int)") and this equation is
valid until the end of the scope in which it is introduced. As the
assume-declaration is at the toplevel in #filename("intset.dats"),
the assumption that #stacode("intset") equals #stacode("list0 (int)") is valid
until the end of the file. There is a global restriction in ATS that allows
each abstract type to be concretized by an assume-declaration at most
once. More specifically, if an abstract type is concretized in two files
#filename("foo1.dats") and #filename("foo2.dats"), then
these two files cannot be used together to generate an executable.

The rest of implementation in #stacode("intset") is all standard.  For
instance, the union operation on two given sets of integers is implemented
as follows:

#atscode("\
implement
intset_union
  (xs1, xs2) = (
case+ (xs1, xs2) of
| (list0_cons (x1, xs11),
   list0_cons (x2, xs21)) =>
  let
    val sgn = compare (x1, x2)
  in
    case+ 0 of
    | _ when sgn < 0 =>
        list0_cons{int}(x1, intset_union (xs11, xs2))
    | _ when sgn > 0 =>
        list0_cons{int}(x2, intset_union (xs1, xs21))
    | _ (* sgn = 0 *) =>
        list0_cons{int}(x1, intset_union (xs11, xs21))
    // end of [case]
  end // end of [(cons, cons)]
| (list0_nil (), _) => xs2
| (_, list0_nil ()) => xs1
) (* end of [intset_union] *)
")

There is also some testing code available
#mycodelink("CHAP_MODULARITY/test_intset.dats", "on-line")
that makes use of some functions declared in
#filename("intset.sats").  Often testing code as such is
constructed immediately after the interfaces for various functions and
values in a package are declared. This allows these interfaces to be tried
before they are actually implemented so that potential flaws can be exposed
in a timely fashion.
")#comment("para")

</sect1><!--id="abstract_types"-->

<!-- ****** ****** -->

<sect1 id="example_a_package_for_rationals">
<title>
Example: A Package for Rationals
</title>

#para("\

Let us represent a rational number as a pair of integers.  If we declare a
boxed abstract type #stacode("rat") for values representing rational
numbers, then each value of the type #stacode("rat") is stored in
heap-allocated memory, which can only be reclaimed through garbage
collection (GC). Instead, we follow an alternative approach by declaring
#stacode("rat") as an unboxed abstract type. Therefore, a declaration like
the following one is expected:

#atscode("\
abst@ype rat
")

The problem with this declaration is that it is too abstract. As there is
not information given about the size of the type #stacode("rat"), the ATS
compiler does not even know how much memory is needed for storing a value
of the type #stacode("rat"). However, the programmer should not assume that
such a form of declaration is useless. There are realistic circumstances
where a declaration of this form can be of great importance, and this is a
topic I will cover elsewhere. For now, let us declare an unboxed abstract
type as follows:

#atscode("\
abst@ype rat = (int, int)
")

This declaration simply informs the ATS compiler that the representation
for values of the type #stacode("rat") is the same as the one for values of
the type #stacode("(int, int)"). However, this information is not made
available to the typechecker of ATS. In particular, if a value of the type
#stacode("rat") is treated as a pair of integers in a program, then a
type-error will surely occur.  ")#comment("para")

#para("\
The following code is contained in a file named
#filename("ratmod.sats"), which is available
#mycodelink("CHAP_MODULARITY/ratmod.sats", "on-line").

#atscode("\
exception Denominator
exception DivisionByZero

fun rat_make_int_int (p: int, q: int): rat

fun ratneg: (rat) -> rat // negation
fun ratadd: (rat, rat) -> rat // addition
fun ratsub: (rat, rat) -> rat // subtraction
fun ratmul: (rat, rat) -> rat // multiplication
fun ratdiv: (rat, rat) -> rat // division
")

The exception #dyncode("Denominator") is for reporting an erroneous
occasion where a rational number is to be formed with a denominator equal
to zero.  Given two integers representing the numerator and denominator of
a rational number, the function #dyncode("rat_make_int_int") returns a
value representing the rational number. The following implementation of
#dyncode("rat_make_int_int") can be found in a file named
#filename("ratmod.dats"), which is also available
#mycodelink("CHAP_MODULARITY/ratmod.dats", "on-line").

#atscode("\
implement
rat_make_int_int (p, q) = let
  fun make (
    p: int, q: int
  ) : rat = let
    val r = gcd (p, q) in (p / r, q / r)
  end // end of [make]
//
  val () = if q = 0 then $raise Denominator
//
in
  if q > 0 then make (p, q) else make (~p, ~q)
end // end of [rat_make_int_int]
")

Given a pair of integers p and q such that q is not zero, the function
#dyncode("rat_make_int_int") returns another pair of integers
p<subscript>1</subscript> and q<subscript>1</subscript> such that
q<subscript>1</subscript> is positive, p<subscript>1</subscript> and
q<subscript>1</subscript> are coprimes, that is, their greatest common
divisor is 1, and p<subscript>1</subscript>/q<subscript>1</subscript>
equals p/q. With #dyncode("rat_make_int_int"), it is straightforward to
implement as follows the arithmetic operations on rational numbers:

#atscode("\
implement ratneg (x) = (~x.0, x.1)

implement
ratadd (x, y) =
  rat_make_int_int (x.0 * y.1 + x.1 * y.0, x.1 * y.1)
// end of [ratadd]

implement
ratsub (x, y) =
  rat_make_int_int (x.0 * y.1 - x.1 * y.0, x.1 * y.1)
// end of [ratsub]

implement
ratmul (x, y) = rat_make_int_int (x.0 * y.0, x.1 * y.1)

implement
ratdiv (x, y) = (
if y.0 > 0
  then rat_make_int_int (x.0 * y.1, x.1 * y.0) else $raise DivisionByZero()
// end of [if]
) (* end of [ratdiv] *)
")

There is also some testing code available
#mycodelink("CHAP_MODULARITY/test_ratmod.dats", "on-line") that makes
use of some functions declared in #filename("ratmod.sats").

")#comment("para")

</sect1><!--id="example_a_package_for_rationals"-->

<!-- ****** ****** -->

<sect1 id="example_a_functorial_package_for_rationals">
<title>
Example: A Functorial Package for Rationals
</title>

#para("\

The previous package for rational numbers contains a serious limitation:
The type for the integers employed in the representation of rational
numbers is fixed to be #stacode("int"). If we ever want to represent
rational numbers based on integers of a different type (for instance,
#stacode("lint") for long integers or #stacode("llint") for long long
integers), then we need to implement another package for rationals based on
such integers. It is clearly advantageous to avoid this style of
programming as it involves code duplication to a great extent.  ")

#para("\

The approach I employ in this section to implement a package for rational
numbers that can address the aforementioned limitation follows the idea of
functors in the programming language Standard ML (SML). Let us first
introduce a type definition as follows:

#atscode("\
typedef
intmod (a:t@ype) = '{
  ofint= int -> a
, fprint= (FILEref, a) -> void
, neg= (a) -> a // negation
, add= (a, a) -> a // addition
, sub= (a, a) -> a // subtraction
, mul= (a, a) -> a // multiplication
, div= (a, a) -> a // division
, mod= (a, a) -> a // modulo operation
, cmp= (a, a) -> int // comparison
} // end of [intmod]
")

Given a type T, #stacode("intmod(T)") is a boxed record type in which each
field is a function type. A value of the type #stacode("intmod(T)") is
supposed to represent a module of integer operations on integers
represented by values of the type T. Similarly, let us introduce another
type definition as follows:

#atscode("\
abst@ype rat (a:t@ype) = (a, a)

typedef
ratmod (a:t@ype) = '{
  make= (a, a) -<cloref1> rat a
, fprint= (FILEref, rat a) -<cloref1> void
, numer= rat a -> a // numerator
, denom= rat a -> a // denominator
, neg= (rat a) -<cloref1> rat a // negation
, add= (rat a, rat a) -<cloref1> rat a // addition
, sub= (rat a, rat a) -<cloref1> rat a // subtraction
, mul= (rat a, rat a) -<cloref1> rat a // multiplication
, div= (rat a, rat a) -<cloref1> rat a // division
, cmp= (rat a, rat a) -<cloref1> int // comparison
} // end of [ratmod]
")

Given a type T, a value of the type #stacode("ratmod(T)") is supposed to
represent a module of rational operations on rationals represented by
values of the type #stacode("rat(T)"). The function we need to implement can
now be given the following interface:

#atscode("\
fun{a:t@ype} ratmod_make_intmod (int: intmod a): ratmod a
")

If applied to a given module of integer operations,
#dyncode("ratmod_make_intmod") returns a module of rational operations such
that the integers in the former and the latter modules have the same
representation. Therefore, #dyncode("ratmod_make_intmod") behaves like a
functor in SML.  In the following code, let us implement two modules
#dyncode("ratmod_int") and #dyncode("ratmod_dbl") of rational operations in
which integers are represented as values of the types #stacode("int") and
#stacode("double"), respectively:

#atscode('\
staload M = "libc/SATS/math.sats"

val ratmod_int = let
//
val intmod_int = \'{
  ofint= lam (i) => i
, fprint= lam (out, x) => $extfcall (void, "fprintf", out, "%i", x)
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => x / y
, mod= lam (x, y) => op mod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (int) // end of [val]
//
in
  ratmod_make_intmod<int> (intmod_int)
end // end of [val]

val ratmod_dbl = let
//
val intmod_dbl = \'{
  ofint= lam (i) => g0i2f(i)
, fprint= lam (out, x) => $extfcall (void, "fprintf", out, "%0.f", x)
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => $M.trunc (x / y) // truncation
, mod= lam (x, y) => $M.fmod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (double) // end of [val]
//
in
  ratmod_make_intmod<double> (intmod_dbl)
end // end of [ratmod_dbl]
')

An implementation of the function #dyncode("ratmod_make_intmod") is
available #mycodelink("CHAP_MODULARITY/ratfun.dats", "on-line") and there
is some related testing code available
#mycodelink("CHAP_MODULARITY/test_ratfun.dats", "on-line") as well.\

")#comment("para")

</sect1><!--id="example_a_functorial_package_for_rationals"-->

</chapter><!--id="modularity"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
