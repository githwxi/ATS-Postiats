%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/ats2tutorial.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="reference">
#title("Persistent References")

#para("\

A reference is essentially a heap-allocated array of size 1. It is
persistent in the sense that the memory allocated for storing the content
of a reference cannot be freed manually. Instead, it can only be (safely)
reclaimed through garbage collection (GC).

")

#para("\

Given a viewtype VT, the type for references to values of viewtype VT is
#stacode("ref")(VT). For convenience, the type constructor #stacode("ref")
is declared to be abstract in ATS. However, it can be defined as follows:

#atscode('\
typedef ref (a:vt@ype) = [l:addr] (vbox (a @ l) | ptr l)
')

The interfaces for various functions on references can be found in
#myatscodelink("prelude/SATS/reference.sats", "prelude/SATS/reference.sats").\

")#comment("para")

#para("\
For creating a reference, the function template #dyncode("ref_make_elt") of
the following interface can be called:

#atscode('\
fun{a:vt@ype} ref_make_elt (x: a):<!wrt> ref a
')

Note that the symbol #stacode("!wrt") indicates that the so-called
#stacode("wrt")-effect may occur when #dyncode("ref_make_elt") is called.

For reading writing through a reference, the function templates
#dyncode("ref_get_elt") and #dyncode("ref_set_elt") can be used,
respectively, which are assigned the following interfaces:

#atscode('\
fun{a:t@ype} ref_get_elt (r: ref a):<!ref> a
fun{a:t@ype} ref_set_elt (r: ref a, x: a):<!refwrt> void
')

Note that the symbol #stacode("!ref") indicates that the so-called
ref-effect may occur when #dyncode("ref_get_elt") is evaluated. Similarly,
#stacode("!refwrt") means both ref-effect and wrt-effect may occur when
#dyncode("ref_set_elt").  Given a reference #dyncode("r") and a value
#dyncode("v"), #dyncode("ref_get_elt(r)") and #dyncode("ref_set_elt(r, v)")
can be written as #dyncode("!r") and #dyncode("!r := v"), respectively.\

")#comment("para")

#para("\

A reference is typically employed to record some form of persistent state.
For instance, following is such an example:

#atscode_extract('\
local
//
// [ref]: shorthand for [ref_make_elt]
//
val count = ref<int> (0)

in (* in of [local] *)

fun getNewName
  (prfx: string): string = let
  val n = !count
  val () = !count := n + 1
  val name = sprintf ("%s%i", @(prfx, n))
in
  strptr2string (name)
end // end of [getNewName]

end // end of [local]
')

The function #dyncode("getNewName") is called to generate fresh names. As
the integer content of the reference #dyncode("count") is updated whenever
a call to #dyncode("getNewName") is made, each name returned by
#dyncode("getNewName") is guaranteed to have not been generated
before. Note that each string returned by #dyncode("sprinf") is a linear
one (of the type #dyncode("Strptr1")) and the cast funtion
#dyncode("strptr2string") is called to turn it into a nonlinear one. There
is no run-time cost associated with such a call as every call to a cast
function is always a no-op at run-time.

")#comment("para")

#para("\

#emphasis("Misuse of References")
References are commonly misused in practice. The following program is often
written by a beginner of functional programming who has already learned
(some) imperative programming:

#atscode_extract('\
fun fact
  (n: int): int = let
  val res = ref<int> (1)
  fun loop (n: int):<cloref1> void =
    if n > 0 then !res := n * !res else ()
  val () = loop (n)
in
  !res
end // end of [fact]
')

The function #dyncode("fact") is written in such a style as somewhat a direct
translation of the following C code:

#atscode('\
int fact (int n) {
  int res = 1 ;
  while (n > 0) res = n * res ;
  return res ;
}
')

In the ATS implementation of #dyncode("fact"), #dyncode("res") is a
heap-allocated reference and it becomes garbage (waiting to be reclaimed by
the GC) after a call to #dyncode("fact") returns.  On the other hand, the
variable #dyncode("res") in the C implementation of #dyncode("fact") is
stack-allocated (or it can even be mapped to a machine register), and there
is no generated garbage after a call to #dyncode("fact") returns. A proper
translation of the C implementation in ATS can actually be given as
follows, which makes no use of references:

#atscode_extract('\
fun fact
  (n: int): int = let
  fun loop (n: int, res: int): int =
    if n > 0 then loop (n, n * res) else res
  // end of [loop]
in
  loop (n, 1)
end // end of [fact]
')

")#comment("para")

#para("\

Unless strong justification can be given, making extensive use of
(dynamically created) references is often a sure sign of poor coding style.

")#comment("para")

#para("\

#emphasis("Statically Allocated References")
Creating a reference by calling #dyncode("ref_make_elt") involves dynamic
memory allocation. If this is not desirable or even acceptable, it is
possible to only employ statically allocated memory in a reference creation
as is shown below:

#atscode_extract('\
var myvar: int = 0
val myref = ref_make_viewptr (view@(myvar) | addr@(myvar))
')

The function #dyncode("ref_make_viewptr") takes a pointer and a proof of
some at-view associated with the pointer and returns a reference after
consuming the proof. As #dyncode("ref_make_viewptr") is a cast-function, it
causes no run-time overhead. In the above code, #dyncode("myvar") is
statically allocated and it is no longer available after its at-view proof
is consumed by #dyncode("ref_make_viewptr"). It should be interesting to
observe that both #dyncode("myvar") and #dyncode("myref") are just the same
pointer in C but they are the reification of fundamentally different
concepts in ATS: the former is a linear variable while the latter is a
non-linear reference.

")#comment("para")

</chapter><!--"reference"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
//
staload STDIO = "libc/SATS/stdio.sats"
//
implement main () =
{
//
val filr =
  $STDIO.fopen_ref_exn ("../CODE/chap_reference.dats", file_mode_w)
val () = fprint_theCodeLst (filr)
val () = $STDIO.fclose_exn (filr)
//
val () = fprint_filsub (stdout_ref, "main_atxt.txt")
//
}
%}
