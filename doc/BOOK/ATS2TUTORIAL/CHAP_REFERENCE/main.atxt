%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/ats2tutorial.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="reference"
>#title("References")

#para("\

A reference is a singleton array, that is, an array of size 1.  It is
persistent in the sense that the (heap-allocated) memory for storing the
content of a reference cannot be freed manually in a type-safe
manner. Instead, it can only be reclaimed through garbage collection (GC).

")

#para("\

Given a viewtype VT, the type for references to values of viewtype VT is
#stacode("ref")(VT). For convenience, the type constructor #stacode("ref")
is declared to be abstract in ATS. However, it can be defined as follows:

#atscode('\
typedef ref (a:vt@ype) = [l:addr] (vbox (a @ l) | ptr l)
')

The interfaces for various functions on references can be found in
#myatscodelink("prelude/SATS/reference.sats", "prelude/SATS/reference.sats").\

")#comment("para")

#para("\
For creating a reference, the function template #dyncode("ref_make_elt") of
the following interface can be called:

#atscode('\
fun{a:vt@ype} ref_make_elt (x: a):<!wrt> ref a
')

It is also allowed to use the shorthand #dyncode("ref") for
#dyncode("ref_make_elt").  Note that the symbol #stacode("!wrt") indicates
that the so-called #stacode("wrt")-effect may occur when
#dyncode("ref_make_elt") is called.

")

#para("\

For reading writing through a reference, the function templates
#dyncode("ref_get_elt") and #dyncode("ref_set_elt") can be used,
respectively, which are assigned the following interfaces:

#atscode('\
fun{a:t@ype} ref_get_elt (r: ref a):<!ref> a
fun{a:t@ype} ref_set_elt (r: ref a, x: a):<!refwrt> void
')

Note that the symbol #stacode("!ref") indicates that the so-called
ref-effect may occur when #dyncode("ref_get_elt") is evaluated. Similarly,
#stacode("!refwrt") means both ref-effect and wrt-effect may occur when
#dyncode("ref_set_elt").  Given a reference #dyncode("r") and a value
#dyncode("v"), #dyncode("ref_get_elt(r)") and #dyncode("ref_set_elt(r, v)")
can be written as #dyncode("!r") and #dyncode("!r := v"), respectively.\

")#comment("para")

#para("\

A reference is typically employed to record some form of persistent state.
For instance, following is such an example:

#atscode_extract('\
local
//
\#define BUFSZ 128
//
val count = ref<int> (0)
//
in (* in of [local] *)

fun genNewName
  (prfx: string): string = let
  val n = !count
  val () = !count := n + 1
  var res = @[byte][BUFSZ]((*void*))
  val err =
  $extfcall (
    int, "snprintf", addr@res, BUFSZ, "%s%i", prfx, n
  ) (* end of [$extfcall] *)
in
  strptr2string(string0_copy($UNSAFE.cast{string}(addr@res)))
end // end of [genNewName]

end // end of [local]
')

The function #dyncode("genNewName") is called to generate fresh names. As
the integer content of the reference #dyncode("count") is updated whenever
a call to #dyncode("genNewName") is made, each name returned by
#dyncode("genNewName") is guaranteed to have not been generated
before. Note that the use of #keycode("$extfcall") is for making a direct
call to the function #dyncode("snprintf") in C.

")#comment("para")

#para("\

#emphasis("Misuse of References")
References are commonly misused in practice. The following program is often
written by a beginner of functional programming who has already learned
(some) imperative programming:

#atscode_extract('\
fun fact
  (n: int): int = let
  val res = ref<int> (1)
  fun loop (n: int):<cloref1> void =
    if n > 0 then !res := n * !res else ()
  val () = loop (n)
in
  !res
end // end of [fact]
')

The function #dyncode("fact") is written in such a style as somewhat a direct
translation of the following C code:

#atscode('\
int fact (int n) {
  int res = 1 ;
  while (n > 0) res = n * res ;
  return res ;
}
')

In the ATS implementation of #dyncode("fact"), #dyncode("res") is a
heap-allocated reference and it becomes garbage (waiting to be reclaimed by
the GC) after a call to #dyncode("fact") returns.  On the other hand, the
variable #dyncode("res") in the C implementation of #dyncode("fact") is
stack-allocated (or it can even be mapped to a machine register), and there
is no generated garbage after a call to #dyncode("fact") returns. A proper
translation of the C implementation in ATS can actually be given as
follows, which makes no use of references:

#atscode_extract('\
fun fact
  (n: int): int = let
  fun loop (n: int, res: int): int =
    if n > 0 then loop (n, n * res) else res
  // end of [loop]
in
  loop (n, 1)
end // end of [fact]
')

")#comment("para")

#para("\

Unless strong justification can be given, making extensive use of
(dynamically created) references is often a sure sign of poor coding style.

")#comment("para")

#para("\

#emphasis("Statically Allocated References")
Creating a reference by calling #dyncode("ref_make_elt") involves dynamic
memory allocation. If this is not desirable or even acceptable, it is
possible to only employ statically allocated memory in a reference creation
as is shown below:

#atscode_extract('\
var myvar: int = 0
val myref = ref_make_viewptr (view@(myvar) | addr@(myvar))
')

The function #dyncode("ref_make_viewptr") takes a pointer and a proof of
some at-view associated with the pointer and returns a reference after
consuming the proof. As #dyncode("ref_make_viewptr") is a cast-function, it
causes no run-time overhead. In the above code, #dyncode("myvar") is
statically allocated and it is no longer available after its at-view proof
is consumed by #dyncode("ref_make_viewptr"). It should be interesting to
observe that both #dyncode("myvar") and #dyncode("myref") are just the same
pointer in C but they are the reification of fundamentally different
concepts in ATS: the former is a linear variable while the latter is a
non-linear reference.

")#comment("para")

#para("\

Please find #mycodelink("chap_reference.dats", "on-line") the entirety of the
code used in this chapter.\

")#comment("para")

</chapter><!--"reference"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
//
staload STDIO = "libc/SATS/stdio.sats"
//
implement main () =
{
//
val filr =
  $STDIO.fopen_ref_exn ("../TEMP/chap_reference.dats", file_mode_w)
val () = fprint_theCodeLst (filr)
val () = $STDIO.fclose_exn (filr)
//
val () = fprint_filsub (stdout_ref, "main_atxt.txt")
//
} (* end of [main] *)
%}
