

<!DOCTYPE html>
<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>EFFECTIVATS-Producer-Consumer</title>
<style type="text/css">
  .patsyntax {color:#808080;background-color:#E0E0E0;}
  .patsyntax span.keyword {color:#000000;font-weight:bold;}
  .patsyntax span.comment {color:#787878;font-style:italic;}
  .patsyntax span.extcode {color:#A52A2A;}
  .patsyntax span.neuexp  {color:#800080;}
  .patsyntax span.staexp  {color:#0000F0;}
  .patsyntax span.prfexp  {color:#603030;}
  .patsyntax span.dynexp  {color:#F00000;}
  .patsyntax span.stalab  {color:#0000F0;font-style:italic}
  .patsyntax span.dynlab  {color:#F00000;font-style:italic}
  .patsyntax span.dynstr  {color:#008000;font-style:normal}
  .patsyntax span.stacstdec  {text-decoration:none;}
  .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
  .patsyntax span.dyncstdec  {text-decoration:none;}
  .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
  .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
</style>

<style type="text/css">
  @import url("https://fonts.googleapis.com/css?family=Lato:400,300,700");

  body {
    margin: 0 auto;
    width: 66%;
    font-family: "Lato", sans-serif;
    font-weight: 400;
    font-size: 15pt;
    color: #2E2E2E;
    padding-left: 2em;
    padding-right: 2em;
    border-left: 1px solid #acacac;
    border-right: 1px solid #acacac;
  }
  pre, .patsyntax {
    color: black;
    background-color: #FEFFEC;
    border: 1px solid #acacac;
    border-left: 5px solid #BCBCBC;
    padding: 20px;
    margin: 1.5em 0;
    font-family: monospace;
    font-size: 0.75em;
    overflow: auto;
    line-height: 1.3em;
  }
  h1, h2, h3 {
    font-family: "Lato", sans-serif;
  }
  h1 {
    border: 1px solid #8c8c8c;
    font-size: 1.2em;
    padding: 5px;
    background-color: #EEF;
    box-shadow: 1px 1px 2px #999;
    text-align: center;
  }
  h2 {
    border-bottom: 1px solid #8C8C8C;
    padding: 5px;
    margin-top: 1em;
    font-size: 1.2em;
    text-align: left;
  }
  h4 {
    border-bottom: 1px dashed #8C8C8C;
  }
  ol, ul {
    list-style: none;
    padding-left: 0;
  }
  li:first-child {
    border-top: 1px solid #EEF;
  }
  li:hover {
    background-color: #EEF;
  }
  li {
    border-bottom: 1px solid #EEF;
    border-left: 1px solid #EEF;
    border-right: 1px solid #EEF;
  }
  li a {
    display: inline-block;
    width: 100%;
    height: 100%;
    padding: 5px;
  }

  a:hover {
    color: black;
  }
  a:visited {
    color: #7D7D7D;
  }
  a {
    text-decoration: none;
    color: #0062BB;
  }

  @media print {
  body {
    margin: 0 auto;
    width: 90%;
    font-size: 12pt;
    border-left: 0;
    border-right: 0;
  }
  pre, .patsyntax {
    color: black;
    padding: 10px;
    font-size: 10pt;
  }
  h1 {
    box-shadow: none;
  }
  }
</style>

</head>

<body>

<h1>
Effective ATS:<br>
Producer-Consumer
</h1>

The Producer-Consumer problem is a classical one in concurrent programming.
In this article, I present an implementation of this problem that makes
highly effective use of dependent types and linear types.  Due to great
difficulty in debugging concurrent programs, relying on static checking to
detect and fix bugs is of much more significance in concurrent programing
than in sequential programming.  While the style of programming I employ
here may take time for one to master, the great advantages it brings can be
readily appreciated. In general, ATS shines much more brightly in contexts
where dynamic testing becomes more difficult to perform and/or control.

<h2>
Description of the Problem 
</h2>

Given a buffer of finite capacity, there are multiple producers who insert
items into the buffer and also multiple consumers who take out items from
the buffer. If a producer wants to insert an item but the buffer is full,
the producer is blocked until the buffer becomes not full. If a consumer
wants to take out an item but the buffer is empty, then the consumer is
blocked until the buffer is not empty.

<h2>
Interface for Linear Buffer
</h2>

Let us first declare as follows a linear abstract type for buffers:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
buffer_vtype<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> m<span class="keyword">:</span>int<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">buffer<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">buffer_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">buffer<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>int</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">buffer_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</pre>

Given a type T and two integers M and N, the type
<span style="color: #0000F0;">buffer(T, M, N)</span> is for a buffer of capacity M in which N
elements of the type T are stored.  The following lemma can be used to
establish the property that M >= N and N >= 0 (for the purpose of
constraint-solving):

<pre
class="patsyntax">
<span class="prfexp"><span class="keyword">praxi</span>
lemma_buffer_param<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m &gt;= n<span class="keyword">;</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
</pre>

The function <span style="color: #F00000;">buffer_make_nil</span> can be called to create a linear buffer of a
given capacity that contains no elements:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_make_nil<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>pos<span class="keyword">}</span></span> <span class="keyword">(</span>cap<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
</pre>

The functions <span style="color: #F00000;">buffer_isnil</span> and <span style="color: #F00000;">buffer_isful</span>
can be called to test whether a given buffer is empty and full,
respectively:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> buffer_isnil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> buffer_isful<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">m</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span></span>
</pre>

The function <span style="color: #F00000;">buffer_insert</span> is for inserting an element into
a buffer that is not full:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_insert<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&lt;</span> m<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [buffer_insert]</span>
</pre>

The function <span style="color: #F00000;">buffer_takeout</span> is for taking out an element from
a buffer that is not empty:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
buffer_takeout<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

<h2>
Interface for Shared Buffer
</h2>

In terms of implementation, a shared buffer wraps a protection mechanism
around a linear buffer that consists of a mutex and two conditional
variables. The mutex is for protecting the linear buffer and the
conditional variables are introduced to avoid busy-waiting. I will present
more details on the protection mechanism later.

<p>

Let us now introduce an abstract type for shared buffers:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abstype</span>
sbuffer_type<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype</span><span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">sbuffer<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">sbuffer_type</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</pre>

Please note that <span style="color: #0000F0;">sbuffer</span> is a non-linear type. This means
that a shared buffer cannot be freed explicitly after its creation. It
is also possible to make <span style="color: #0000F0;">sbuffer</span> a reference-counted
linear type so that a shared buffer can be freed. The interested
reader is encouraged to give this alternative design a try, which
should only lead to slightly more involved implementation.

<p>

Given a linear buffer, <span style="color: #F00000;">sbuffer_make_buffer</span> turns it into a
shared buffer (by wrapping a protection mechanism around it):

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_make_buffer <span class="keyword">(</span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

The function <span style="color: #F00000;">sbuffer_insert</span> inserts an element into
a shared buffer:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_insert <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// called by producer</span>
</pre>

Note that a call to <span style="color: #F00000;">sbuffer_insert</span> may be blocked due to the linear
buffer inside the shared buffer being full.

<p>

The function <span style="color: #F00000;">sbuffer_takeout</span> takes out an element from
a shared buffer:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_takeout <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// called by consumer</span>
</pre>

Note that a call to <span style="color: #F00000;">sbuffer_takeout</span> may be blocked due to
the linear buffer inside the shared buffer being empty.

<h2>
Implementation of Shared Buffer
</h2>

The linear buffer inside a shared buffer is protected by a mutex.

<p>

The function <span style="color: #F00000;">sbuffer_acquire</span> is for acquiring the linear
buffer inside a given shared buffer:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> sbuffer_acquire<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

The function <span style="color: #F00000;">sbuffer_release</span> is for releasing a linear
buffer (to the same shared buffer from which the linear buffer was
previously acquired):

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_release<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>


Let us now declare two functions as follows:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_insert2 <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sbuffer_takeout2 <span class="keyword">(</span>sbf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
</pre>

A call to the function <span style="color: #F00000;">sbuffer_insert2</span> tries to insert an
element into a given linear buffer. In the case where the linear
buffer is full, the caller is blocked to wait on some conditional
variable until it is notified that the linear buffer is no longer
full.

<p>

A call to the function <span style="color: #F00000;">sbuffer_takeout2</span> tries to take out
an element from a given linear buffer. In the case where the linear
buffer is empty, the caller is blocked to wait on some conditional
variable until it is notified that the linear buffer is no longer
empty.

<p>

It is straightforward to implement <span style="color: #F00000;">sbuffer_insert</span> and
<span style="color: #F00000;">sbuffer_takeout</span> based on <span style="color: #F00000;">sbuffer_insert2</span> and
<span style="color: #F00000;">sbuffer_takeout2</span>, respectively:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_insert <span class="keyword">(</span>sbuf<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> buf <span class="keyword">=</span> sbuffer_acquire <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_insert2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_release <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
<span class="keyword">}</span></span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_takeout <span class="keyword">(</span>sbuf<span class="keyword">)</span> <span class="keyword">=</span> x <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> buf <span class="keyword">=</span> sbuffer_acquire <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> x<span class="comment">(*a*)</span> <span class="keyword">=</span> sbuffer_takeout2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> sbuffer_release <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
<span class="keyword">}</span></span>
</pre>

There are two conditional variables (CVs) inside a shared buffer.  One of
them is for handling the condition of the linear buffer (inside the shared
buffer) being empty, and the other CV is for handling the condition of the
linear buffer being full. The following functions are implemented directly
based on these two conditional variables:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_wait_isnil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_signal_isnil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_wait_isful
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">buffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span>
sbuffer_signal_isful<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>sbuf<span class="keyword">:</span> <span class="staexp">sbuffer</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
</pre>

The type assigned to the function <span style="color: #F00000;">sbuffer_wait_isnil</span> means
that its caller must have possession of a linear buffer when calling
it and the caller should still have possession of the linear buffer,
which may be empty, when the call returns. The reason for the linear
buffer being still empty at the moment when a call to
<span style="color: #F00000;">sbuffer_wait_isnil</span> returns is that other callers
(consumers) may have gained access to the linear buffer earlier.

<p>

The type assigned to the function <span style="color: #F00000;">sbuffer_wait_isful</span> can be
explained similarly.

<p>

<h4>
Implementing <span style="color: #F00000;">sbuffer_insert2</span>
</h4>

An implementation of <span style="color: #F00000;">sbuffer_insert2</span> is given as follows:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_insert2
  <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isful <span class="keyword">=</span> buffer_isful <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_buffer_param <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isful
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      sbuffer_wait_isful <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    sbuffer_insert2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">,</span> x<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> buffer_isnil <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> buffer_insert <span class="keyword">(</span>buf<span class="keyword">,</span> x<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isnil <span class="keyword">then</span> sbuffer_signal_isnil <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">in</span>
    <span class="comment">// nothing</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [else]</span>
<span class="comment">//  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sbuffer_insert2]</span>
</pre>

The code should be self-explaining. Please note that inserting an element
into an empty buffer requires a signal to be sent to the CV handling the
condition of buffer being empty. If this is not done, then a deadlock may
occur as the consumers waiting on the CV can never be awakened.

<h4>
Implementing <span style="color: #F00000;">sbuffer_takeout2</span>
</h4>

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sbuffer_takeout2
  <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> buffer_isnil <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_buffer_param <span class="keyword">(</span>buf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> isnil
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      sbuffer_wait_isnil <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    sbuffer_takeout2 <span class="keyword">(</span>sbuf<span class="keyword">,</span> buf<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> x <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> isful <span class="keyword">=</span> buffer_isful <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> x<span class="comment">(*a*)</span> <span class="keyword">=</span> buffer_takeout <span class="keyword">(</span>buf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">if</span> isful <span class="keyword">then</span> sbuffer_signal_isful <span class="keyword">(</span>sbuf<span class="keyword">)</span></span>
  <span class="keyword">}</span> <span class="comment">(* end of [else] *)</span>
<span class="comment">//  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sbuffer_takeout2]</span>
</pre>

The code should be self-explaining. Please note that taking out an element
from a full buffer requires a signal to be sent to the CV handling the
condition of buffer being full. If this is not done, then a deadlock may
occur as the producers waiting on the CV can never be awakened.

<h4>
Summary of the Remaining Implementation
</h4>

The remaining implementation of the producer-consumer problem can be
readily done in C (based on pthread support for mutexes and
conditional variables). For instance, <span style="color: #0000F0;">sbuffer</span> can be
represented as a pointer to a value of the following struct type:

<pre>
struct
{
  void *buffer ;
  mutex_t mutex ;
  cond_t CVisnil ;
  cond_t CVisful ;
}
</pre>

Instead of being coded in C directly, the rest of my implementation is also
written in ATS but it makes pervasive use of some unsafe programming
features. Please find the entirety of the code in the files sbuffer.sats
and sbuffer.dats. There is no testing code in my implementation as I feel
highly confident about its correctness. A primary reason for programming in
ATS is that one can make effective use of types in ATS so as to convince
oneself that his or her code should perform as expected. I feel that I have
done it in this case.

<h2>
Safe Programming with Shared Resources
</h2>

In the rest of the article, I would like to outline a general approach
to safe programming with shared resources that can be seen as a generalization
of the implementation of the producer-consumer problem presented above.

<p>

Suppose we have a linear type <span style="color: #0000F0;">Resource</span> for values that we
want to share:

<pre
class="patsyntax">
<span class="staexp"><span class="keyword">absvtype</span> Resource</span>
</pre>

Let us introduce a (non-linear) type <span style="color: #0000F0;">SharedResource</span> for
values that are formed by wrapping some kind of protection mechnism
around linear values of the type <span style="color: #0000F0;">Resource</span>:

<pre
class="patsyntax">
<span class="staexp"><span class="keyword">abstype</span> SharedResource</span>
</pre>

The function that does the wrapping can be given the following type:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_create <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp">Resource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">SharedResource</span></span>
</pre>

The linear resource inside a shared resource is protected by a lock,
and the following two functions are for taking out the linear resource
and returning it back:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_acquire <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Resource</span></span>
<span class="dynexp"><span class="keyword">fun</span> SharedResource_release <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp">Resource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>

Let us now assume that we have the following function for processing
a linear resource:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> Resource_process <span class="keyword">(</span>R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>
</pre>

If a call to <span style="color: #F00000;">Resource_process</span> returns true, then the resource has been
processed properly. Otherwise, it is an indication that the state of the
resource needs to be changed before it is suitable for processing.

<p>

What we want to implement is the following function:

<pre
class="patsyntax">
<span class="dynexp"><span class="keyword">fun</span> SharedResource_process <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
</pre>

When called on a shared resource, <span style="color: #F00000;">SharedResource_process</span> tries to process
the linear resource inside it by calling <span style="color: #F00000;">Resource_process</span>.

<p>

An implementation of <span style="color: #F00000;">SharedResource_process</span> is sketched as follows:

<pre
class="patsyntax">
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
SharedResource_wait
  <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
SharedResource_process2
  <span class="keyword">(</span>SR<span class="keyword">:</span> <span class="staexp">SharedResource</span><span class="keyword">,</span> R<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Resource</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
SharedResource_process
  <span class="keyword">(</span>SR<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="dynexp"><span class="keyword">val</span> R <span class="keyword">=</span> SharedResource_acquire <span class="keyword">(</span>SR<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> SharedResource_release <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
<span class="keyword">}</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
SharedResource_process2
  <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> ans <span class="keyword">=</span> Resource_process <span class="keyword">(</span>R<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> ans
  <span class="keyword">then</span>
  <span class="keyword">(</span>
    <span class="comment">// processing is done properly</span>
    <span class="comment">// there may be a need to send signals</span>
    <span class="comment">// to some conditional variables</span>
  <span class="keyword">)</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
      SharedResource_wait <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
  <span class="keyword">in</span>
    SharedResource_process2 <span class="keyword">(</span>SR<span class="keyword">,</span> R<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [SharedResource_process2]</span>
<span class="comment">//</span>
</pre>

A call to <span style="color: #F00000;">SharedResource_wait</span> puts the caller on the waiting-list
of some conditional variable to avoid busy-waiting. Whenever the condition
needed for <span style="color: #F00000;">Resource_process</span> to do proper processing is met, a signal should
be sent to the conditional variable (by another caller).

<p>

Please find in the file SharedResource.dats the entirety of the code
presented in this section.

<hr size="2">

<p>
This article is written by <a href="http://www.cs.bu.edu/~hwxi/">Hongwei Xi</a>.
</p>
<script type="text/javascript">
  window.onload = function() {
    var links = [];
    var headers = document.getElementsByTagName('h2');

    for (var i = 0; i < headers.length; i++) {
        var header = headers[i];
        var subHeadings = header.getElementsByTagName('h4');
        var title = header.innerHTML;
        var link = title.trim().split(/\s/).map(function(x) { return x.toLowerCase(); }).join('-');
        var html = '<h2 id="' + link + '">' + title + '</h2>';
        var linkHtml = '<a href="#' + link + '">' + html + '</a>';
        header.outerHTML = linkHtml;
        links.push({link: link, title: title});
    }

    if (links.length > 0) {
        var sideBarHtml = '<h2>Table of Contents</h2>';
        sideBarHtml += '<ul class="sidebar-list">';
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            sideBarHtml += '<li class="sidebar-item">';
            sideBarHtml += '<a href="#' + link.link + '">' + link.title + '</a>';
            sideBarHtml += '</li>';
        }
        sideBarHtml += '</ul>';
        sideBarHtml += '<h2>Introduction</h2>';

        var sidebar = document.createElement('div');
        sidebar.className = 'sidebar';
        sidebar.innerHTML = sideBarHtml

        var mainTitle = document.getElementsByTagName('h1')[0];
        document.body.insertBefore(sidebar, mainTitle.nextSibling);
    }
  }
</script>

</body>
</html>


