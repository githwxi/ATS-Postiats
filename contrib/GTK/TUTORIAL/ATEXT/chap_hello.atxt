%{
//
dynload "libatsdoc/dynloadall.dats"
#include "utils/atsdoc/DOCUMENT/TUTORIALATS/tutorialatxt.dats"
//
#include "./ATEXT/ats2gtk.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from chap_hello.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="hello_world">
#title("Hello, world!")

#para("\

Let us write a program that creates a window containing a button.
The button can be be clicked to issue the message \"Hello, world!\".
In addition, the window can be closed by a simple click.

")

#para("\

The following code essentially outlines an implementation of such a program:

#atscode('\
fun
mymain
(
) : GtkWindow1 = let
//
val window = window_create ()
val button = button_create ()
//
val () = window_add_button (window, button)
//
val () = button_handle_clicked (button)
val () = window_handle_destroy (window)
val () = window_handle_delete_event (window)
//
val () = gtk_widget_show (window)
val () = gtk_widget_show_unref (button)
//
in
  window
end // end of [mymain]
')

The interface for some of the functions in the above code
is given as follows:

#atscode('\
//
extern
fun window_create (): GtkWindow1
extern
fun button_create (): GtkButton1
extern
fun window_add_button (!GtkWindow1, !GtkButton1): void
extern
fun button_handle_clicked (!GtkButton1): void
extern
fun window_handle_destroy (!GtkWindow1): void
extern
fun window_handle_delete_event (!GtkWindow1): void
//
')

The type #stacode("GtkWindow1") is for a GTK-window that cannot be null.
Similarly, the type #stacode("GtkButton1") is for a GTK-button that cannot
be null. Note that both #stacode("GtkWindow1") and #stacode("GtkButton1")
are linear.  The function #dyncode("window_add_button") adds a GTK-button
into a GTK-window.  The functions #dyncode("button_handle_clicked"),
#dyncode("window_handle_destroy"), and
#dyncode("window_handle_delete_event") are called to connect signal
handlers with given GTK-widgets.

")

#para('\

The function #dyncode("window_create") is implemented as follows:

#atscode('\
implement
window_create () = let
  val widget =
    gtk_window_new (GTK_WINDOW_TOPLEVEL)
  val ((*void*)) = assertloc (ptrcast(widget) > 0)
in
  widget
end // end of [window_create]
')

')

#para('\

The function #dyncode("button_create") is implemented as follows:

#atscode('\
implement
button_create () = let
  val widget =
    gtk_button_new_with_label ((gstring)"Hello, world!")
  val ((*void*)) = assertloc (ptrcast(widget) > 0)
in
  widget
end // end of [button_create]
')

Note that the argument of #dyncode("gtk_button_new_with_label")
determines the label on the created button when the latter is displayed.

')

#para('\

The function #dyncode("window_add_button") is implemented as follows:

#atscode('\
implement
window_add_button
  (window, button) = let
//
val () =
gtk_container_set_border_width (window, (guint)10)
//
in
//
gtk_container_add (window, button)
//
end (* end of [window_add_button] *)
')

where the funtion #dyncode("gtk_container_add") adds a GTK-widget into a
GTK-container. We will encounter functions for adding multiple GTK-widgets
into a GTK-container later.

')

#para('\

The function #dyncode("button_handle_clicked") is implemented as follows:

#atscode('\
implement
button_handle_clicked
  (button) = () where
{
//
fun f (): void = println! ("Hello, world!")
//
val id =
g_signal_connect
(
  button, (gsignal)"clicked", G_CALLBACK(f), (gpointer)NULL
) (* end of [val] *)
//
} (* end of [button_handle_clicked] *)
')

where the function #dyncode("g_signal_connect") is called to connect a
signal handler with a widget (given as its first argument).

')

#para('\

The function #dyncode("window_handle_destroy") is implemented as follows:

#atscode('\
implement
window_handle_destroy
  (window) = () where
{
//
val id =
g_signal_connect
(
  window, (gsignal)"destroy", G_CALLBACK(gtk_main_quit), (gpointer)NULL
) (* end of [val] *)
//
} (* end of [window_handle_destroy] *)
')

Note that a call to #dyncode("gtk_main_quit") terminates the main loop of GTK.

')

#para('\

The function #dyncode("window_handle_delete_event") is implemented as follows:

#atscode('\
implement
window_handle_delete_event
  (window) = () where
{
//
fun f (x: GtkWindow1): gboolean =
  let val () = gtk_widget_destroy0 (x) in GTRUE end
//
val id =
g_signal_connect
(
  window, (gsignal)"delete-event", G_CALLBACK(f), (gpointer)NULL
) (* end of [val] *)
//
} (* end of [window_handle_delete_event] *)
')

In GTK, a handler for a signal of a name ending with #dyncode("event")
seems to be required to return a boolean value (of the type
#stacode("gboolean")).  That the handler #dyncode("f") returns
#dyncode("GTRUE") in the above code means that the handling of
#dyncode("delete-event") signal is finished (and thus no more handlers are
to be invoked for it). Also note that calling the function
#dyncode("gtk_widget_destroy0") on a widget sends a #dyncode("destroy")
signal to the widget. In this case, the signal triggers a call to
#dyncode("gtk_main_quit"), which terminates the main loop of GTK.

')

#para('\

The entirety of the presented code can be found in
#mycodelink("chap_hello.dats", "chap_hello.dats"), and there is a
#mycodelink("Makefile", "Makefile") available for compiling the file.

')

</chapter>#comment("chapter/hello_world")

#comment(" ****** ****** ")

#comment(" end of [chap_hello.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "chap_hello_atxt.txt")
%}
